<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[可变模板参数(c++11新特性)]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Variadic Templates Variadic Templates谈的是template function template class template 变化的是template parameters 参数个数：利用参数个数注意递减的特性，实现递归函数调用．使用function template完成 参数类型：利用参数个数逐一递减，参数类型也逐一递减的特性，实现递归继承或递归复合，以class template完成． 可变模板参数写的一个小例子针对函数模板参数包，函数参数类型包，函数参数包 123456789void print() &#123;&#125; //非模板，和模板的实例形成重载函数；函数没有特化和偏特化template&lt;typename T, typename... Types&gt;void print(const T &amp;firstArg, const Types &amp;... args) &#123; // firstArg是包中第一个元素的引用，输出包中剩余元素个数 cout &lt;&lt; sizeof...(args) &lt;&lt; " "; cout &lt;&lt; firstArg &lt;&lt; endl; print(args...); // 当args为空时，调用的是非模板函数print&#125; 可变模板参数实现hash function1234567891011121314151617181920212223242526template&lt;typename T&gt;inline void hash_combine(size_t &amp;seed, const T &amp;val) &#123; seed ^= std::hash&lt;T&gt;()(val) + 0x9e3779b9 // 0x9e3779b9黄金比例 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);&#125;template&lt;typename T&gt;inline void hash_val(size_t &amp;seed, const T &amp;val) &#123; hash_combine(seed, val);&#125;template&lt;typename T, typename...Types&gt;inline void hash_val(size_t &amp;seed, const T &amp;val, const Types &amp;...args) &#123; hash_combine(seed, val); hash_val(seed, args...);&#125;// 版本1// typename...Types：任意个模板参数// 第一个函数不是size_ttemplate&lt;typename...Types&gt;inline size_t hash_val(const Types &amp;...args) &#123; size_t seed = 0; hash_val(seed, args...); return seed;&#125; 可变模板参数实现printf1234567891011121314151617181920212223242526void printf(const char *s) &#123; while (*s) &#123; if (*s == '%' &amp;&amp; (*(++s) != '%')) &#123; throw std::runtime_error("invalid formal string::missing arguments"); &#125; cout &lt;&lt; *s++; &#125;&#125;template&lt;typename T, typename... Args&gt;void printf(const char *s, T value, Args... args) &#123; while (*s) &#123; if (*s == '%' &amp;&amp; (*(++s)) != '%') &#123; cout &lt;&lt; value; printf(++s, args...); return; &#125; cout &lt;&lt; *s++; // 如果s不是用于格式控制，则直接输出s &#125; throw std::logic_error("extra argument provided to printf");&#125;void test_printf() &#123; printf("%d\n%s\n%f\n", 15, "This is Alice", 3.1415926); printf("%d, %s, %f\n", 15, "This is Alice", 3.1415926);&#125; variadic templates与initializer_list若参数的类型相同，无须使用variadic templates,使用initializer_list&lt;T&gt;即可 使用initializer_list实现max 12345678910111213141516171819202122232425262728293031323334template&lt;typename __ForwardIterator, typename __Compare&gt;__ForwardIterator __max_element(__ForwardIterator __first, __ForwardIterator __last, __Compare _comp) &#123; if (__first == __last) &#123; return __first; &#125; __ForwardIterator __result = __first; while (++__first != __last) &#123; if (_comp(__result, __first)) __result = __first; &#125; return __result;&#125;// _Iter_less_iter是一种类型inline __Iter_less_iter __iter_less_iter() &#123; return __Iter_less_iter();&#125;template&lt;typename __ForwardIterator&gt;inline __ForwardIterator max_element(__ForwardIterator __first, __ForwardIterator __last) &#123; // _iter_less_iter()是一个函数调用，但是返回一个对象 return __max_element(__first, __last, __iter_less_iter());&#125;template&lt;typename _Tp&gt;inline _Tpmax(initializer_list&lt;_Tp&gt; _l) &#123; return *max_element(_l.begin(), _l.end());&#125;// 调用形式：max(&#123;1,2,43,2,41&#125;); 使用varadic templates实现max 123456789101112int maximum(int n) &#123; return n;&#125;template&lt;typename... Args&gt;int maximum(int n, Args... args) &#123; return max(maximum(args...), n);&#125;void test_maximum() &#123; cout &lt;&lt; maximum(57, 48, 60, 100, 20, 18) &lt;&lt; endl;&#125; 对异于一般的方式处理first元素和last元素12345678910111213141516171819202122232425template&lt;int IDX, int MAX, typename... Args&gt;struct PRINT_TUPLE &#123; static void print(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123; os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1 == MAX ? &quot;&quot; : &quot;,&quot;); PRINT_TUPLE&lt;IDX + 1, MAX, Args...&gt;::print(os, t); &#125;&#125;;// 当前元素是最后一个template&lt;int MAX, typename...Args&gt;struct PRINT_TUPLE&lt;MAX, MAX, Args...&gt; &#123; static void print(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123;&#125;&#125;;template&lt;typename... Args&gt;ostream &amp;operator&lt;&lt;(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123; PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t); return os;&#125;void test_print_tuple() &#123; cout &lt;&lt; make_tuple(1.4, &quot;hello&quot;, 13, string(&quot;good&quot;)) &lt;&lt; endl;&#125; 可变模板参数实现tuple通过private 继承实现复合递归的继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template&lt;typename...Values&gt;class tuple;template&lt;&gt;class tuple&lt;&gt; &#123;&#125;;// private继承template&lt;typename Head, typename... Tail&gt;class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt; &#123; typedef tuple&lt;Tail...&gt; inherited;protected: Head m_head;public: tuple() &#123;&#125; // inherited(vtail...)调用base ctor并给予参数(不是创建temp object) tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) &#123;&#125; // 原始构想是取出Head指定的类型，但是head类型如何知道自己是什么type？// typename Head::type head() &#123; return m_head; &#125; // 通过decltype获取Head // m_head必须声明在此句之前 // auto head() -&gt; decltype(m_head) &#123; return m_head; &#125; // 更好的等价写法 // 可以直接这么写，Head本身就是指的类型 // Head head() &#123; return m_head; &#125; // return后转型为inherited // 返回值一定得是引用 // 调用tail之后，得到一个inhertied子对象，然后再对此子对象调用head时会改变此子对象，但是如果传回的是值(而非引用)，则被改变的是副本 inherited &amp;tail() &#123; return *this; &#125;&#125;;void test_tuple() &#123; tuple&lt;int, float, string&gt; t(41, 6.3, "nico"); cout &lt;&lt; sizeof(string) &lt;&lt; " " &lt;&lt; sizeof(int) &lt;&lt; " " &lt;&lt; sizeof(float) &lt;&lt; endl; // 32 4 4 cout &lt;&lt; sizeof(t) &lt;&lt; endl; // 40 cout &lt;&lt; t.head() &lt;&lt; endl; // 40 cout &lt;&lt; t.tail().head() &lt;&lt; endl; // 6.3 cout &lt;&lt; t.tail().tail().head() &lt;&lt; endl; // nico&#125; 通过composite实现复合1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这两句存在的意义是什么？换言之，为什么需要这两句template&lt;typename... Values&gt; class tup;// 特化版本template&lt;&gt; class tup&lt;&gt; &#123; public: tup() &#123; cout &lt;&lt; "empty tup" &lt;&lt; endl; &#125; &#125;;// 特化版本template&lt;typename Head, typename...Tail&gt; class tup&lt;Head, Tail...&gt; &#123; typedef tup&lt;Tail...&gt; compositied; protected: compositied m_tail; Head m_head; public: tup() &#123;&#125;; // vtail...是一个函数参数包 tup(Head v, Tail... vtail) : m_head(v), m_tail(vtail...) &#123; cout &lt;&lt; m_head &lt;&lt; " " &lt;&lt; sizeof...(vtail) &lt;&lt; endl; &#125; Head head() &#123; return m_head; &#125; compositied &amp;tail() &#123; return m_tail; &#125; &#125;;void test_tup() &#123; tup&lt;int, float, string&gt; it1(41, 6.3, "nico"); cout &lt;&lt; endl; cout &lt;&lt; sizeof(it1) &lt;&lt; endl; cout &lt;&lt; it1.head() &lt;&lt; endl; cout &lt;&lt; it1.tail().head() &lt;&lt; endl; cout &lt;&lt; it1.tail().tail().head() &lt;&lt; endl;&#125; 运行结果 1234567891011# 由内到外构造对象empty tupnico 06.3 141 2# 依次输出tup中的内容56416.3nico]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>variadic templates</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++2.0新特性]]></title>
    <url>%2F2019%2F09%2F21%2Fc%2B%2B11%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[此文档整理c++11中新特性． 语言： Variadic Templates move Semantics auto auto和decltype的区别与联系 range base for Initializer list Lambdas type_traits Unordered Containers forward_list array explicit tuple Con-currency RegEx Initializer list1234int values[]&#123;1,2,3&#125;;vector&lt;int&gt; v&#123;2,3,4,5&#125;;vector&lt;string&gt;cities&#123;"hello","hi"&#125;;complext&lt;double&gt; c&#123;4.0, 3.0&#125;; 当编译器看到{t1,t2,…,tn}便做出一个initializer_list,它关联至一个array&lt;T,n&gt;．调用函数（如ctor)时该array内的元素可被编译器分解逐一传给函数．但是，若函数的参数是initializer_list&lt;T&gt;，调用者却不能给予数个T参数然后以为它们会被自动转为一个initializer_list&lt;T&gt;传入． 对于vector&lt;string&gt;cities{“hello”,”hi”}; {“hello”,”hi”}形成了一个initializer_list&lt;string&gt;，背后有个array&lt;string,2&gt;，调用vector&lt;string&gt; ctor时编译器找到一个vector&lt;string&gt; ctor接受initializer_list&lt;string&gt;．所有容器都有这样的ctor． complext&lt;double&gt; c{4.0, 3.0}; 这形成一个initializer_list&lt;string&gt;，背后有个array&lt;double,2&gt;．调用complext&lt;double&gt; ctor时该array内的2个元素被分解传给ctor．因为complex&lt;double&gt;并无任何ctor接受initializer_list． initializer_list的使用在函数中使用initializer_list传递不定个参数 12345678910void print(initializer_list&lt;int&gt; vals) &#123; for (auto p = vals.begin(); p != vals.end(); ++p) &#123; cout &lt;&lt; *p &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void test() &#123; print(&#123;12, 3, 5, 7, 13, 17&#125;);&#125; 在类中使用initializer_list 12345678910111213141516171819202122class P &#123;public: P(int a, int b) &#123; cout &lt;&lt; "P(int, int): a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; P(initializer_list&lt;int&gt; initlist) &#123; cout &lt;&lt; "P(initializer_list&lt;int&gt;), values="; for (auto i:initlist) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;;void test1() &#123; // 若同时存在两个构造函数，如上 P p(77, 5); // 调用构造函数 P(int, int): a=77 b=5 P q&#123;77, 5&#125;; // 调用构造函数 P(initializer_list&lt;int&gt;), values=77 5 P r&#123;77, 5, 42&#125;; // P(initializer_list&lt;int&gt;), values=77 5 42 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125; 123456789101112131415void test2() &#123; // 若仅存在构造函数P(int, int) P p(77, 5); // 调用构造函数 P(int, int): a=77 b=5 P q&#123;77, 5&#125;; // 调用构造函数 P(initializer_list&lt;int&gt;), values=77 5 // P r&#123;77, 5, 42&#125;; // 无法使用这种方式创建对象 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125;void test3() &#123; // 若仅存在构造函数P(initializer_list&lt;int&gt; initlist) // P p(77, 5); // 无法使用这种方式创建对象 P q&#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5 P r&#123;77, 5, 42&#125;; // P(initializer_list&lt;int&gt;), values=77 5 42 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125; 在标准库容器和算法中使用initializer_list 1234567891011121314151617vector&lt;int&gt; v1&#123;11, 22, 454, 33&#125;;vector&lt;int&gt; v2(&#123;11, 22, 454, 33&#125;);for (auto i:v2) &#123; cout &lt;&lt; i &lt;&lt; " ";&#125;cout &lt;&lt; endl;vector&lt;int&gt; v3&#123;1, 2, 3&#125;;v3.insert(v3.begin() + 1, &#123;11, 22, 33, 55&#125;);for (auto i:v3) &#123; cout &lt;&lt; i &lt;&lt; " ";&#125;cout &lt;&lt; endl;cout &lt;&lt; max(&#123;string("hello"), string("good"), string("stacy"), string("nice")&#125;) &lt;&lt; endl;cout &lt;&lt; min(&#123;string("hello"), string("good"), string("stacy"), string("nice")&#125;) &lt;&lt; endl;cout &lt;&lt; max(&#123;11, 24, 25, 44, 10&#125;) &lt;&lt; endl; initializer_list的实现1234567891011121314151617181920212223242526272829303132template&lt;class _E&gt; class _initializer_list &#123; public: typedef _E value_type; typedef const _E &amp;reference; typedef const _E &amp;const_reference; typedef size_t size_type; typedef const _E *iterator; typedef const _E *const_iterator; private: iterator _M_array; // array的头 size_type _M_len; // array的长度 // 编译器实现准备好一个array,并把array的首地址和长度记录下来 constexpr _initializer_list(const_iterator _a, size_type _l) : _M_array(_a), _M_len(_l) &#123;&#125; public: constexpr _initializer_list() noexcept : _M_array(0), _M_len(0) &#123;&#125; constexpr size_type size() const noexcept &#123; return _M_len; &#125; constexpr const_iterator begin() const noexcept &#123; return _M_array; &#125; constexpr const_iterator end() const noexcept &#123; return begin() + _M_len; &#125; &#125;; explicit对于仅有单一实参（也可能是有n(n&gt;=2)个参数，但是n-1个参数都有默认实参）的构造函数，指定expliciit表示不允许隐式转换． 对于多个实参的构造函数，指定explicit表示不允许进行隐式转换．如果没有指定explicit，那么对于多个实参的构造函数也可以进行隐式转换． 123456789101112class P &#123; public: P(int a, int b, int c) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; " c=" &lt;&lt; c &lt;&lt; endl; &#125;&#125;;void test1() &#123; // 多实参的隐式转换 P p = &#123;1, 2, 3&#125;; //&#125; 运行结果： 1a=1 b=2 c=3 Alias Template(template typedef)与模板模板参数相关． 12345template&lt;typename T&gt;using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;; // 为vector指定别名// 使用别名Vec&lt;int&gt; coll; type Alias12345678typedef void(*func)(int, int); // func是一个返回值为void,两个int参数的函数指针类型// 下面是等价写法using func = void (*)(int,int);// 给函数指针赋值void example(int,int)&#123;&#125;func fn = example; usingusing的三种用法 using-directives 123using namespace std;using std::cout; using-declarations 12345class Derived:public Base&#123; protected: using Base::_M_alloc; using Base::_M_deallocate;&#125; type alias and alias template 1234template&lt;typename&gt;struct Container&#123; using value_type = T;&#125; 12345// type alias used to hide a template parametertemplate&lt;class CharT&gt; using mystring = std::basic_string&lt;CharT,std::char_traits&lt;CharT&gt;&gt;;// mystring是模板，mystring&lt;char&gt;才是类型mystring&lt;char&gt; str; noexceptfinalfinal有两种用法： 修饰class，禁止类被继承 修饰virtual function，禁止virtual function被重写 decltypedecltype可以找出一个表达式的类型．decltype有三种用法： 声明一个type作为返回类型 1234template&lt;typename T1, typename T2&gt;auto add(T1 x, T2 y) -&gt; decltype(x + y) &#123; return x + y;&#125; 在metaprogramming中使用 取一个表达式的类型 1234567891011121314template&lt;typename T&gt;void test_decltype(T obj) &#123; typedef typename decltype(obj)::iterator iType; // 相当于typedef typename T::iterator iType iType it = obj.begin(); if (it != obj.end()) &#123; cout &lt;&lt; "not empty container" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "empty container" &lt;&lt; endl; &#125; decltype(obj) anoObj(obj); cout &lt;&lt; "anoObj.size(): " &lt;&lt; anoObj.size() &lt;&lt; endl; cout &lt;&lt; endl;&#125; 面对lambda，往往只有object,没有type，要获得其类型就需要借助于decltype． 12345678910111213141516171819class Person &#123; public: Person(string _firstName, string _lastName) : fname(_firstName), lname(_lastName)&#123;&#125; string firstName() const &#123; return fname; &#125; string lastName() const &#123; return lname; &#125; private: string fname; string lname;&#125;;auto comp = [](const Person &amp;p1, const Person &amp;p2) &#123; return p1.lastName() &lt; p2.lastName() || (p1.lastName() == p2.lastName() &amp;&amp; p1.firstName() &lt; p2.firstName(); &#125;; set&lt;Person, decltype(comp)&gt; coll(comp); lambda]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>c++11新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载和重写]]></title>
    <url>%2F2019%2F09%2F21%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重载是指在同一作用域内的几个函数名字相同但形参列表不同，称这些函数为重载函数．重写(override)是指子类中对父类的虚函数不继承其实现，而重新实现． 两个除了返回类型外其他所有要素都相同的函数不是重载函数．顶层const不影响形参的类型． 12Record lookup(Phone); Record lookup(const Phone); //重复声明了Record lookup(Phone) 但底层const可以区分两个函数．即如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载． 12Record lookup(Account&amp;); // 函数作用于Account的引用Record lookup(const Account&amp;); // 新函数，作用于常量引用 编译器可以通过实参是否是常量来推断应该调用哪个函数．因为const不能转换成其他类型，所以我们只能把const对象(指向const对象的指针)传递给const形参．但是非常量对象可以转换成const，所以上面两个函数都可以作用于非常量对象，但是当实参是非常量对象时，编译器会优先选择非常量版本的函数． 重写(override)是指子类中对父类的虚函数不继承其实现，而重新实现． const_cast和重载 12345678const string &amp;shorterString2(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size() ? s1 : s2;&#125;string &amp;shorterString2(string &amp;s1, string &amp;s2) &#123; auto &amp;r = shorterString2(static_cast&lt;const string &amp;&gt;(s1), static_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(r);&#125;]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的5大控制成员]]></title>
    <url>%2F2019%2F09%2F21%2F%E7%B1%BB%E7%9A%84%EF%BC%95%E5%A4%A7%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[类的5大控制成员包括： 概念构造函数是类用来控制其对象初始化过程的函数，构造函数的任务是初始化类对象的数据成员．无聊何时只要创建类的对象，就会调用构造函数．与其他成员函数不同，构造函数没有返回类型；构造函数不能被声明为const．当我们创建一个类的const对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性． 默认构造函数当对象被默认初始化或值初始化时自动执行默认构造函数．默认初始化在以下情况下发生：值初始化在以下情况下发生： 拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数． 拷贝初始化通常由拷贝构造函数来完成．但是如果一个类有一个移动构造函数，则拷贝初始化会使用移动构造函数而非拷贝构造函数来完成．总之，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的． 合成的拷贝构造函数与默认构造函数不同, 即使类中存在其他构造函数, 编译也会自动合成一个拷贝构造函数.合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中,编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中. 每个成员的类型决定了它如何拷贝:对于类类型成员,会使用其拷贝构造函数来拷贝;内置类型的成员直接拷贝. 虽然数组不能直接拷贝,但是合成拷贝构造函数会逐元素地拷贝一个数组类型的成员.如果数组元素是类类型,则使用元素的拷贝构造函数来进行拷贝. 直接初始化和拷贝初始化直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数.使用拷贝初始化则要求编译器将右侧运算对象拷贝到我们正在创建的对象中.如果必要的话还需要进行类型转换.拷贝初始化要么通过拷贝构造函数,要么通过移动构造函数完成.拷贝初始化在以下情况下发生： 当我们用=定义变量时将一个对象作为实参传递给一个引用类型的形参从一个返回类型为非引用类型的函数返回一个对象用花括号列表初始化一个数组中的元素或一个聚合类中的成员 拷贝赋值运算符赋值运算符返回一个指向其左侧运算对象的引用． 析构函数构造函数初始化对象的非static数据成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员．在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁． 移动构造函数移动赋值运算符关联如果类的设计者没有声明，那么编译器会为它声明一个拷贝构造函数，一个拷贝赋值运算符函数和一个析构函数．如果类的设计者没有声明任何构造函数，那么编译器会为类声明一个默认构造函数．所有这些版本都是public且inline．默认的拷贝构造函数的功能： 以上五个函数统称为拷贝控制操作．各个拷贝控制操作之间的关系是： 一个类如果包含指针数据成员，那么需要一个析构函数来释放动态分配的内存． 通常如果一个类需要一个析构函数，那么它也需要一个拷贝构造函数和一个拷贝赋值运算符．但需要拷贝或赋值操作时，不一定需要析构函数．如果一个类需要一个拷贝构造函数，那么它也需要一个拷贝构造函数． 实例下面实现一个string类，命名为String．首先类的声明如下： 1234567891011121314151617class String &#123;public: explicit String(const char *cstr = 0); String(const String &amp;str); String &amp;operator=(const String &amp;str); ~String(); char *get_c_str() const &#123; return m_data; &#125;private: char *m_data;&#125;; 单参数构造函数接下来我们来看构造的函数的实现．单参数构造函数有一个默认实参，所以，这个构造函数是默认构造函数．explicit关键字的存在是为了防止从char*到String的隐式转换． 123456789inline String::String(const char *cstr) &#123; if (cstr) &#123; m_data = new char[std::strlen(cstr) + 1]; strcpy(m_data, cstr); &#125; else &#123; m_data = new char[1]; // 这里分配一个长度为1的数组是为了与上面搭配 *m_data = '\0'; &#125;&#125; 在实现中，首先检查cstr是否是空指针，若是空指针，说明当前字符串是个空字符串．那么仅分配一个字节，存在字符串结束标志’\0’．否则，分配足够的空间，并将字符串指针cstr所指向的字符串拷贝到新分配的空间中． strcpy函数会拷贝整个源字符串到目的字符串中，包括结尾处的空字符’\0’ 析构函数然后我们来看析构函数．因为String类是一个class with pointer，因此需要在析构函数中销毁指向指向的对象并销毁其占用的内存． 123inline String::~String() &#123; delete[] m_data; // 销毁底层字符串并释放字符串占用的空间&#125; delete运算符调用m_data指向的对象的析构函数销毁对象，并调用operator delete([])标准库函数释放内存空间． 拷贝构造函数拷贝构造函数采用的是深拷贝．当目的String对象从源String对象中拷贝的不仅仅是指针，还需要为目的String对象分配内存空间，并拷贝源String对象字符串的内容． 1234String::String(const String &amp;str) &#123; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); &#125; 拷贝赋值运算符函数首先，拷贝赋值运算符函数的功能是将source str的内容拷贝给dest str，dest str是一个已经存在的对象，因此，它不是拷贝赋值运算符函数的local object，所以可以返回dest str的一个引用．接下来，我们需要实现最难实现的拷贝赋值运算符函数．在实现拷贝赋值运算符函数过程中，需要考虑的第一个问题是自我赋值． 第一版：检测并避免了自我赋值 123456789101112String &amp;String::operator=(const String &amp;str) &#123; // 检测自我赋值 if (this == &amp;str) &#123; return *this; &#125; //清除旧的数据，为新的数据分配空间，令m_data指向新分配的数据 delete m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this;&#125; 上面的代码尽管避免了自我赋值，却不具备异常安全性．具体而言，*m_data = new char[strlen(str.m_data) + 1]; *可能会因为内存不足等原因而出错．一旦出错，就会导致，m_data指向一块已经被释放的内存空间． 因此我们仍然需要考虑如何实现异常安全性． 第二版：防止在内存分配成功之前释放旧的内存空间 1234567String &amp;String::operator=(const String &amp;str) &#123; char *m_old = m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); delete m_old; return *this;&#125; 在这一版本的代码中，我们实现了先保证新的内存空间能够分配成功，分配成功之后，再将旧的字符串拷贝到新内存中，然后再销毁旧的字符串并释放内存空间． 第三本版：copy and swap计数实现异常安全性copy和swap在于＂修改对象的副本，然后在一个不抛异常的函数中将修改后的数据和原件置换＂．首先需要定义个public member swap，负责实现两个String类型的置换，这个函数不允许抛异常． 12345// member swap:不允许抛异常void String::swap(String &amp;other) &#123; using std::swap; swap(m_data, other.m_data); // 直接交换两个指针&#125; 此后在std命名空间中全特化swap的String． 123456namespace std &#123; template&lt;&gt; void swap&lt;String&gt;(String &amp;a, String &amp;b) &#123; a.swap(b); // 调用String的public swap成员函数 &#125;&#125; 或者是定义一个non-member swap． 12345// non-member swap,调用了public member swap// 且non-member swap会先于std::swap被匹配void swap(String &amp;a, String &amp;b) &#123; a.swap(b);&#125; 在std命名空间中的全特化swap和non-member swap中都调用了public member swap来实现真正的置换过程．最后，我们可以实现拷贝赋值运算符函数的实现如下． 1234567String &amp;String::operator=(const String &amp;str) &#123; String tmp(str); using std::swap; // 令std::swap在此函数内可用 swap(*this, tmp); return *this;&#125; 测试最后为了测试，准备一个输出运算符重载的non-member函数． 12345678std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const String &amp;rhs) &#123; // 为了测试，当字符串为空时，输出empty String if (*rhs.get_c_str() == '\0') &#123; out &lt;&lt; "empty String"; &#125; out &lt;&lt; rhs.get_c_str(); return out;&#125; 测试程序如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include "String.h"using namespace std;int main() &#123; String s1; char p[] = "hello"; String s2(p); cout &lt;&lt; "s1:" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; "s2:" &lt;&lt; s2 &lt;&lt; endl; char p1[] = "good"; String s3(p1); cout &lt;&lt; "s3:" &lt;&lt; s3 &lt;&lt; endl; s1 = s3; cout &lt;&lt; "s1:" &lt;&lt; s1 &lt;&lt; endl; String s4(s2); cout &lt;&lt; "s4:" &lt;&lt; s4 &lt;&lt; endl; return 0;&#125; 运行结果： 12345s1:empty Strings2:hellos3:goods1:goods4:hello]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>析构函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++2.0新特性]]></title>
    <url>%2F2019%2F09%2F21%2Fc%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[此文档整理c++11中新特性． autoauto和decltype的区别与联系variadic templatesrange base for]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>c++11新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[traits]]></title>
    <url>%2F2019%2F09%2F20%2Ftraits%2F</url>
    <content type="text"><![CDATA[type_traits和iterator_traits is_void的实现is_class，is_union, is_enum, is_pod的实现]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tuple]]></title>
    <url>%2F2019%2F09%2F20%2Ftuple%2F</url>
    <content type="text"></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[完全二叉树]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[如何判断一棵树是否是完全二叉树?]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++标准库]]></title>
    <url>%2F2019%2F09%2F20%2Fc%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[几个可以参考的网站：http://www.cplusplus.comhttps://en.cppreference.com/whttps://gcc.gnu.org 如何学习标准库． 标准库源码：gnu c++ 2.9.1版本．如何找到gnu c++2.9.1版本代码？ OOP: 将data和methods关联起来；GP: 将data和methods分开来． 模板分为： 分配器先谈一谈operator new()和malloc()标准库中allocator的实现往往是使用operator new和operator delete，而operator new和operator delete又调用malloc和free来分配和释放内存．SGI主要使用的是alloc．尽量减少调用malloc的次数．当使用自由链表来保存内存空间的大小时，不再需要在 set和map中都有一个rb_tree，set和rb_tree之间的关系是composition. iteratorIterator需要遵循的原则 value_type: Iterator所指向的元素的类型 difference_type: 两个Iterator之间的距离 iterator_category: Iterator有5种类型：输入迭代器，输出迭代器，单向迭代器，双向迭代器(bidirectional_iterator_tag)，随机迭代器(random_access_iterator_tag) 后面两种很少被用到． reference pointer traits机制 如果Iterator是类类型，可以在类中定义value_type等，但若Iterator不是类类型，而是native pointer(native pointer也是一种迭代器).特性萃取机必须有能力分辨它所获取的iterator是class Iterator T还是native pointer to T． type traits &lt;c++/type_traits&gt; type_traits不属于stl，但属于标准库． iterator traits &lt;c++/bits/stl_iterator.h&gt; 属于stl． char traits &lt;c++/bits/char_traits.h&gt;allocator traits &lt;c++/bits/alloc_traits.h&gt;pointer traits &lt;c++/bits/ptr_traits.h&gt;array traits &lt;c++/array&gt; 容器 迭代器类型 array random_access_iterator vector random_access_iterator deque random_access_iterator list bidirectional_iterator forward list forward_iterator rb tree bidirectional_iterator unordered containers 取决于底层的链表是单向还是双向的 istream_iterator的iterator_category某些类之间的继承关系是为了继承typedef outstream_iterator的iterator_category 算法分类（iterator category）和type traits对算法效率的影响： distance advance copy copy_unique 容器vectorvector和array的区别是：array的空间固定，一旦用尽，如果用户还希望使用更多空间，需要自己分配一个更大容量的array，并把旧的元素搬到新的array中，然后将旧的array的内存空间还给系统．而vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素．vector每次扩充空间都分配当前容量两倍的空间． array array没有ctor，dtorarray与其他容器的区别在于，它需要一个size_t类型参数，表示数组的大小．array的迭代器就是指针T* deque扩充：分配一个缓冲区． reallocate_map情形1: map_size = 14, old_num_nodes = 4, nodes_to_add = 2, add_at_front = truenew_num_nodes = 6;map_size &gt; 2 * new_num_nodes 如下图1所示： 接下来我们计算，new_start = map + (14-6)/2 + 2 = map + 6 之后，移动元素，修改start和finish迭代器所在的位置．蓝色部分是新配置的两个map_node. 情形2: map_size = 6, old_num_nodes = 3, nodes_to_add = 1, add_at_front = truenew_num_nodes = 4;map_size &lt; 2 * new_num_nodesnew_map_size = 6 + 6 + 1 = 13new_start = new_map + (13 - 4) / 2 + 2 = new_map + 6 蓝色部分是新配置的map_node hashtableseperate chaing当bucket中的链表过长时，就说明冲突的可能性很大了，需要扩容．扩容过程：首先分配一块更大的内存，新内存的容量是大于旧的内存的两倍的一个质数．stl源码中准备了28个质数备用．然后将旧内存中的每一个元素搬到新内存中去．这个过程中需要为每一个元素重新计算位置．最后，释放旧的内存． bucket所在的内存是连续的吗？底层使用的是什么结构？buckets聚合体底层使用的是vector， 一个万能的hash FunctionAlgorithmfunctor为算法服务． 自己写functor并继承标准库的binary_function和unary_function.functor要被Adapter改造时，Adapter可能会问functor一些问题，所以，自定义的functor应该继承unary_function, binary_function等． 123456789101112template&lt;class Arg, class Result&gt;struct unary_function &#123; typedef Arg argument_type; typedef Result result_type;&#125;;template&lt;class Arg1, class Arg2, class Result&gt; struct binary_function &#123; typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;; 自定义的仿函数要能够被适配器改造，应该继承unary_function或者binary_function． Adapter通过内含的方式实现． container adapter：stack，queue functor adapteriterator adapter function Adaptable的条件是：继承unary_function或者binary_function． &lt;c++\backward\backward_warning.h&gt;reverse_iterator inserter ostream_iterator istream_iterator]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F09%2F20%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux常用命令有:grep, awk, ps等待． grep grep –color选项，高亮要查找的字符串．如，在/etc/passwd文件中查找某个字符串出现的行 12root@root:~$ grep --color "la" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false # 在我的机器上的结果 grep -v选项，实现反查效果，显示出所有不包含被查询字符串的行． 12345grep -v "la" /etc/passwd# 在我的机器上的执行结果sshd:x:123:65534::/run/sshd:/usr/sbin/nologinnvidia-persistenced:x:124:129:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin grep 展示行号和统计行数 使用-n选项，grep不仅能搜索到字符串，还能展示出它们位于文件的第几行． 使用-c选项，grep可以统计搜索结果中的总行数 12345678910root@root:~$ grep -n "la" /etc/passwd# 行首的40表示出现的行号40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot@root:~$ grep -c "la" /etc/passwd1root@root:~$ grep -c "var" /etc/passwd22 grep可以环顾四周 在输出时，同时输出搜索结果相邻的行也输出出来． -A number 表示输出搜索结果下面的行(number表示要输出的行数) A是after的缩写 -B number 表示输出搜索结果上面的行(number表示要输出的行数) B是before的缩写 12345678910111213root@root:~$ grep -A 1 "la" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot:x:1000:1000:root,,,:/home/root:/bin/bashroot@root:~$ grep -n -A 2 "la" /etc/passwd40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false41-root:x:1000:1000:root,,,:/home/root:/bin/bash42-redis:x:122:128::/var/lib/redis:/usr/sbin/nologinroot@root:~$ grep -n -A 1 -B 1 "la" /etc/passwd39-gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false41-root:x:1000:1000:root,,,:/home/root:/bin/bash grep 不区分大小写 grep -i选项不区分大小写，提高搜索命中的概率 123root@root:~$ grep --color "LA" /etc/passwdroot@root:~$ grep --color -i "LA" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false grep处理多文件 grep可以一次处理多个文件，最长使用的一个场景是:从大量文件中找出含有特定字符的文件． grep -l “query key word” *.txt从多个文件中查找含有被查询的关键词的文件有哪些，应该得到一个文件列表 grep -L “query key word” .txt反向选项，从多个文件中查找*不包含**被查询的关键词的文件有哪些，应该得到一个文件列表 123456789101112131415161718192021# 当前目录下有三个文件[roc@roclinux ~]$ lltotal 12-rw-rw-r-- 1 roc roc 58 Mar 15 17:47 1.txt-rw-rw-r-- 1 roc roc 59 Mar 15 17:51 2.txt-rw-rw-r-- 1 roc roc 58 Mar 15 17:52 3.txt # 1.txt文件的内容如下[roc@roclinux ~]$ cat 1.txtthis first filethis file contain some import infomation. # 2.txt文件的内容如下[roc@roclinux ~]$ cat 2.txtthis second filethis file contain some import infomation. # 3.txt文件的内容如下[roc@roclinux ~]$ cat 3.txtthis third filethis file contain some import infomation. 123# 使用-l选项[roc@roclinux ~]$ grep -l "first" *.txt1.txt 123[roc@roclinux ~]$ grep -L "first" *.txt2.txt3.txt grep支持正则表达式 ^sp表示以sp开头的行；se$表示以se结尾的行． 1234root@root:~$ grep '^sp' -c /etc/passwd1root@root:~$ grep 'sp' -c /etc/passwd5 1234root@root:~$ grep 'se' -c /etc/passwd7root@root:~$ grep 'se$' -c /etc/passwd5 grep查询一个词 如要搜索含有bin这个词的行 1234567891011root@root:~$ grep '\&lt;bin\&gt;' /etc/passwd --colorroot:x:0:0:root:/root:/bin/bashbin:x:2:2:bin:/bin:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncproxy:x:13:13:proxy:/bin:/usr/sbin/nologinspeech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/falsewhoopsie:x:112:117::/nonexistent:/bin/falsehplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/falsegnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/falsegdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot:x:1000:1000:root,,,:/home/root:/bin/bash 这样的词有一个问题，那就是连sbin这样的词也会被搜索出来．因此，我们需要理解词的定义，以及正则表达式中如何表示一个词．首先，正则表达式中的词(word)，一般是由字母，数字和下划线组成，且词和词之间通常使用空格，制表符或换行符分隔．举个’栗子’，“I love you.”中的“love”就是一个“词”，但“My gloves are red.”中的“love”就不能称作一个“词”。在正则表达式中，通常用尖括号表示一个词，比如能够匹配I love you.但不能匹配My gloves are red. 正则表达式awkawk命令是一个非常棒的数据处理工具．sed命令一次处理一整行，awk命令一次处理一整行，但将每行的内容分成多个字段来处理． 参考文献[1]grep: http://c.biancheng.net/linux/grep.html]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>awk</tag>
        <tag>grep</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindromic Substrings系列]]></title>
    <url>%2F2019%2F09%2F19%2FPalindromic-Substrings%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Palindromic Substrings系列 647 Palindromic Substrings5 Longest Palindromic Substring516. Longest Palindromic Subsequence647. Palindromic Substrings 647. Palindromic SubstringsMedium Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: 123Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: 123Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. Note: The input string length won’t exceed 1000. 解法1动态规划： 时间复杂度：O(n2) 空间复杂度：O(n2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[对象模型]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[多重继承下的对象模型 123456789101112131415161718192021class A &#123; public: virtual ~A() &#123;&#125;&#125;;class B &#123; public: virtual ~B() &#123;&#125;&#125;;class C : public A, public B &#123;&#125;;void test1() &#123; C *pC = new C(); A *pA = (A *) pC; B *pB = (B *) pC; cout &lt;&lt; pA &lt;&lt; endl; // 0x5652962dbe70 cout &lt;&lt; pB &lt;&lt; endl; // 0x5652962dbe78 cout &lt;&lt; pC &lt;&lt; endl; // 0x5652962dbe70&#125;]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++牛客网刷题总结]]></title>
    <url>%2F2019%2F09%2F19%2FC%2B%2B%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[字符串系列]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[memmove与memcpy]]></title>
    <url>%2F2019%2F09%2F19%2Fmemmove%E4%B8%8Ememcopy%2F</url>
    <content type="text"><![CDATA[题目链接 如图所示，绿色表示数组2的元素，杏色表示数组1的元素．蓝色表示数组1和数组2重合的位置的元素．当pstr1 &gt; pstr2时，需要逆序移动．否则，属于pstr2数组的后几个元素会被覆盖． 当pstr1 &lt; pstr2时，正向移动．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[传参]]></title>
    <url>%2F2019%2F09%2F19%2F%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[传参有值传递和引用传递两种方式．值传递用在参数较小的情况下，值传递过程中，形参和实参独立．对形参的修改不会影响实参．引用传递用在：传递的参数较大或者不支持拷贝时．引用传递可以避免拷贝实参，但对形参的修改会直接影响实参． 数组形参数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响．这两个特殊性质是： 不允许拷贝数组 使用数组时通常会将数组名转换为指向数组首元素的指针 因为不能拷贝数组，所以我们不能以值传递的方式使用数组参数．因为数组会被转换为指针，所以当我们为函数传递一个数组时，实际上传递的是一个指向数组首元素的指针（传入的数组的大小对函数调用没有影响）．三个形式不同但等价的函数声明： 123void print(const int*);void print(const int[]);void print(const int[10]); // 这里的维度表示我们希望数组含有多少个元素，但实际情况不一定 尽管形式不同，但上面三个函数是等价的：每个函数的唯一形参都是const int*类型的．当编译器处理对print函数的调用时，只检查传入的参数是否是const int *类型的(这里的const是底层的，是表示指针指向的是常量对象)．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载new和delete]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete%2F</url>
    <content type="text"><![CDATA[当应用程序对于内存分配有特殊要求时,需要重载operator new和operator delete运算符. new表达式的工作机制 new表达式的工作机理 当我们使用一条new表达式时,实际执行了三步操作. 第一步,调用名为operator new(或operator new[])的标准库函数, 分配一块足够大的, 原始的, 未命名的内存空间以便存储特定类型的对象(或对象数组). 运行相应的构造函数构造这些对象,并初始化这些对象 对象被分配了空间并构造完成,返回一个指向该对象的指针. 1234567891011121314151617181920212223class Complex &#123;public: explicit Complex(double _real = 0.0, double _vir = 0.0) : real(_real), vir(_vir) &#123;&#125;private: double real; double vir;&#125;;Complex *pc = new Complex(1, 2);//equal to:void *p = operator new(sizeof(Complex)); // 分配内存Complex *pc = static_cast&lt;Complex *&gt;(p); // 转型pc-&gt;Complex::Complex(1, 2); // 调用构造函数delete pc;//equal topc-&gt;~Complex(); // 调用对象的析构函数operator delete(p); // 释放内存空间 delete表达式的工作机理 当我们使用一条delete表达式时,实际执行了两步操作. 对delete表达式中指针所指向的对象执行相应的析构函数 调用名为operator delete(或operator delete[])的标准库函数释放对象内存空间 几个疑问为什么array new一定要搭配array delete？(array new 即new [size])？发生内存泄露不在于array new 分配的数组，而在于delete 表达式仅仅调用一次析构函数，而array delete表示调用多次(取决于array new分配的数组大小)析构函数．如果在对象的构造函数中进行了动态内存分配，那么需要在析构函数中进行释放，但是delete表达式仅仅调用一次而非多次析构函数，无法释放数组中所有对象分配的动态内存，因此会造成内存泄露． 定位new表达式可以通过自定义operator new和operator delete函数来控制内存分配过程. 但是有一个operator new函数不允许被用户重载: 1void *operator new(size_T, void*) 此形式的operator new(定位new)只供标准库使用,不允许用户重载.该函数并不分配内存,而是直接返回void参数传入的指针;然后由new表达式负责在指定的地址初始化对象以完成整个工作.即*定位new允许我们在一个特定的,预先分配的内存地址上构造对象**.传给定位new表达式的指针可以是堆内存,也可以不是. 使用定位new表达式定位new表达式的形式: new (place_address) type [n] {initializer list}其中,place-address是一个指针,指向已经分配好的内存地址, type表示要构造的对象的类型, n可选参数,表示要构造的对象的个数, {initializer list}为初始化列表用于初始化对象. 指针place_address指向的是堆内存 1234567891011void f1()&#123; double *p3, *p4; p3 = new double[N]; // 堆内存,p3指向动态分配的空间 p4 = new(p3) double[N]&#123;1.1, 2.2, 3.0, 4.6, 6.9&#125;; // 定位new允许我们在一个特定的,预先分配的内存地址上构造对象 for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p4[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 11.1 2.2 3 4.6 6.9 指针place_address指向的是静态内存 1234567891011121314151617const int BUF = 512;const int N = 5;char buffer[BUF];void f2()&#123; int *p; p = new(buffer) int[N]; // buffer是静态内存, 定义在任何函数之外的变量 for (int i = 0; i &lt; N; ++i) &#123; p[i] = i * 4; &#125; cout &lt;&lt; "静态分配的地址buffer:" &lt;&lt; (void *) buffer &lt;&lt; endl; cout &lt;&lt; "直接使用placement new的p2地址" &lt;&lt; p &lt;&lt; endl; for (int i = 0; i &lt; N; ++i) &#123; cout&lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 123静态分配的地址buffer: 0x556ab55fd140直接使用placement_new的p2地址: 0x556ab55fd1400 4 8 12 16 指针place_address指向的是栈内存 123456789void f3()&#123; string arr[N]; // 栈内存, arr中保存着定义在函数内的非static对象 string *p; p = new(arr) string[N]&#123;"hello", "world", "a", "good", "day"&#125;; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 1hello world a good day 重载operator new和operator delete重载类的operator new和operator delete首先类的声明即定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Foo &#123; public: Foo() : _id(0) &#123; cout &lt;&lt; "default ctor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; Foo(int i) : _id(i) &#123; cout &lt;&lt; "ctor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; ~Foo() &#123; cout &lt;&lt; "dtor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; static void *operator new(size_t size); static void operator delete(void *pdead, size_t size); static void *operator new[](size_t size); static void operator delete[](void *pdead, size_t size); private: int _id; long _data; string _str;&#125;;void *Foo::operator new(size_t size) &#123; Foo *p = (Foo *) malloc(size); cout &lt;&lt; "custom operator new" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; return p;&#125;void Foo::operator delete(void *pdead, size_t size) &#123; cout &lt;&lt; "custom operator delete" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; free(pdead);&#125;void *Foo::operator new[](size_t size) &#123; Foo *p = (Foo *) malloc(size); cout &lt;&lt; "custom operator new[]" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; return p;&#125;void Foo::operator delete[](void *pdead, size_t size) &#123; // 析构函数调用顺序为逆序调用，从最后一个元素到第一个元素 cout &lt;&lt; "custom operator delete[]" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; free(pdead);&#125; 测试代码： 当没有定义成员 operator new和operator delete时就调用全局的operator new和operator delete 123456789101112131415void test_foo1() &#123; // 若无members就调用globals Foo *pf = new Foo; delete pf; cout &lt;&lt; endl; Foo *parr = new Foo[1]; delete[] parr; cout &lt;&lt; endl; parr = new Foo[2]; delete[] parr;&#125; 在64位系统上，string占32个字节，int占4个字节，long占8个字节．因此，sizeof(Foo)=32+4+8=44，又因为44不是8的倍数，因此，在Foo中添加一些padding，最后sizeof(Foo)=48字节．最后的运行结果为： 12345678910111213141516custom operator new size = 48default ctor.this=0x55bda8d2be70 id=0dtor.this=0x55bda8d2be70 id=0custom operator delete size = 48custom operator new[] size = 56default ctor.this=0x55bda8d2be78 id=0dtor.this=0x55bda8d2be78 id=0custom operator delete[] size = 56custom operator new[] size = 104default ctor.this=0x55bda8d2c2c8 id=0default ctor.this=0x55bda8d2c2f8 id=0dtor.this=0x55bda8d2c2f8 id=0dtor.this=0x55bda8d2c2c8 id=0custom operator delete[] size = 104 可以看到，这里调用了自定义的operator new和operator delete函数．此外，分别使用new Foo和new Foo[1]动态分配一个Foo对象时，打印出的size不同，这是因为在operator new[]中分配的内存的最上面有一个额外内存用于记录数组中元素的个数，以备记录调用delete []时，需要调用析构函数的次数．当new Foo[2]时：size=104．首先两个Foo对象占用内存为48 * 2 = 96字节, 而在分配内存的最前端有一个counter记录数组中元素个数，因此，最后size = 96 + 8 = 104．即这个动态分配的数组在占用内存如下图所示： 此外，可以看到，在delete[]表达式中调用析构函数是逆序调用的，即数组中最后一个元素首先调用析构函数，然后倒数第二个，依次类推，直到第一个元素． 强制调用全局operator new和operator delete 12345678910void test_foo2() &#123; // 强制使用globals Foo *pf = ::new Foo; ::delete pf; cout &lt;&lt; endl; Foo *parr = ::new Foo[2]; ::delete[] parr;&#125; 运行结果： 1234567default ctor.this=0x55e231ba2e70 id=0dtor.this=0x55e231ba2e70 id=0default ctor.this=0x55e231ba32c8 id=0default ctor.this=0x55e231ba32f8 id=0dtor.this=0x55e231ba32f8 id=0dtor.this=0x55e231ba32c8 id=0 重载placement new我们可以重载class member operator new()，写出多个版本，前提是每一版本的声明都必须有独特的参数列，其中第一参数必须是size_t，其余参数是以new所指定的placement arguments为初值．出现于new(…)小括号内的便是所谓placement arguments． 1Foo* pf = new (300, 'c')Foo; 我们也可以重载class member operator delete()（或者称此为placement operator delete），写出多个版本．但它们绝不会被delete调用．只有当new所调用的ctor抛出exception时，才会调用这些重载版的operator delete()．它只能这样被调用，主要用来归还未能完全创建成功的object所占用的memory． new表达式的作用域查找规则]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bind与函数适配器]]></title>
    <url>%2F2019%2F09%2F19%2Fbind%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[bind是从c++11开始出现的新型适配器]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[subSets]]></title>
    <url>%2F2019%2F09%2F19%2FsubSets%2F</url>
    <content type="text"><![CDATA[Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 题目链接 方法一一次处理一位，循环处理每一位即可．比如对于题目中给的例子 [1,2,3] 来说，最开始是空集，接下来首先处理第一位1，于是就在空集上加1，为 [1]，现在我们有两个子集 [] 和 [1]．然后来处理2，我们在之前的子集基础上，每个都加个2，可以分别得到 [2]，[1, 2]，那么现在所有的子集合为 [], [1], [2], [1, 2]，用同样的方法处理3可得 [3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合． 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; subsetsCore(0, nums, tmp, res); return res; &#125; void subsetsCore(int pos, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; res.push_back(tmp); for(int i=pos;i&lt;nums.size();++i)&#123; tmp.push_back(nums[i]); subsetsCore(i+1, nums, tmp, res); tmp.pop_back(); &#125; &#125;&#125;; 方法二: 回溯方法三思路：为数组中所有的数分配一个状态，状态0表示这个数不在子集中出现，状态1则表示这个数在子集中出现．对于一个长度为n的数组，每个数组都有出现和不出现两种情况，所以共有2n种情况．因此，把1 - 2n-1-1转换为对应的二进制形式，再将这个二进制字符串转换成子数组即可． 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int maxVal = 1 &lt;&lt; nums.size(); for(int k=0;k&lt;maxVal;++k)&#123; vector&lt;int&gt; tmp = convertIntToSet(nums, k); res.push_back(tmp); &#125; return res; &#125; vector&lt;int&gt; convertIntToSet(vector&lt;int&gt;&amp; nums, int k)&#123; vector&lt;int&gt; sub; int index = 0; for(int i=k;i&gt;0;i&gt;&gt;=1)&#123; if((i&amp;1)==1)&#123; sub.push_back(nums[index]); &#125; ++index; &#125; return sub; &#125;&#125;; Subsets II题目链接 参考文献[1] Subsets 子集合: https://www.cnblogs.com/grandyang/p/4309345.html[2] 含有重复元素的subsets子集: https://www.cnblogs.com/grandyang/p/4310964.html]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板特化]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是特化？什么是偏特化？偏特化有两种，第一种是个数上的偏．第二种是范围上的偏． 对于个数上的偏，如，模板共有2个模板参数，但是只指定1个模板参数，那么这就是偏特化．范围上的偏，如第一个模板参数，表示指向任意类型，当我们想要表示指向任意类型的指针，那么这就是范围上的偏． 1234567891011121314151617181920template&lt;typename T&gt;class C &#123; public: C() &#123; cout &lt;&lt; "generic version" &lt;&lt; endl; &#125;&#125;;template&lt;typename T&gt;class C&lt;T *&gt; &#123; public: C() &#123; cout &lt;&lt; "pointer version" &lt;&lt; endl; &#125;&#125;;void test_parial_specialization() &#123; C&lt;string&gt; obj1; // 使用泛华版本 C&lt;string *&gt; obj2; // 使用指向任意类型的指针类型&#125; 运行结果： 12generic versionpointer version 函数模板没有特化，只能重载．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>specialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可调用对象]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[可调用对象有函数,函数指针,lambda表达式,函数对象, bind创建的对象等.函数和函数指针不必多说.那么什么是函数对象呢?函数对象是一种重载了调用运算符的类类型.因为重载了调用运算符,所以我们可以像调用函数一样调用类的对象,因为称为函数对象.lambda表达式表示一个可调用的代码单元. 函数对象12345678910111213141516/** * absInt类只定义了一种操作:函数调用运算符 * 此类为函数对象 */struct absInt &#123; int operator()(int val) const &#123; return val &lt; 0 ? -val : val; &#125;&#125;;int main()&#123; absInt absObj; cout &lt;&lt; absObj(42) &lt;&lt; endl; // 42 cout &lt;&lt; absObj(-10) &lt;&lt; endl; // 10 return 0;&#125; 以上代码即定义了一个函数对象.调用该对象就像调用函数一样.仿佛该类型对象是一个函数.还可以定义有数据成员的函数对象 123456789101112131415161718class PrintString &#123;public: PrintString(ostream &amp;o = cout, char c = ' ') : os(o), sep(c) &#123;&#125; void operator()(const string &amp;s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: ostream &amp;os; char sep;&#125;;int main()&#123; PrintString printer; printer("hello"); // 输出hello PrintString errors(cerr, '\n'); string s = "wrong answer"; errors(s); // 输出wrong answer return 0;&#125; lambda表达式lambda表达式在很多语言中都有.lambda可以理解为一个未命名的内联函数,但是与普通函数不同的是,lambda可能定义在函数内部;lambda表达式必须尾置返回; lambda表达式不能有默认参数; lambda表达式的参数列表和返回类型可以省略. 那么在c++中该怎么定义一个lambda表达式呢?一个lambda表达式具有以下形式: 1[capure list](parameter list)-&gt; return type &#123;function body&#125; 其中,捕获列表(capure list)是该lambda表达式所在函数中定义的局部变量(通常为空).参数列表(parameter list), 返回类型, 返回类型(return type)和函数体(function body)与普通函数相同. 当定义一个lambda时,编译器生成一个与lambda对象的新的(未命名的)类类型.当向一个函数传递一个lambda时,同时定义了一个新类型和该类型的一个对象. 123456vector&lt;string&gt; vc&#123;"good", "to", "see", "you", "again"&#125;;for_each(vc.begin(), vc.end(), PrintString(cout, '\n')); // 函数对象// 等价的lambda表达式string sep("\n");for_each(vc.begin(), vc.end(), [sep](const string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; sep; &#125;); 使用函数对象打印出可变数组vc中的元素.同时定义了一个与函数对象PrintString等价的lambda表达式. 捕获变量与参数传递类似,捕获变量也有两种方式,值捕获和引用捕获.采用值捕获需要变量可以拷贝.与参数传递不同,被捕获的变量的值是在lambda创建时拷贝,而不是调用时拷贝.引用捕获需要保证lambda表达式执行时,该引用指向的对象仍然存在. 在一个基本类型为string类型的可变数组中找出第一个长度大于给定值sz的元素.下面分别用函数对象和lambda表达式的形式实现. 123456789101112131415161718192021222324252627class SizeCmp &#123;public: SizeCmp(size_t n) : sz(n) &#123;&#125; bool operator()(const string &amp;a) &#123; return a.size() &gt;= sz; &#125;private: size_t sz;&#125;;int main()&#123; vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;; size_t sz = 6; // 使用lambda表达式// auto wc = find_if(vc.begin(), vc.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;); // 使用等价的函数对象 auto wc = find_if(vc.begin(), vc.end(), SizeCmp(sz)); // wc 为指向第一个长度不小于给定值sz的元素的迭代器 if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl; else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; &#125; //当sz=5时,输出mango;当sz=6时,输出empty result&#125; bind参数绑定标准库的bind函数可以看做一个函数适配器.它接受一个可调用对象,生成一个新的可调用对象. 12345678910111213141516171819bool check_size(const string&amp; s, string::size_type sz)&#123; return s.size() &gt;= sz;&#125;// 给check_size函数的第一个参数绑定一个值// auto check6 = bind(check_size, std::placeholders::_1, 6);auto check6 = bind(check_size, std::placeholders::_1, 5);// 调用check6函数string s = "hello";cout &lt;&lt; check6(s) &lt;&lt; endl;vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;;auto wc = find_if(vc.begin(), vc.end(), check6);// wc 为指向第一个长度不小于给定值sz的元素的迭代器if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl;else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; 可调用对象与function每一个lambda表达式都是一种未命名的新类型;函数对象的类型是该对象的类类型;函数和函数指针的类型由参数列表和返回值决定. 多个调用对象有不同的类型,但是却共享相同的调用形式.调用形式指明了调用返回的类型以及传递给调用的实参类型(如何SizeCmp类型的函数对象和lambda表达式,类型不同,调用形式相同).一种调用形式对应一个函数类型.标准库中function模板可以表示函数类型. 123456789101112map&lt;string, function&lt;int(int, int)&gt;&gt; binops = &#123; &#123;"+", add&#125;, &#123;"-", std::minus&lt;int&gt;()&#125;, &#123;"/", Divide()&#125;, &#123;"*", [](int i, int j) &#123; return i * j; &#125;&#125;, &#123;"%", mod&#125;&#125;;cout &lt;&lt; binops["+"](10, 5) &lt;&lt; endl; // 15cout &lt;&lt; binops["-"](10, 5) &lt;&lt; endl; // 5cout &lt;&lt; binops["%"](11, 4) &lt;&lt; endl; // 3cout &lt;&lt; binops["*"](13, 2) &lt;&lt; endl; // 26 add, Divide(),mod等各个可调用对象的类型各不相同,但是它们都是调用形式为int(int, int)的可调用对象,因此可以赋值给function&lt;int(int,int)&gt;类型的对象.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>可调用对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板实参推断和引用]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板分为类模板，函数模板，还有成员模板． 编译器会对函数模板参数进行推导． 从左值引用函数参数推断类型从右值引用函数参数推断类型]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>模板</tag>
        <tag>函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树与双向链表]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[二叉搜索树与双向链表 12345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode* lastNode = nullptr; ConvertCore(pRootOfTree, lastNode); while(lastNode &amp;&amp; lastNode-&gt;left) lastNode = lastNode-&gt;left; return lastNode; &#125; void ConvertCore(TreeNode* node, TreeNode* &amp;lastNode)&#123; // lastNode表示双向链表中最后一个节点,node表示当前的根节点 // 首先考虑node的左子树，若左子树不空，则先转换左子树，并且lastNode表示左子树转换成的双向链表中 // 的最后一个节点，那么指向让node-&gt;left = lastNode,若lastNode不为空，令lastNode-&gt;right=node // 返回 if(node == nullptr)&#123; return; &#125; if(node-&gt;left)&#123; ConvertCore(node-&gt;left, lastNode); &#125; node-&gt;left = lastNode; if(lastNode!=nullptr)&#123; lastNode-&gt;right = node; &#125; lastNode = node; if(node-&gt;right!=nullptr)&#123; ConvertCore(node-&gt;right, lastNode); &#125; &#125;&#125;; 二叉树与双向链表]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类之间的关系]]></title>
    <url>%2F2019%2F09%2F16%2F%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[类之间的关系有composition(has-a)，delegation(委托)等． Composition 构造由内而外，如Container中包含Component，那么Container的构造函数首先调用Conponent的default构造函数，然后才执行自己．析构由外而内，Container的析构函数首先执行自己，然后调用Component的析构函数． Delegation 两个类之间用指针相连，称之为delegation． 1234567891011121314151617181920212223242526272829303132// handle/Body: file1为handle，file2为Body// file1 String.hpp：对外接口class StringRep;class String &#123;public: String(); String(const char *s); String(const String &amp;s); String &amp;operator=(const String &amp;s); ~String();private: StringRep *rep; // pimpl：pointer to implementation&#125;;// file2 String.cpp：字符串真正的实现在这里class StringRep &#123; friend class String; StringRep(const char *s); ~StringRep(); int count; char *rep;&#125;; 无论字符串的实现如何变化，都不影响客户端代码．String中的StringRep也可以指向不同的StringRep的实现，如可以指向StringRep的子类． 三个string共享一个字符串hello，所以共享计数n=3表示有三个String对象共享hello． 继承 继承有三种方式：public，private，protected．其中public表示is-a关系．构造由内而外．Derived的构造函数首先调用Base的default构造函数，然后才执行自己．析构由外而内．Derived的析构函数首先执行自己，然后才调用Base的析构函数． 函数的继承继承的是调用权．当一个类B以public方式继承另一个类A，那么在类A中所有的public方法在类B中也会变成public，但是当B以private方式继承类A，那么类A中所有的public方法在类B方法中变成private方法．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组和字符指针]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是数组?数组是一组类型相同元素的容器.数组中存放的对象没有名字,必须通过位置来访问.数组的大小确定不变, 一旦数组定义完成,不能再向数组中添加元素. 数组基本概念数组是一种复合类型.数组的声明形如a[d], 其中a是数组的名字,d是数组的维度.维度说明了数组中元素的个数,因此必须大于0. 数组中元素的个数也属于数组类型的一部分,编译时数组的维度必须是已知的. 适用所有数组类型 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。当对数组名称使用decltype关键字时得到的是数组对象类型。 对数组执行下标运算其实是对指向数组元素的指针执行下标运算 内置的下标运算符不是无符号数,标准库类型如vector和string限定使用的下标必须是无符号数 因为数组本身是对象,可以定义数组的指针和数组的引用 适用于字符数组 当使用字符串常量对字符数组进行初始化时, 字符串数组最后一位会被加上一个’\0’空字符但是使用strlen()计算该数组的长度时,该字符串末尾的空字符不计算在内 对字符数组进行列表初始化时,字符数组末尾没有空字符; 但是由于strlen()函数时是使用空字符来判断字符串结束的, 无法对这样的字符数组使用strlen()求长度 代码示例 字符数组初始化和求长度 字符数组初始化有两种方式,列表初始化和字符串常量初始化 字符串常量初始化时,字符串常量末尾的空字符也会拷贝到字符数组中去 12345678910111213141516void testCharArray() &#123; char a1[] = "danam"; // 计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // a1的长度为6字节,字符串字面值的末尾是一个空字符,这个空字符也会像其他字符一样拷贝到字符数组中去 cout &lt;&lt; "a1:" &lt;&lt; a1 &lt;&lt; " sizeof(a1): " &lt;&lt; sizeof(a1) &lt;&lt; " strlen(a1): " &lt;&lt; strlen(a1) &lt;&lt; endl; //a1:danam sizeof(a1): 6 strlen(a1): 5 // 对字符数组进行列表初始化,没有空字符 char a2[] = &#123;'a', 'b', 'c'&#125;; cout &lt;&lt; "a2: " &lt;&lt; a2 &lt;&lt; " sizeof(a2): " &lt;&lt; sizeof(a2) &lt;&lt; endl; // a2的长度为3字节;无法对a2使用strlen函数 // a2: abcdanam sizeof(a2): 3&#125; 运行结果 123strlen("danam"): 5a1:danam sizeof(a1): 6 strlen(a1): 5a2: abcdanam sizeof(a2): 3 数组名和指针,迭代器 数组名通常会自动转换为指向数组首元素的指针 在表达式decltype(arr)时,不会发生自动转换,decltype(arr)的返回类型是一个数组类型,其元素类型和维度都与数组arr相同 1234567891011void testCharArray1() &#123; //===============数组名和指针================= int iarr[] = &#123;1, 2, 3, 4, 5&#125;; // ia是一个指针,在这里使用数组类型对象iarr时,编译器将其替换为一个指向数组首元素的指针 auto ia(iarr); ia = &amp;iarr[1]; // decltype(ia)是一个含有5个整形元素的数组对象,因此iarr2也是一个含有5个元素的数组 decltype(iarr) iarr2 = &#123;22, 33, 444, 55, 99&#125;; iarr2[2] = 1882;&#125; 运行结果 1nice to meet you alice 指针运算 对数组执行下标运算其实是对指向数组元素的指针执行下标运算.标准库类型使用的下标类型必须是无符号类型,内置的下标运算可以是带符号类型 可以从一个指针加上或减去一个整数值,结果仍是指针 指向同一个数组中元素(包括尾元素)的指针可以相减,两个指针相减的结果是一种名为ptrdiff_t的标准库类型.ptrdiff_t类型是一种带符号类型 123456789101112131415161718192021void testCharArray3() &#123; //=======================指针运算===================== string sarr[5] = &#123;"good", "day", "you", "know", "me"&#125;; // sarr[2]是一个使用了数组名字的表达式,对数组执行下标运算其实是对指向数组元素的指针执行下标运算 string s1 = sarr[2]; //sarr转换为指向数组首元素的指针,sarr[2]得到(sarr+2)所指向的元素 string *p = sarr; //sarr转换为指向数组首元素的指针 string s2 = *(p + 2); //等价于sarr[2] cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; s2 = p[3]; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; //=======只要指针指向的是数组中的元素(或者数组中尾元素的下一位置),都可以执行下标运算 //内置的下标运算符使用的不是无符号数,而标准库类型如vector和string限定使用的下标必须是无符号类型 string *p1 = &amp;sarr[2]; string s3 = p1[2]; string s4 = p1[-2]; cout &lt;&lt; "s3: " &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; "s4: " &lt;&lt; s4 &lt;&lt; endl;&#125; 运行结果 12345s1: yous2: yous2: knows3: mes4: good 指针和迭代器 1234567891011121314151617181920void testCharArray2() &#123; //================指针也是迭代器======================== string sarr[5] = &#123;"nice", "to", "meet", "you", "alice"&#125;; //指针e指向sarr尾元素的下一位置的指针,该位置并不存在,因此不能对该指针进行解引用和递增操作 string *e = &amp;sarr[5]; for (string *b = sarr; b != e; b++) &#123; cout &lt;&lt; *b &lt;&lt; " "; &#125; cout &lt;&lt; endl; //=====================标准库begin和end函数====================== int ia1[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *beg = begin(ia1); // 指向ia1首元素的指针 int *last = end(ia1); // 指向ia1尾元素的下一位置的指针 while (beg != last) &#123; cout &lt;&lt; *beg &lt;&lt; " "; ++beg; &#125; cout &lt;&lt; endl;&#125; 运行结果: 10 1 2 3 4 5 6 7 8 9]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串基础知识总结]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[有几种不同类型的字符串： c风格字符串(包括字符串字面常量和指向以空字符结尾的字符数组的指针)，string类型(类类型) c风格字符串 c风格字符串必须符合某种编码(如ASCII),并且除了字符串的末尾之外,字符串里面不能包含空字符(空字符是字符结束的标志).这些限制使得c风格字符串只能保存文本数据,而不能保存二进制数据(如图片,音频等) c风格字符串不保存自身长度,要获取一个c字符串的长度,需要遍历整个字符串,直到遇到代表字符串结尾的空字符为止,这个操作的时间复杂度为O(n)(n是字符串长度). c字符串容易造成缓冲区溢出 如使用strcat函数将src字符串中的内容拼接到字符串的末尾时, 1char *strcat(char* dest, const char* src) 由于c字符串不记录自身的长度,所以strcat假定用户在执行这个函数时,已经为dest分配了足够多的内存,可以容纳src字符串中的所有内容,但是万一这个假设不成立就会造成缓冲区溢出. c字符串修改字符串长度时需要进行内存重分配;内存重分配涉及复杂的算法,而且可能需要执行系统调用,通常来说比较耗时. 字符串,字符数组相关API c标准库string函数, 共有4个函数 strlen(p), strcmp(p1, p2), strcat(p1, p2), strcpy(p1, p2) 传入此类函数的指针必须指向以空字符结尾的数组不能使用strlen函数求”使用列表初始化的字符数组的长度 strlen计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 strcpy(char* dest, const char*src) 把src所指向的字符串复制到dest，包括结尾处的空字符 如果目标数组dest的内存空间比src的内存空间小，会出现缓冲区溢出 strcmp(const char* str1, const char* str2) 依次比较str1和str2中的一对字符，直到str1或者str2到达字符串结尾或者被比较的一对字符不等． 当两个字符串相等时返回0. http://www.cplusplus.com/reference/cstring/strcmp/ 123456789101112void testCharArray3() &#123; cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // 允许使用以空字符结尾的字符数组类初始化string对象或为string对象赋值 string s("danam"); cout &lt;&lt; "s:" &lt;&lt; s &lt;&lt; " s.size():" &lt;&lt; s.size() &lt;&lt; endl; char c[] = "nice"; cout &lt;&lt; "strlen(c): " &lt;&lt; strlen(c) &lt;&lt; " c:" &lt;&lt; c &lt;&lt; endl; string s1(c); cout &lt;&lt; "s1.size():" &lt;&lt; s1.size() &lt;&lt; " s1:" &lt;&lt; s1 &lt;&lt; endl;&#125; 运行结果 1234strlen("danam"): 5s:danam s.size():5strlen(c): 4 c:nices1.size():4 s1:nice memset和memstcpy fill memset 头文件string.h（c++头文件cstring） memset可以对数组中每个元素赋以相同的值．但是因为memset按字节赋值，即对每个字节赋相同的值，一般只用来填充char型数组（char类型占一个字节），如果填充int数组最好只在要对数组赋值０或-1时使用memset． memset函数的格式为：memset(数组名，值，sizeof(数组名)) 与fill相比，memset执行速度较快． fill 头文件algorithm fill()函数可以将数组或者容器中的某一段区间赋为某个相同的值．和memset不同，这里的赋值可以是数组类型对应范围的任意值． fill函数格式： fill(arr, arr+n, 0) (其中arr为指向数组首元素的指针，arr+n为指向数组尾元素的指针, 0为要赋的值) fill(vec.begin(), vec.end(), 0) (vec.begin()和vec.end()为迭代器表示的范围)]]></content>
  </entry>
  <entry>
    <title><![CDATA[const关键字的妙用]]></title>
    <url>%2F2019%2F09%2F15%2Fconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[const可用于修饰变量，成员函数等待． 用于成员函数的const规则一 const object(data members不得变动) non-const object(data members可变动) const member functions(保证不更改data members) yes yes non-const member functions(不保证data members不变) no yes 规则二当成员函数的const和non-const版本同时存在，const object只会(只能)调用const版本，non-const object只会(只能)调用non-const版本． 关于规则二的例子：class template std::basci_string&lt;…&gt;有如下两个member functions： 12charT operator[](size_t pos) const &#123; /*...*/ &#125; // 需要考虑cowreference operator[](size_t pos) &#123; /*...*/ &#125; // 不需要考虑cow COW：copy on write多个对象共享底层字符串对象；常量对象不会修改其底层对象，因此不需要考虑COW；对于非常量对象，需要考虑COW，当多个共享底层字符串的对象中的某个需要修改底层数据时，需要为该对象复制一份底层对象，让其独享．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内置指针]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%86%85%E7%BD%AE%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针?指针是一种特殊的变量.它的值是一个对象的地址,也称指针指向该对象.对指针进行解引用可以获取该对象.指针本身是一个对象,可以赋值和拷贝. 指针中保存着它指向的对象的地址.直接输出指针的内容即指针指向的对象的地址.对指针进行解引用得到指针指向的对象 二级指针中保存一个指针的地址, 这个被指向的指针中才真正保存着对象的地址.直接输出指针得到指针指向的一级指针的地址.对二级指针进行解引用得到一级指针指向的最终对象的地址(即一级指针的值).对一级指针进行解引用,得到最终对象 关于指针有一些很容易混淆的地方,下面举几个例子辨析一下. 示例1 1234567int a = 10;int *p = &amp;a;int **pp = &amp;p; // pp是指向指针的指针，它指向指针p。解引用后是指针p。cout&lt;&lt;"pp:"&lt;&lt;(pp)&lt;&lt;" &amp;p"&lt;&lt;(&amp;p)&lt;&lt;endl; // pp是指向指针变量p的指针，所以，pp中存放着整形指针变量p的地址cout&lt;&lt;"*pp:"&lt;&lt;(*pp)&lt;&lt;" p"&lt;&lt;(p)&lt;&lt;endl; // pp是指向指针变量p的指针，*pp解引用pp会得到整形指针变量p，而p的值是一个整形变量a的地址cout&lt;&lt;"p:"&lt;&lt;p&lt;&lt;" &amp;a:"&lt;&lt;(&amp;a)&lt;&lt;endl; // p是指向整形变量a的指针，所以，p中存放着整形变量a的地址cout&lt;&lt;"*p:"&lt;&lt;p&lt;&lt;" a:"&lt;&lt;(a)&lt;&lt;endl; // p是指向整形变量a的指针。*p解引用整形指针p会得到一个整形数 运行结果 1234pp:0x7fff5ce9bf48 &amp;p0x7fff5ce9bf48*pp:0x7fff5ce9bf44 p0x7fff5ce9bf44p:0x7fff5ce9bf44 &amp;a:0x7fff5ce9bf44*p:0x7fff5ce9bf44 a:10 示例2 123456789101112131415161718192021int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p, **k; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *p:" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(p++):" &lt;&lt; *(p++) &lt;&lt; " "; cout &lt;&lt; "after p++" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(++p):" &lt;&lt; *(++p) &lt;&lt; " "; cout &lt;&lt; "after ++p" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; 运行结果 1234567891011a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *p:1k:0x7ffcd38cc920 *k:0x7ffcd38cc930 **k:1=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(p++):1 after p++0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(++p):2 after ++p0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2 可知, a是数组的名字,也是指向数组首元素的指针.p=a将指针p指向数组首元素.因此p的值是数组首元素的地址. p是数组首元素的值.\*k表明k是指向指向指针的指针, k指向指针p,因此,k中保存这指针p的地址,*k是指针p的值,也就是指针指向的对象地址,这里就是数组a首元素的地址.**k就是*(p)就是指针p指向的对象的值.]]></content>
      <categories>
        <category>指针</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数指针]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[函数指针指向的是函数而非对象.和其他指针一样,函数指针指向某种特定类型.函数的类型由它的返回类型和形参类型共同决定,与函数名无关. 123456789101112131415161718bool lengthCompare(const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size();&#125;bool (*pf)(const string &amp;a, const string &amp;b); // pf是一个未初始化的函数指针bool (*pf1)(const string &amp;a, const string &amp;b); // pf1是一个未初始化的函数指针int main()&#123; // 以下两种写法都是等价的 pf = lengthCompare; pf1 = &amp;lengthCompare; // 以下是三个等价的调用 bool fa = pf("hello", "goodbye"); bool fb = pf1("hello", "goodbye"); bool fc = lengthCompare("hello", "goodbye"); return 0; &#125; 当把函数名作为一个值使用时,该函数自动转换为指针,所以, pf = lengthCompare和 pf1 = &amp;lengthCompare是等价的. 函数指针作为实参不能定义函数类型的形参,但是形参可以是指向函数的指针 12345// 第三个形参是函数类型,它会自动转换为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// 显式地将形参定义为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 定义函数类型别名和函数指针类型别名decltype返回函数类型,不会将函数类型自动转换为指针类型 12345678// Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2; // 等价的类型// FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; useBigger的另外两种等价的声明(使用了类型别名) 12void useBigger(const string &amp;s1, const string &amp;s2,Func);void useBigger(const string &amp;s1, const string &amp;s2,FuncP2); 返回函数指针12using F = int(int*, int); // F是函数类型,不是指针using PF = int(*)(int*,int); // PF是指针类型 使用类型别名定义返回类型为函数指针的函数 1234567PF f1(int); // PF是指向函数的指针,f1返回指向函数的指针F f1(int); // F是函数类型,f1不能返回一个函数类型F* f1(int); // F*是函数类型int (*f1(int))(int *,int); // 直接声明f1// 尾置返回类型auto f1(int) -&gt; int(*)(int *,int); 首先f1有形参列表,所以,f1是个函数,f1的返回值是一个指针.该指针也有形参列表,所以,该指针指向函数.该函数的形参是int和int,返回int.所以,f1是一个返回一个函数int(\)(int *,int)的函数. 一个复杂点的例子 12345678910111213141516171819202122232425262728293031string::size_type sumLength(const string &amp;a, const string &amp;b) &#123; return a.size() + b.size();&#125;string::size_type largerLength(const string &amp;a, const string &amp;b) &#123; return a.size() &gt; b.size() ? a.size() : b.size();&#125;decltype(sumLength) *getFcn(const string &amp;s) &#123; if (s == "+") &#123; return sumLength; &#125; else &#123; return largerLength; &#125;&#125;int main()&#123; typedef string::size_type (*Func)(const string &amp;, const string &amp;); Func fcn = getFcn("+"); // fcn是一个函数指针 // 一种等价形式// auto fcn = getFcn("+"); string::size_type sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; fcn = getFcn("-"); sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; return 0;&#125; 由于函数的类型由它的返回类型和形参类型决定,而与函数名无关,可知sumLength和largerLength属于相同的类型.所以,我们可以向getFcn传入参数,获取指向同一种函数类型的不同的函数指针.]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 易混淆概念之常量指针]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指向常量的指针常量是这样一种变量:它的值不能被改变,因此,常量必须初始化. 指向常量的指针,可以指向常量或者非常量.但是要想用指针来存放常量对象的地址,只能用指向常量的指针.指向常量的指针仅仅要求不能通过该指针改变对象的值,而没有规定该对象的值不能通过其他方式改变.可以这样想: 指向常量的指针, 自以为是地以为自己指向了常量,所以自觉地不去改变该对象的值.同样,可以认为指向非常量的指针,会认为自己指向的是非常量,因此,可能会改变自己指向的变量,因此不能用指向非常量的指针保存常量对象的地址.因为,指向非常量的指针可能会试图改变其指向的常量对象的值. 非常量可以转化为常量.反之则不行. 123456const double pi = 3.14;const double *pip = &amp;pi; // 正确:指向常量的指针const double pi1 = 3.1415;pip = &amp;pi; // 使指向常量的指针pip指向另一个常量double pi2 = 3.1415926;pip = &amp;pi2; // 指向常量的指针pip指向一个非常量 常量指针常量指针是指指针本身是常量,即指针一旦指向某个对象就不能再改变(指针中保存的那个地址就不再改变了).因此同常量一样,常量指针必须初始化. 指针本身是常量只规定了指针不能指向其他对象,而并没有规定不能通过指针修改其所指向对象的值,能否只有做完全取决于所指对象的类型.常量指针既可以指向常量也可以指向非常量,具体指向的是常量还是非常量,取决于定义该指针时所指向对象的基本数据类型. 12345int errNumb = 0;int *const curErr = &amp;errNumb; // 指向非常量的常量指针 curErr常量指针,始终指向errNumb*curErr = 1; // 通过指向非常量的常量指针修改其所指向对象的值const double pi = 3.14;const double *const pip = &amp;pi; // 指向常量的常量指针pip 常量指针this类的成员函数调用时,用请求该函数的对象地址初始化this.在整个调用过程中,this所指向的都是发起该调用的对象.默认情况下,this的类型是指向非常量版本的常量指针.如类类型的名为sales_data, 则this指针的类型是sales_data *const. 又如果想要用指针来保存常量对象的地址,只能使用指向常量的指针, 所以,我们不能把类型为sales_data const的this指向一个常量对象.也因此,不能在一个常量对象上调用普通的成员函数.如果想要常量对象也能调用该成员函数,那么必须要把this指针的类型设置成指向常量的常量指针,即*const sales_data const*声明成员函数时,紧随参数列表的const的作用就是将this指针的类型声明成指向常量的常量指针.像这样使用construction的成员函数被称作常量成员函数,常量成员函数内部不能改变this指针所指向的对象的内容(即调用此成员函数的对象的内容). 1234class sales_data&#123; void f(); // 常量对象不能调用此函数 void f() const; // 此函数是常量成员函数,常量对象也可以调用,this指针指向的是常量对象(也可以是非常量对象)&#125;]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[void*指针]]></title>
    <url>%2F2019%2F09%2F15%2Fvoid*%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[void*是一种特殊的指针类型,可以用于存放任意类型的对象地址.但是我们不知道该指针着存放的地址指向的对象的类型. 1234int d = 102;void *p = &amp;d;int *pa = static_cast&lt;int *&gt;(p);cout &lt;&lt; *pa &lt;&lt; endl; // 102 将指针p强制为int*类型,强制转换过程中应该确保指针的值即指针指向的对象地址不变; 因此我们进行强制转换时,必须确保转换的目标类型就是指针所指的类型,否则,将产生未定义的结果. 那么什么时候使用void*指针呢?未完待续]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>void*指针</tag>
        <tag>static_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和引用]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是引用？ 引用和指针的区别与联系指针和引用的异同点 指针 引用 指针本身是对象 引用本身不是对象,只是对象的别名 允许对指针本身进行赋值和拷贝,在指针的生命期内可以指向不同的对象(只要指针不是常量指针) 引用定义时就和一个对象绑定,且始终和这个对象绑定,无法令引用重新绑定到另一个对象 指针无须在定义时赋初值,在块作用域内的指针如果没有被初始化,将拥有一个不确定的值. 引用必须初始化. 可以定义指向指针的指针 无法定义引用的引用 引用的常见用途引用通常不用于声明变量，而用于参数类型和返回类型的描述． 12345678910void func1(Cls* pobj)&#123; pobj-&gt;xxx();&#125;void func2(Cls obj)&#123;obj.xxx();&#125;void func3(Cls&amp; obj)&#123;obj.xxx();&#125;Cls obj;func1(&amp;obj); // 接口不同// 调用端口相同func2(obj);func3(obj); 以下两个函数被视为”same signature”(所以二者不能同时存在)： 12double imag(const double&amp; im)&#123;...&#125;double imag(const double im)&#123;...&#125; // Ambiguity Q：const是不是函数签名的一部分？A：是的，两个函数，一个函数有const，另一个没有，则可以看做函数重载．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能指针]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针有三类: shared_ptr, unique_ptr, weak_ptr.其中shared_ptr可以和其他shared_ptr共享内存,指向同一块内存区域,引用计数用于记录指向该内存的shared_ptr个数. unique_ptr只能独占内存.任意时刻,都只有一个unique_ptr指向一个给定对象.当unique_ptr被销毁时, 它所指向的对象也会被销毁. weak_ptr是一种弱引用,指向shared_ptr所管理的对象. shared_ptr 初始化shared_ptr有三种初始化方式: 使用make_shared&lt;T&gt;(obj)初始化 使用同类型内置指针对shared_ptr进行初始化 使用另一个智能指针进行初始化 reset将一个新的内置指针赋予shared_ptr use_count引用计数 默认情况下,一个用来初始化智能指针的内置指针必须指向动态内存,因为智能指针默认使用delete释放它所关联的对象.我们也可以将智能指针绑定一个指向其他类型对象的指针上,但是此时必须提供自己的操作来代替delete.这个自己的操作就是删除器函数,即,我们必须定义一个自己的函数作为新的删除器函数. 1234567891011121314void f1()&#123; // 使用对象初始化智能指针 shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(12); cout &lt;&lt; *p &lt;&lt; " " &lt;&lt; p.use_count() &lt;&lt; endl; // 使用智能指针初始化智能指针 shared_ptr&lt;int&gt; p2(p); cout &lt;&lt; *p2 &lt;&lt; " " &lt;&lt; p2.use_count() &lt;&lt; endl; // 使用内置指针初始化智能指针 int *p3 = new int(193); shared_ptr&lt;int&gt; p4(p3); cout &lt;&lt; *p4 &lt;&lt; " " &lt;&lt; p4.use_count() &lt;&lt; endl;&#125; 运行结果 12312 112 2193 1 reset和use_count的使用 调用p.reset(q)时, 若是p是唯一一个指向其对象的shared_ptr,则reset会释放此对象.若传递了可选的参数内置指针q, 会令p指向q所指的内存空间, 否则将p置空.reset会更新p的引用计数. 123456789101112131415161718void f2()&#123; shared_ptr&lt;int&gt; p4(new int(28)); cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p5(new int(109)); cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl; // 调用智能指针类的赋值运算符函数 p4 = p5; cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; // p5不是唯一一个指向其所指对象的shared_ptr,因此,重新制作一份该对象的副本并修改该对象的值 if (!p5.unique()) &#123; p5.reset(new int(*p5)); *p5 += 100; &#125; cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl;&#125; 运行结果 1234*p4: 28 p4.use_count(): 1*p5:109 p5.use_count: 1*p4: 109 p4.use_count(): 2*p5:209 p5.use_count: 1 unique_ptrweak_ptr]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>shared_ptr</tag>
        <tag>unique_ptr</tag>
        <tag>weak_ptr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从数组中找重复数字系列]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[287. Find the Duplicate Number 方法一：排序，将整个数组进行排序．排序的时间复杂度和空间复杂度取决于使用的排序算法．这里要求额外空间排序度为O(1)，那么只能用堆排序． 方法二：使用set 方法三 前面方法一都会修改数组，不满足要求．方法二的额外空间复杂度是O(n)，同样不满足要求． https://leetcode.com/problems/find-the-duplicate-number/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221.Maximal Square]]></title>
    <url>%2F2019%2F09%2F15%2F221.Maximal%20Square%2F</url>
    <content type="text"><![CDATA[Maximal Square Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 解法1:单调栈解法详见程序员代码面试指南：求最大子矩阵的大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())&#123; return 0; &#125; int maxArea = 0; int row = matrix.size(); // 1 int col = matrix[0].size(); // 1 vector&lt;int&gt; height(col, 0); for(int i=0;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; height[j] = (matrix[i][j] == '0') ? 0 : height[j] + 1; &#125; auto res = getLessThan(height); for(int j=0;j&lt;col;++j)&#123; int w = res[j][1] - res[j][0] - 1; int l = min(w, height[j]); maxArea = max(maxArea, l * l); &#125; &#125; return maxArea; &#125; vector&lt;vector&lt;int&gt;&gt; getLessThan(vector&lt;int&gt;&amp; nums)&#123; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for(int i=0;i&lt;nums.size();++i)&#123; int r = i; while(!s1.empty() &amp;&amp; nums[s1.top()] &gt;= nums[i])&#123; int index = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); res[index][0] = l; res[index][1] = r; &#125; s1.push(i); &#125; int r = nums.size(); while(!s1.empty())&#123; int index = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); res[index][0] = l; res[index][1] = r; &#125; return res; &#125;&#125;; 解法2:动态规划]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%85%B3%E4%BA%8E%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于快速排序过程中一个的问题：为什么在qsort中递归时，需要将递归范围改为[lo, pos-1]而不是[lo, pos]? 以下看一个具体例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; int i = lo - 1; int key = arr[hi]; for (int j = lo; j &lt; hi; ++j) &#123; if (arr[j] &lt;= key) &#123; ++i; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; arr[hi] = arr[i + 1]; arr[i + 1] = key; return i + 1;&#125;void qsort(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int pos = partition(arr, lo, hi); // 这里返回了pos=5,所以出现了递归调用，而且这个递归调用和之前的调用一模一样 qsort(arr, lo, pos - 1); qsort(arr, pos + 1, hi);&#125;int main() &#123; vector&lt;int&gt; arr&#123;12, 34, 11, 46, 12, 89&#125;; qsort(arr, 0, arr.size() - 1); for (auto c:arr) &#123; cout &lt;&lt; c &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 在归并排序过程中，递归的两个子范围为[lo, mid]和[mid+1, hi].那是因为[lo, mid]区间必然是[lo, hi]区间的子区间，而不会和区间[lo, hi]重叠．而这里的pos是通过partition函数返回的，表示在数组中小于等于key的元素范围，pos有可能等于hi,这是区间[lo, pos]和区间[lo, hi]重叠．]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于快速排序过程中一个的问题：为什么在qsort中递归时，需要将递归范围改为[lo, pos-1]而不是[lo, pos]? 以下看一个具体例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; int i = lo - 1; int key = arr[hi]; for (int j = lo; j &lt; hi; ++j) &#123; if (arr[j] &lt;= key) &#123; ++i; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; arr[hi] = arr[i + 1]; arr[i + 1] = key; return i + 1;&#125;void qsort(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int pos = partition(arr, lo, hi); // 这里返回了pos=5,所以出现了递归调用，而且这个递归调用和之前的调用一模一样 qsort(arr, lo, pos - 1); qsort(arr, pos + 1, hi);&#125;int main() &#123; vector&lt;int&gt; arr&#123;12, 34, 11, 46, 12, 89&#125;; qsort(arr, 0, arr.size() - 1); for (auto c:arr) &#123; cout &lt;&lt; c &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 在归并排序过程中，递归的两个子范围为[lo, mid]和[mid+1, hi].那是因为[lo, mid]区间必然是[lo, hi]区间的子区间，而不会和区间[lo, hi]重叠．而这里的pos是通过partition函数返回的，表示在数组中小于等于key的元素范围，pos有可能等于hi,这是区间[lo, pos]和区间[lo, hi]重叠．]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序的优化和鸡尾酒排序]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序的优化有设置哨兵来表示当前整个数组已经有序，以及设置有序区间，下一次只对有序区间进行排序（尚未完全理解）． 详情可见 鸡尾酒排序鸡尾酒排序算法适用于大部分元素已经有序的情况．它能够在特定条件下，减少排序的回合数；但是缺点是代码量几乎扩大了一倍． 鸡尾酒排序 未进行优化的鸡尾酒排序 12345678910111213141516171819202122232425262728293031323334353637383940414243void clockTailSort(vector&lt;int&gt; &amp;nums) &#123; // 未进行优化的鸡尾酒排序 int tmp = 0; for (int i = 0; i &lt; nums.size() / 2 - 1; ++i) &#123; // 有序标记，每一轮的初始值是true bool isSorted = true; // 奇数轮:从做向右比较和交换 // 奇数轮：区间内最大的数会被冒泡到最右 for (int j = i; j &lt; nums.size() - i - 1; ++j) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; // 有元素交换，所以，不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; isSorted = true; // 8 1 2 3 4 // 偶数轮，从右向左比较和交换 // 偶数轮，最小的数会被冒泡到最左边 for (int j = nums.size() - i - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; tmp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125;&#125; 进行优化的鸡尾酒排序优化方法：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>冒泡排序的优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F09%2F15%2F%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[以下对进程相关的几个概念进行解释． 什么是孤儿进程，僵尸进程 子进程是在父进程调用fork函数后生成的．子进程将其终止状态返回给父进程．但是如果父进程在子进程之前终止，那么会发生什么呢？对于父进程已经终止的所有进程，他们的父进程都会变成init进程，称这些进程被init进程收养． 操作过程大致为：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，将该进程的父进程ID改为1(init进程的ID)． 子进程终止时，它与父进程之间的关联还会保持，直到父进程也正常终止或父进程调用wait才告结束．尽管它已经不再运行了，但是它仍然存在于系统中．内核为每个终止子进程保存了一些信息，当终止进程的父进程调用wait或waitpid时，可以得到这些信息．这些信息包括进程ID，该进程的终止状态以及进程使用的CPU时间总量． 这样一个已经终止，但其父进程尚未对其进程善后处理(获取终止子进程的有关信息，释放它仍占用的资源)的进程被称为僵尸进程． 如果子进程先于父进程终止，那么子进程会成为一个僵尸进程． 进程同步与进程互斥的区别与联系https://zhuanlan.zhihu.com/p/69581607 互斥量，信号量，锁等概念]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[什么是单调栈？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;/** * 对于不含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 */vector&lt;vector&lt;int&gt;&gt; getNearLessNoRepeat(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; while (!s1.empty() &amp;&amp; arr[s1.top()] &gt; arr[i]) &#123; int popIndex = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top(); res[popIndex][0] = left; res[popIndex][1] = i; &#125; s1.push(i); &#125; while (!s1.empty()) &#123; int popIndex = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top(); res[popIndex][0] = left; res[popIndex][1] = -1; &#125; return res;&#125;/** * 对于含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 * 方法１：把所有相等元素放到一个vector中 */vector&lt;vector&lt;int&gt;&gt; getNearLess(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;vector&lt;int&gt;&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; while (!s1.empty() &amp;&amp; arr[s1.top()[0]] &gt; arr[i]) &#123; vector&lt;int&gt; popIs = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top()[s1.top().size() - 1]; for (int popi : popIs) &#123; res[popi][0] = left; res[popi][1] = i; &#125; &#125; if (!s1.empty() &amp;&amp; arr[s1.top()[s1.top().size() - 1]] == arr[i]) &#123; s1.top().push_back(i); &#125; else &#123; vector&lt;int&gt; tmp&#123;i&#125;; s1.push(tmp); &#125; &#125; while (!s1.empty()) &#123; vector&lt;int&gt; popIs = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top()[s1.top().size() - 1]; for (int popi: popIs) &#123; res[popi][0] = left; res[popi][1] = -1; &#125; &#125; return res;&#125;/** * 对于含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 * 方法2：对于每个元素从栈中退出时才统计与其相等的元素 */vector&lt;vector&lt;int&gt;&gt; getNearLess2(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; int right = i; while (!s1.empty() &amp;&amp; arr[s1.top()] &gt; arr[i]) &#123; int idx = s1.top(); vector&lt;int&gt; tmp&#123;idx&#125;; while (!s1.empty() &amp;&amp; arr[s1.top()] == arr[idx]) &#123; tmp.push_back(s1.top()); s1.pop(); &#125; int left = s1.empty() ? -1 : s1.top(); for (auto index : tmp) &#123; res[index][0] = left; res[index][1] = right; &#125; &#125; s1.push(i); &#125; int right = -1; while (!s1.empty()) &#123; int idx = s1.top(); vector&lt;int&gt; tmp&#123;idx&#125;; while (!s1.empty() &amp;&amp; arr[idx] == arr[s1.top()]) &#123; tmp.push_back(s1.top()); s1.pop(); &#125; int left = s1.empty() ? -1 : s1.top(); for (auto index:tmp) &#123; res[index][0] = left; res[index][1] = right; &#125; &#125; return res;&#125;int main() &#123; vector&lt;int&gt; arr&#123;3, 1, 3, 4, 3, 5, 3, 2, 2&#125;; vector&lt;vector&lt;int&gt;&gt; res1 = getNearLess(arr); vector&lt;vector&lt;int&gt;&gt; res2 = getNearLess2(arr); for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " " &lt;&lt; res1[i][0] &lt;&lt; " " &lt;&lt; res1[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " " &lt;&lt; res2[i][0] &lt;&lt; " " &lt;&lt; res2[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; 单调栈的应用 Maximal Square]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix 高级环境编程系列2]]></title>
    <url>%2F2019%2F09%2F15%2Funix-%E9%AB%98%E7%BA%A7%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[此文档主要整理并记录liunx中常用的api． IOfgetcfgetc从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节。 fputc功能：把一个字符写到一个输出文件流中．它返回写入的值，如果失败，则返回EOF．putc函数的作用相当于fputc，但它可能被实现为一个宏．putchar相当于putc(c, stdout)，但它把单个字符写到标准输出．注意：putchar和getchar都是把字符当做int类型而不是char类型来使用的．这就允许文件尾标识取值-1，这是一个超出字符数字编码范围的值． fopenhttps://blog.csdn.net/hairetz/article/details/4150193 read1ssize_t read(int fd, void* buf, size_t nbytes); 成功时返回接收的字节数(但遇到文件结尾则返回0)，失败时返回-1.fd: 显示数据接收对象的文件描述符．buf: 要保存接收数据的缓冲地址值．nbytes: 要接收数据的最大字节数． write1ssize_t write(int fd, const void* buf, size_t nbytes); 成功时返回写入的字节数，失败时返回-1.fd: 显示数据传输对象的文件描述符．buf: 要保存传输数据的缓冲地址值．nbytes: 要传输数据的最大字节数． freadsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 功能：从给定流 stream 读取数据到 ptr 所指向的数组中 ptr – 这是指向带有最小尺寸 size\nmemb* 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 fgets函数原型为：char *fgets(char *str, int n, FILE *stream) 功能：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。fgets会把读到字符写到s指向的字符串里，直到出现下面某种情况： 遇到换行符 已经传输了n-1个字节 到达文件尾 它会把遇到的换行符也保存到s中．最后在s末尾加上一个表示结尾的空字符\0．一次调用最多只能传输n-1个字符，因为它必须把空字符加到字符串表示结尾． gets函数类似于fgets，但是它从标准输入流中取数据并丢弃遇到的换行符．它在接收字符串的尾部加上一个空字节(一个字符占一个字节)． puts12# include &lt;stdio.h&gt;int puts(const char *s); 功能：将字符串输出到屏幕。输出时只有遇到 ‘\0’ 也就是字符串结束标志符才会停止。 目录opendir123#include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;DIR * opendir(const char * name); 功能：opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流．接下来对目录的读取和搜索都要使用此返回值． 返回值：成功则返回DIR*型态的目录流，打开失败则返回nullptr. 错误代码： EACCESS 权限不足 EMFILE 已达到进程可同时打开的文件数上限 ENFILE 已达到系统可同时打开的文件数上限 ENOTDIR 参数name 非真正的目录 ENOENT 参数name 指定的目录不存在, 或是参数name 为一空字符串 ENOMEM 核心内存不足 进程fork12 vfork函数原型 12 功能：vfork函数用于创建一个新进程．新进程的目的是exec一个新程序． vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中．因为子进程会立即调用exec(exit)，于是也就不会引用该地址空间．但是在子进程调用exec或exit之前，它在父进程的空间中运行． vfork和fork之间的另一个区别是：vfork保证子进程先运行．在它调用exec或exit之后父进程才可能被调度运行．当子进程调用这两个函数中的任意一个时，父进程会恢复运行．如果在调用这两个函数之前子进程依赖于父进程的进一步动作，会导致死锁． wait在父进程中通过调用wait函数来让父进程等待子进程的结束．wait系统调用将阻塞父进程直到它的子进程结束．这个调用返回子进程的PID，它通常是已经结束运行的子进程的PID．状态信息允许父进程了解子进程的退出状态，即子进程的main函数返回的值或子进程中exit函数的退出码．如果stat_loc不是空指针，那么状态信息就会被写入它所指向的位置．如果调用wait的进程有多个子进程，那么在其某一子进程终止时，wait就立即返回． 12#include&lt;sys/wait.h&gt;pid_t wait(int *stat_loc) 头文件sys/wait.h中定义的宏来解释状态信息． 12WIFEXITED(stat_val); // 如果子进程正常结束，它就取一个非零值WEXITSTATUS(stat_val); // 如果WIFEXITED非零，它返回子进程的退出码 waitpid函数原型 123#include&lt;sys/type.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *stat_loc, int options) 功能：waitpid用来等待某个特定进程的结束． pid参数用于指定需要等待的子进程的PID．如果它的值为-1，waitpid将返回任一子进程的信息． 如果stat_loc不是空指针，waitpid将状态信息写入到stat_loc指定的位置． option参数可用来改变waitpid的行为，其中一个最有用的选项是WNOHANG，它的作用是防止waitpid调用将调用者的执行挂起．可以使用这个选项来查找是否有子进程已经结束，如果没有，程序将继续执行．其他的选项和wait调用的选项相同． 返回值：如果子进程没有结束或意外终止，返回0；否则返回child_pid．如果waitpid失败，它将返回-1并设置errno．失败的情况包括：没有子进程(errno设置为ECHILD)，调用被某个信号中断(EINTR)，或选项参数无效(EINVAL)． exec函数族1int execl(const char*path, const char *arg,...) exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行参数path：可执行文件的路径名字arg：可执行程序所带的参数，第一个参数为可执行文件的名字，没有带路径且arg必须以空指针结束 https://blog.csdn.net/u014530704/article/details/73848573 线程pthread_create函数原型 1int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void*), void* arg); 功能：创建一个新线程 第一个参数指向一个pthread_t 类型的指针，线程被创建时，这个指针指向的变量中将被写入一个标识符，我们用该标识符来引用新线程． 第二个参数用于设置线程的属性；一般不需要特殊的属性，因此令该参数为NULL 第三个参数一个函数指针，告诉线程将要启动执行的函数 第四个参数是传递给该函数的参数 成功时，返回0；失败时，返回错误代码 pthread_join函数原型 1int pthread_join(); 功能：pthread_join等价于进程中用来收集子进程信息的wait函数．调用进程将一直阻塞，直到指定的线程调用thread_exit或者从启动例程(即被调用的函数)中返回，或被取消． pthread_exit函数原型 1int pthread_exit(void * rval_ptr); 用于线程的信号量 有两组接口函数用于信号量．一组取自POSIX的实时扩展，用于线程．另一组被成为系统V信号量，常用于进程的同步．信号量是一个特殊类型的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作． 在多线程程序中，如果一个程序中有两个(或多个)线程试图改变一个信号量的值，系统将保证所有的操作都依次进行．信号量有二进制信号量和计数信号量．信号量一般用来保护一段代码，使其每次只能被一个执行线程运行，使用二进制信号量来完成这个工作． 允许有限数目的线程执行一段指定的代码，这时需要计数信号量． sem_init函数原型 1int sem_init(sem_t *sem, int pshared, unsigned int value); 功能：创建信号量；信号量由一个sem_t类型指针指定，设置该信号量对象的共享选项，并给它一个初始的整数值． 第一个参数为指向sem_t类型的信号量对象的指针． pshared表示该信号量对象的共享选项，若为0表示该信号量是当前进程的局部信号量，否则，这个信号量就可以在多个进程之间共享． sem_wait函数原型 1int sem_wait(sem_t* sem); 功能：以原子操作的方式给信号量的值减1.但是它会等待直到信号量有个非零值才会开始减法操作． sem_post函数原型 1int sem_post(sem_t* sem); 功能：以原子操作的方式给信号量的值加1. 互斥量另一种用在多线程程序中的同步访问方法是使用互斥量．它允许程序锁住某个对象，使得每次只能有一个线程访问它．为了控制对关键代码的访问，必须在进入这段代码之前锁住一个互斥量，然后在完成操作之后解锁它． 以下这些用于互斥量的基本函数成功时返回0，失败时返回错误代码，但是这些函数并不设置errno，必须对函数的返回代码进行检查． pthread_mutex_init函数原型 1int pthread_mutex_init(pthread_mutext_t *mutex, const pthread_mutexattr_t *mutexattr); pthread_mutex_lock函数原型 1int pthread_mutex_lock(pthread_mutex_t *mutex) pthread_mutex_unlock函数原型 1int pthread_mutex_unlock(pthread_mutex_t *mutex); pthread_mutex_destroy函数原型 1int pthread_mutex_destroy(pthread_mutex_t *mutex) 用于进程的信号量]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix 高级环境编程系列1]]></title>
    <url>%2F2019%2F09%2F15%2Funix-%E9%AB%98%E7%BA%A7%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[此文档主要记录学习过程中出现的一些问题． 环境配置学习unix高级环境编程这本书时，发现#include”apue.h”报错，在网上查找后发现这是作者自己写的一个包，需要自己手动添加到/usr/include目录下，所以从网上找了一个教程配置了下，成功配好了环境．具体过程不赘述了，直接参考的参考文献中的第二条链接． 运行程序过程中出现的错误报错信息： 12345gcc main.cpp -o th2 -lpthread/tmp/ccdz0db3.o：在函数‘__static_initialization_and_destruction_0(int, int)’中：main.cpp:(.text+0x186)：对‘std::ios_base::Init::Init()’未定义的引用main.cpp:(.text+0x19b)：对‘std::ios_base::Init::~Init()’未定义的引用collect2: error: ld returned 1 exit status 报错原因：使用了c编译器来编译c++文件解法办法：使用命令[g++ main.cpp -o th2 -lpthread]来编译https://blog.csdn.net/u010758410/article/details/78704003 报错信息 1234g++ thread_exit_test.cpp -o exit -lpthreadthread_exit_test.cpp: In function ‘int main()’:thread_exit_test.cpp:47:43: error: lvalue required as unary ‘&amp;’ operand err = pthread_join(tid1, &amp;((void *) fp)); 报错原因：C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，而C++不允许的。解法方法：https://blog.csdn.net/alpelious/article/details/53486547 参考文献[1] http://www.apuebook.com/[2] https://www.jianshu.com/p/c51a4127e9e6]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调序列]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%8D%95%E8%B0%83%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j]. Return true if and only if the given array A is monotonic. Example 1: 12Input: [1,2,2,3]Output: true Example 2: 12Input: [6,5,4,4]Output: true Example 3: 12Input: [1,3,2]Output: false Example 4: 12Input: [1,2,4,5]Output: true Example 5: 12Input: [1,1,1]Output: true Note: 1 &lt;= A.length &lt;= 50000 -100000 &lt;= A[i] &lt;= 100000 方法一：两次遍历第一遍检查序列是否是递增序列；第二遍检查序列是否是递减序列． 方法二：一次遍历遍历一次，依次查看相邻两对数的变化趋势是否相等，若相反，则说明不是单调序列． 12345678910111213141516171819202122232425class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; A) &#123; int store = 0; for(int i=0;i&lt;A.size()-1;++i)&#123; int c = compare(A[i], A[i+1]); if(c!=0)&#123; // A[i] != A[i+1] // A[i] != A[i+1] and A[i-1] != A[i] // then A[i] &gt; A[i+1] and A[i-1] &gt; A[i] // or A[i] &lt; A[i+1] and A[i-1] &lt; A[i] if(c!= store &amp;&amp; store != 0)&#123; return false; &#125; store = c; &#125; &#125; return true; &#125; int compare(int a, int b)&#123; if(a == b)&#123; return 0; &#125; return a &lt; b ? -1 : 1; &#125;&#125;; 方法三：一次遍历(变种)如果一个序列是单调递增的，那么不会出现相邻两个数递减的趋势，同理，若一个序列是单调递减的，那么不会出现递增的趋势．如果在一个序列中同时出现了递增和递减的趋势，说明该序列不是单调序列． 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找各种不同的应用场景]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[二分查找是一种十分重要的查找算法．通常在有序数组中查找某个指定的数． Find peak Element: https://leetcode.com/problems/find-peak-element 如何处理一个数组中所有元素都相等的情况． https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/&gt; 相似题：https://leetcode.com/problems/first-bad-version/ 12345678910111213int findLastPos(vector&lt;int&gt;&amp; nums, int target)&#123; int i = 0, j = nums.size()-1; int mid = -1; while(i &lt;= j)&#123; mid = (i + j) / 2; if(nums[mid] &gt; target)&#123; j = mid - 1; &#125;else&#123; i = mid; &#125; &#125; return mid;&#125; 从有序数组中大于等于某个数的元素第一次出现的位置123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出大于某个值的元素第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例: 1234[1, 3, 3, 3, 3] // 1, 元素3(最早出现的元素3)[1, 2, 4, 5, 6] // 2, 元素4[1, 2, 2, 2, 2] // -1, 所有元素都比3小[4, 5, 6, 9, 12] // 0, 所有元素都比3大 从有重复元素的有序数组中找出某个元素第一次出现的位置123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出某个值第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例 123[1, 3, 3, 3, 3] // 1, 第一个元素3[-1, 1, 2, 3, 5] //3, 元素3[1, 2, 4, 5, 6] // -1, 不存在元素3 在有序旋转数组中搜索某个给定的数题目链接]]></content>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程和套接字]]></title>
    <url>%2F2019%2F09%2F04%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%2F</url>
    <content type="text"><![CDATA[首先实现一个简单的服务器端和客户端通信的小例子． 服务器端代码 12 服务器端调用步骤： 调用socket函数创建套接字 调用bind函数分配IP地址和端口号 调用listen函数将套接字转为可接收连接状态 调用accept函数受理连接请求．如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止． 使用write函数用于向客户端传输数据． 相关API创建socket函数原型如下： 1int socket(int domain, int type, int protocol) socket函数成功时返回一个文件描述符(见后续其他相关知识)，失败则返回-1. domain: 套接字中使用的协议族信息 PF_INET表示IPV4互联网协议族 type: 套接字数据传输类型信息 SOCK_STREAM表示面向连接的套接字 SOCK_DGRAM表示面向消息的套接字． 创建TCP套接字和UDP套接字： 12tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); protocol: 计算机间通信中使用的协议信息 描述socket 接下来代码描述socket文件，包括socket文件的大小，接受的内容等 1234memset(&amp;serv_addr, ０, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);serv_addr.sin_port = htons(atoi(argv[1])); sin_family: 地址族 每种协议族适用的地址族不同．IPV4使用4字节地址族．IPV6使用16字节地址族． AF_INET IPV4网络协议中使用的地址族 AF_INET6 IPV6网络协议中使用的地址族 sin_port: 该成员保存16位端口号，它以网络字节序保存 sin_addr: 该成员保存32位IP地址信息，且也以网络字节序保存． 地址绑定给套接字分配地址信息（IP地址和端口号） 1int bind(int sockfd, struct sockaddr* myaddr, socklen_t addrlen); 成功时返回0,失败时返回-1.sockfd: 要分配地址(IP地址和端口号)的套接字文件描述符myaddr: 存有地址信息的结构体变量地址值addrlen: 第二个结构体变量的长度 监听 绑定了地址信息后，只需要最后一步接收来自客户的连接请求了．这就是让套接字变成监听状态，之后，只要客户端向服务器发送请求，服务器就可以接收到了．通过listen函数进入等待连接请求状态．只有调用了listen函数，客户端才能进入可发出连接请求的状态．换言之，这时客户端才能调用connect函数(若提前调用将发生错误)． 1int listen(int sock, int backlog); 成功时返回0,失败时返回-1.sock：希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字(监听套接字)backlog: 连接请求等待队列的长度, 若为5，则队列长度为5,表示最多使5个连接请求进入队列． 等待连接请求状态： 服务端处于等待连接请求状态是指，客户端请求连接时，受理连接前一直使请求处于等待状态． 连接请求队列：允许的连接请求的客户端个数 接受连接函数原型如下： 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); sock: 服务器套接字的文件描述符 addr: 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息． addrlen: 第二个参数addr结构体的长度，但是存有长度的变量地址．函数调用完成后，该变量即被填入客户端地址长度． 返回值：accept函数成功时返回文件描述符，失败时返回-1 accept函数受理连接请求队列中待处理的客户端连接请求．函数调用成功时，accept函数内部将产生用于数据IO的套接字，并返回其文件描述符．套接字是自动创建的，并自动与发起连接请求的客户端建立连接 一个服务器端socket可以接收很多客户端的连接请求．当客户端发起连接请求时，服务器端需要调用accept函数受理客户端的请求．同时来自不同客户端的连接也会当成不同的socket文件，返回不同的文件描述符． connect1int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); 功能： 客户端调用connect函数后，发生以下情况之一才会返回(完成函数调用) 服务器接收连接请求 注意：接收连接请求并不意味着服务器调用accept函数，而是指服务器把连接请求信息记录到等待队列． 所以，connect函数返回后并不立即进行数据交换 发生断网等异常情况而中断连接请求 sock: 客户端套接字文件描述符 servaddr: 保存目标服务端地址信息的变量地址值 addrlen: 以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度 read和write1ssize_t read(int fd, void* buf, size_t nbytes); 成功时返回接收的字节数(但遇到文件结尾则返回0)，失败时返回-1.fd: 显示数据接收对象的文件描述符．buf: 要保存接收数据的缓冲地址值．nbytes: 要接收数据的最大字节数． 1ssize_t write(int fd, const void* buf, size_t nbytes); 成功时返回写入的字节数，失败时返回-1.fd: 显示数据传输对象的文件描述符．buf: 要保存传输数据的缓冲地址值．nbytes: 要传输数据的最大字节数． freadsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 功能：从给定流 stream 读取数据到 ptr 所指向的数组中 ptr – 这是指向带有最小尺寸 size\nmemb* 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 fgets函数原型为：char *fgets(char *str, int n, FILE *stream) 功能：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。fgets会把读到字符写到s指向的字符串里，直到出现下面某种情况： 遇到换行符 已经传输了n-1个字节 到达文件尾 它会把遇到的换行符也保存到s中．最后在s末尾加上一个表示结尾的空字符\0．一次调用最多只能传输n-1个字符，因为它必须把空字符加到字符串表示结尾． gets函数类似于fgets，但是它从标准输入流中取数据并丢弃遇到的换行符．它在接收字符串的尾部加上一个空字节(一个字符占一个字节)． fgetcfgetc从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节。 fputc功能：把一个字符写到一个输出文件流中．它返回写入的值，如果失败，则返回EOF．putc函数的作用相当于fputc，但它可能被实现为一个宏．putchar相当于putc(c, stdout)，但它把单个字符写到标准输出．注意：putchar和getchar都是把字符当做int类型而不是char类型来使用的．这就允许文件尾标识取值-1，这是一个超出字符数字编码范围的值． fopenhttps://blog.csdn.net/hairetz/article/details/4150193 sigaction1sigaction(int signo, const sigaction* act, struct sigaction *oldact); 功能： signo：与signal函数相同，传递信号信息 act：对应于第一个参数的信号处理函数(信号处理器)信息 oldact：通过此参数获取之前注册的信号处理函数指针，若不需要则传递0 返回值：成功时返回0,失败时返回-1 其他相关知识 文件描述符 对linux来说，一切皆文件．套接字和本地的文件都是文件． 文件描述符是系统分配给文件或套接字的整数．是为了方便称呼操作系统分配的文件或套接字． 结构体sockaddr_in 参考文献[1] TCP/IP网络编程：https://blog.csdn.net/u011675745/article/details/78555250]]></content>
      <categories>
        <category>TCP/IP网络编程</category>
      </categories>
      <tags>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parentheses系列]]></title>
    <url>%2F2019%2F09%2F02%2FParentheses%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[括号系列的几道题，涉及到括号匹配，生成括号等等． Valid Parentheses题目链接 Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;&#123;[]&#125;&quot;Output: true 使用一个栈来完成括号的匹配．当遇到一个左括号，入栈；当遇到一个右括号时，查看栈中是否存在对应的左括号．正常的状态是：左右括号的类型和数量都匹配，那么，当整个字符串遍历完成时，栈为空．因此，首先当字符串为空，该字符串必然是valid．若字符串中字符总数为奇数，该字符串必然为invalid．在遍历过程中，如果发现某个右括号不匹配，直接结束遍历过程，并将标记变量改为invalid．遍历结束之后，如果标记变量为valid，此时还需要检查栈是否为空．代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isValid(string s) &#123; if(s.empty())&#123; return true; &#125;else if(s.size() &amp; 1)&#123; return false; &#125; // map的初始化 map&lt;char, char&gt; mp = &#123; &#123;'&#125;','&#123;'&#125;,&#123;')','('&#125;,&#123;']','['&#125; &#125;; stack&lt;char&gt; st; bool isValid = true; for(int i=0;i&lt;s.size();++i)&#123; if(s[i] == '[' || s[i] =='(' || s[i] == '&#123;')&#123; st.push(s[i]); &#125;else if(s[i] == ']' || s[i] == ')' || s[i] == '&#125;')&#123; if(!st.empty() &amp;&amp; mp[s[i]] == st.top())&#123; st.pop(); &#125;else&#123; isValid = false; break; &#125; &#125; &#125; if(isValid) isValid = st.empty() ? true : false; return isValid; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(1) Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 题目链接 解法1:暴力法依次枚举每个位置上的字符: 对于任意位置i,先将该位置上的字符设为’(‘,然后继续枚举下一个位置,直到所有位置都被枚举完成,判断形成的字符是否有效.处理完第i位上为’(‘之后,继续枚举第i位上为’)’.只需从第0位开始枚举, 将每个位置上都枚举完成,所有可能的字符串都枚举完成,也找出了所有有效的字符串.显然需要递归实现上述思路. 1234567891011121314151617181920212223242526272829bool vaild(string &amp;res) &#123; int bal = 0; for (int i = 0; i &lt; res.size(); ++i) &#123; bal += res[i] == '(' ? 1 : -1; if (bal &lt; 0) &#123; return false; &#125; &#125; return bal == 0;&#125;void generate(string &amp;res, int n) &#123; if (res.size() == n * 2) &#123; if (vaild(res)) &#123; for (auto c : res) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; &#125; else &#123; res.push_back('('); generate(res, n); res.pop_back(); res.push_back(')'); generate(res, n); res.pop_back(); &#125;&#125; 复杂度分析 时间复杂度 当给出n时, 所有可能的字符串有22 * n个. 这是因为共2 * n 个位置上,每个位置上有两种可能. 对于每一个字符串,枚举该字符串并检查该字符串的有效性的时间复杂度为O(n), 因此总的时间复杂度为O(n* 22 * n) 空间复杂度 如上所示,整个递归过程中,只用了一个string,在这个string中,最多只会存放长度为2n的字符串,因此,空间复杂度为O(n) 解法2: 改进版本在上述解法中,当已经能够被枚举的字符串无效时仍然继续枚举下一位置,因此浪费了很多时间.例如,对n=1,当位置0上的字符被设为’)’时,无论后续如何枚举,由这个’)’开始的字符串都是无效的.因此,提前退出枚举过程以减少运行时间. 12345678910111213141516171819void generate(string &amp;res, int n, int bal, vector&lt;string&gt; &amp;ans) &#123; if (res.size() == 2 * n) &#123; if (bal == 0) &#123; ans.push_back(res); &#125; &#125; else &#123; res.push_back('('); generate(res, n, bal + 1, ans); res.pop_back(); // 当我们能确定,被枚举的字符串不可能有效时,提前退出 // 换言之,只有当我们认为被枚举的字符串可能有效时,才继续枚举 if (bal &gt; 0) &#123; res.push_back(')'); generate(res, n, bal - 1, ans); res.pop_back(); &#125; &#125;&#125; 解法3: 闭合数将有效字符串表示为不相交子集的总和.考虑有效括号序列S的闭包数, 至少存在index&gt;=0, 使得S[0], S[1],…,S[2*index+1]是有效的.显然,每个括号序列都有唯一一个的闭包号. 对于每个闭合数c,起始和结束号位于索引0和2c+1.然后位于1-2\c之间的序列和位于2*c+1和2*n之间的序列都是有效序列. 123456789101112131415161718// 生成n对括号的有效序列vector&lt;string&gt; generate(int n) &#123; vector&lt;string&gt; ans; string res = ""; if (n == 0) &#123; ans.push_back(res); &#125; else &#123; for (int i = 0; i &lt; n; ++i) &#123; for (string left: generate(i)) &#123; for (string right: generate(n - 1 - i)) &#123; string tmp = '(' + left + ')' + right; ans.push_back(tmp); &#125; &#125; &#125; &#125; return ans;&#125; valid Parathesis stringGiven a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;. &#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string. An empty string is also valid. Example 1: 12Input: &quot;()&quot;Output: True Example 2: 12Input: &quot;(*)&quot;Output: True Example 3: 12Input: &quot;(*))&quot;Output: True Note: The string size will be in the range [1, 100]. 解法 1:对每个*进行枚举1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool checkValidString(string s) &#123; return checkValidStringCore(s, 0); &#125; bool checkValidStringCore(string&amp; s,int pos)&#123; if(pos == s.size())&#123; return valid(s); &#125; if(s[pos]=='*')&#123; string tmp ="()*"; for(int j=0;j&lt;tmp.size();++j)&#123; s[pos] = tmp[j]; if(checkValidStringCore(s, pos+1))&#123; return true; &#125; &#125; s[pos] = '*'; return false; &#125;else&#123; return checkValidStringCore(s, pos+1); &#125; &#125; bool valid(string s)&#123; int bal = 0; for(int i=0;i&lt;s.size();++i)&#123; if(s[i]=='(')&#123; ++bal; &#125;else if(s[i]==')')&#123; --bal; &#125; if(bal &lt; 0)&#123; return false; &#125; &#125; return bal == 0; &#125;&#125;; 解法2:动态规划 dp[i][j]表示字符串i到j位置上的子串是否有效.若i&gt;j为空串, dp[i][j]=true若i == j, dp[i][j]是否有效取决于字符串i位置上的字符是否为*, 即dp[i][j] = (s[i]==’‘)若i+1==j,则dp[i][j]会在四种情况下有效:s[i] == ‘(‘ &amp;&amp; s[j] == ‘)’s[i] == ‘(‘ &amp;&amp; s[j] == ‘\‘ s[i] == ‘*‘ &amp;&amp; s[j] == ‘)’s[i] == ‘*‘ &amp;&amp; s[j] == ‘*‘ 其余情况下为false若i+1&lt;jdp[i][j] = true只在一种情况下成立,即存在i&lt;k&lt;=j, s[i]和s[k]满足上述四种情况之一,且dp[i][k]=true &amp;&amp; dp[k+1][j]=true 12345678910111213141516171819202122232425262728293031bool checkValidString(string s) &#123; if (s.empty()) &#123; return true; &#125; vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == '*') &#123; dp[i][i] = true; &#125; if (i &lt; s.size() - 1 &amp;&amp; (s[i] == '(' || s[i] == '*') &amp;&amp; (s[i + 1] == ')' || s[i + 1] == '*')) &#123; dp[i][i + 1] = true; &#125; &#125; for (int j = 2; j &lt; s.size(); ++j) &#123; for (int i = 0; i &lt; s.size() - j; ++i) &#123; if (s[i] == '*' &amp;&amp; dp[i + 1][i + j]) &#123; dp[i][i + j] = true; &#125; else if (s[i] == '(' || s[i] == '*') &#123; for (int k = i + 1; k &lt;= i + j; ++k) &#123; if ((s[k] == ')' || s[k] == '*') &amp;&amp; (k == i + 1 || dp[i + 1][k - 1]) &amp;&amp; (k == i + j || dp[k + 1][i + j])) &#123; dp[i][i + j] = true; break; &#125; &#125; &#125; &#125; &#125; return dp[0][s.size() - 1];&#125; 复杂度分析 时间复杂度：O(n3) 空间复杂度：O(n2) 解法3: 贪心lo,hi分别表示尚未匹配的左括号的最少和最大数量.尚未匹配的左括号的最少数量在仅把左括号当做左括号时取得.最大数量在把所有*都当做右括号时取得. 当hi&lt;0时,说明即使把所有*都当做左括号也无法满足左括号和右括号之间的匹配关系,因此,此字符串无效. 当hi&gt;0, 而lo&lt;0时,说明将部分*当做左括号才能满足左括号和右括号之间的匹配关系. 当hi&gt;0, 而lo&gt;0时, 说明左括号的数量多于右括号的数量.尚未匹配的左括号的最少数量还是lo. 当hi=0,lo=0时,说明左括号和右括号的数量相等. 1234567891011121314bool checkValidString(string s) &#123; int lo = 0, hi = 0; for (auto c: s) &#123; lo += c == '(' ? 1 : -1; hi += c != ')' ? 1 : -1; if (hi &lt; 0) &#123; // 即使把所有的*号都看作左括号也不行 return false; &#125; // 如果将所有*号看做右括号时导致左括号较少，则将部分*号看做左括号 lo = max(lo, 0); &#125; return lo == 0; // 最后需要检查是否左右括号彻底抵消&#125; Longest valid parathesis题目链接 解法1:暴力破解列举从每个位置开始的子串能够获得的最大长度.若某位置的字符是’)’,则从该位置获取的最大子串长度为0. 解法2:使用栈如何形成思路? 解法3: 动态规划Score of Parentheses如何区分以位置j结尾的子问题和以位置开始的子问题 Given a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: 12Input: &quot;()&quot;Output: 1 Example 2: 12Input: &quot;(())&quot;Output: 2 Example 3: 12Input: &quot;()()&quot;Output: 2 Example 4: 12Input: &quot;(()(()))&quot;Output: 6 Note: S is a balanced parentheses string, containing only ( and ). 2 &lt;= S.length &lt;= 50 解法1:分而治之首先把整个字符串S分成多个子串s1, s2, …,sn.score(S) = score(s1)+score(s1)+…+score(sn) 接下来,计算每个子串si&gt;的分数,子串si有两种可能: 长度为2: score(si)=1 长度大于2:score(si) = 2 * score(si[1:n-1])(假设n为si.size()) 重点是从位置i到位置j中间的某个位置k，能够形成一个子串，这个子串是一个valid string 1234567891011121314151617181920212223242526class Solution &#123;public: int scoreOfParentheses(string S) &#123; if(S.empty())&#123; return 0; &#125; return scoreOfParenthesesCore(S, 0, S.size()-1); &#125; int scoreOfParenthesesCore(string s, int lo, int hi)&#123; int ans = 0, bal = 0; for(int k=lo;k&lt;=hi;++k)&#123; bal += s[k] == '(' ? 1 : -1; if(bal == 0)&#123; if(k - lo == 1)&#123; ans++; &#125;else&#123; ans += 2 * scoreOfParenthesesCore(s, lo + 1, k - 1); &#125; lo = k + 1; &#125; &#125; return ans; &#125;&#125;; 解法２栈解法3count cores]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题目分类总结]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这里将leetcode上刷的题目做一下分类． 纸牌博弈问题系列几道同类题目: Nim Game 此题较简单 stone game 此题首先需要定义递归函数,写出最简朴的做法 如何确定循环变量i和j的遍历方向 是否可以进行空间压缩,如何可以,如何压缩 stone game II 和stone game相比,有什么区别与联系 Predict the Winner 题号486 此题与上题几乎一模一样,但是需要注意,当player1与player2相等时的边界情况. Can I win 与上面两题之间有什么的联系与区别? 排列系列 Permutation Sequence 线段树系列 Range Sum Query - Mutable Count of Smaller Numbers After Self 广度优先搜索 Minimum Depth of Binary Tree 广度优先搜索专题：https://leetcode.com/tag/breadth-first-search/ 排列 Permutation Sequence(题号60) 百度之星[度度熊与排列] 题目链接 next permutation题目链接]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归这里</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[Permutation SequenceNext permutation 当整个是逆序时，无法找到下一个更大的排列了．如[3,2,1],此时按照题目要求，直接将序列逆序，变成[1,2,3]首先找到数组连续的一对数a[i]与a[i-1]，a[i] &gt; a[i-1].之后从a[i,…,n-1]中找出一个比a[i-1]大的最小的数arr[j]与a[i-1]交换．在交换之前，序列arr[i,…,n-1]满足逆序，由于arr[i-1] &lt; arr[j]小，交换之后的序列仍然满足逆序．reverse(arr[i,..n-1])注意：数组中存在重复元素时的情形．当arr[i,..n-1]满足逆序时，若数组arr[i,..n-1]中存在重复元素，则这两个重复元素必然相邻．交换两个相等元素，显然无用，因此，在前面寻找可交换元素的过程中，没有将两个相等元素作为寻找目标．但是此时，若这两个相等元素正是arr[i,..n-1]中比arr[i-1]大的最小的元素，那么此时该选择哪一个元素呢？答案是选择索引较大的那一个．因为索引较大的那一个目前处在较低位上，reverse之后处在较高位上． Next Permutation 视频：https://www.bilibili.com/video/av52421617?from=search&amp;seid=9609389838434247675&gt;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k sum 系列]]></title>
    <url>%2F2019%2F09%2F02%2Fk-sum-%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[two sumTwo Sum II - Input array is sorted3Sum4Sum4Sum IIk sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Target Sum 系列]]></title>
    <url>%2F2019%2F09%2F01%2FTarget-Sum-%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[combination sumCombination Sum IICombination Sum IIICombination Sum IV 3Sum4Sum4Sum II]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>target sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列1]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%97%EF%BC%91%2F</url>
    <content type="text"><![CDATA[显式转换旧式转型:T(expression)(T)expression 四种新式转型: cast-name&lt;type&gt;(expression): type是转换的目标类型，expression是要转换的值。若type是引用类型，则结果是左值。cast-name是static_cast，dynamic_cast，const_cast和reinterpret_cast中的一种。 旧式转换表面上功能强大，但是转化时不够明确，不能进行错误检查，容易出错． const_cast通常被用来将对象的常量性移除.即将const对象转为非const对象． dynamic_cast 主要用来执行“安全向下转型”,也就是用来决定某对象是否归属继承体系中的某个类型. 用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转化．只能转指针或引用．向下转化时，如果是非法的，对于指针返回nullptr，对于引用抛出异常． 向上转换：子类向基类的转换 向下转换：基类向子类的转换 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换． 它是唯一无法由旧式语法执行的动作,也是唯一可能耗费重大运行成本的转型动作. reinterpret_cast意图执行低级转型,实际动作(及结果)可能取决于编译器,这也就表示它不可移植.例如将一个pointer to int转型为一个int. 这一类型在低级代码以外很少见. static_cast用来强迫隐式转换. 将non-const对象转为const对象 或将int转为double 用于多台向上转化，如果向下转型能成功但是不安全，结果未知． 也可以用来执行上述多种转换的反向转换 将void*指针转为typed指针, 将point-to-base转为pointer-to-derived. 但它无法将const转为non-const,这个只有const_cast才办得到.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>static_cast</tag>
        <tag>类型转换</tag>
        <tag>显示转换</tag>
        <tag>cast</tag>
        <tag>const_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Rotate Array旋转数组 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: 123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: 12345Input: [-1,-100,3,99] and k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? 方法一：暴力破解方法二：使用额外空间方法三：循环移动1234567891011121314151617181920void rotate(vector&lt;int&gt; &amp;nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; // 如果移动的数量正好等于nums.size()时，每个元素移动后的位置都是移动前的位置 // 那么这个循环的唯一目的就是为了count++ // nums: [0,1,2,3], k=4 do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 具体过程[0,1,2,3,4,5,6] , k = 3时，start = 0, 0-3,3-6,6-2, 2-5, 5-1, 1-4, 4-0，此时count=7，start=0，current = 0, 故退出内层循环退出内层循环，又因为count==nums.size()，故退出外层循环．[0,1,2,3,4,5], k = 2时，start = 0, 0-2, 2-4, 4-0, current = 0, start = 0, count = 3,故退出内层循环．start = 1, 1-3, 3- 5, 5 - 1, current = 1, start = 1, 故退出内层循环．count = 6, 故退出外层循环． 时间复杂度: O(n)空间复杂度: O(1) 方法四：数组逆转123456789101112131415void reverse(vector&lt;int&gt; &amp;nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start, --end; &#125;&#125;void rotate1(vector&lt;int&gt; &amp;nums, int k) &#123; k = k % nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[字典树又称为单词查找树．主要应用于字符串的统计和排序，经常被搜索引擎用于文本词频统计． 参考文献[1] 字典树的C++实现 Implement of trie tree: https://blog.csdn.net/pyang1989/article/details/22834653]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[桶排序和计数排序]]></title>
    <url>%2F2019%2F08%2F26%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[比较排序,例如归并排序, 堆排序, 快速排序等等. 在比较排序中, 各元素的次序依赖于它们之间的比较.任何比较排序在最坏情况下都要经过O(nlogn)次比较.快速排序的额外空间复杂度为O(logn)，归并排序的空间复杂度为O(n)，堆排序的空间复杂度为O(1) 桶排序假设输入数据服从均匀分布, 平均情况下它的时间代价为O(n). 与计数排序类似,因为对输入数据做了某种假设, 桶排序的速度也很快.具体来说,计数排序假设数据都属于一个小区间内的整数, 而桶排序假设输入是由一个随机过程产生,该过程将元素均匀,独立地分布在[0,1]区间内.桶排序将[0,1]区间划分为n个相同大小的子区间, 或称为桶.然后将n个输入数分别放在各个桶中.因为输入数据是均匀,独立地分布在[0,1]区间上,所以一般不会出现很多数落在同一个桶中的情况.为了得到输出结果, 先对每个桶中的数进行排序,然后遍历每个桶,按照次序将各个桶中的元素列出来即可. 桶排序是稳定排序．如果有两个键值相同的元素进行排序，那么这两个元素排序前后的相对位置不会改变． 1234567891011121314151617181920212223242526272829303132333435363738394041424344void bucketSort1(vector&lt;int&gt; &amp;nums, int bucketSize) &#123; if (nums.size() &lt; 2) &#123; return; &#125; vector&lt;vector&lt;int&gt;&gt; help(nums.size(), vector&lt;int&gt;(0)); int i; int maxVal, minVal; maxVal = nums[0]; minVal = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; minVal) &#123; minVal = nums[i]; &#125; else if (nums[i] &gt; maxVal) &#123; maxVal = nums[i]; &#125; &#125; int bucketCount = (maxVal - minVal) / bucketSize + 1; vector&lt;vector&lt;int&gt;&gt; buckets(bucketCount, vector&lt;int&gt;(0)); for (int i = 0; i &lt; nums.size(); ++i) &#123; int index = (nums[i] - minVal) / bucketSize;// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; nums[i] &lt;&lt; " index:" &lt;&lt; index &lt;&lt; endl; buckets[index].push_back(nums[i]); &#125; int arrIndex = 0; for (int i = 0; i &lt; buckets.size(); ++i) &#123; if (buckets[i].empty()) &#123; continue; &#125; insectionSort(buckets[i]); // cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个桶中:";// for (int j = 0; j &lt; buckets[i].size(); ++j) &#123;// cout &lt;&lt; buckets[i][j] &lt;&lt; " ";// &#125;// cout &lt;&lt; endl; for (int value : buckets[i]) &#123; nums[arrIndex++] = value; &#125; &#125;&#125; 另一种与桶排序相关的排序方法. 12345678910111213141516171819202122232425262728293031323334// max是数组中元素的最大值, 数组中的元素都在0-max之间void bucketSort(vector&lt;int&gt; &amp;arr, int max) &#123; int i, j; vector&lt;int&gt; buckets(max, 0); // 桶数组,所有 if (arr.empty() || max &lt; 1) &#123; return; &#125; for (int i = 0; i &lt; arr.size(); ++i) &#123; buckets[arr[i]]++; &#125; // bucket[i]表示数组arr中等于i的元素个数 for (int i = 0, j = 0; i &lt; maxVal; ++i) &#123; // 当数组arr中等于i的元素个数不为0,就把元素i加入到原来的数组arr中 while ((buckets[i]--) &gt; 0) &#123; arr[j++] = i; &#125; &#125;&#125;void testBucketSort() &#123; vector&lt;int&gt; arr = &#123;8, 2, 3, 4, 3, 6, 6, 3, 9&#125;; for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; bucketSort(arr, 10); for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 计数排序计数排序假设n个输入元素的每一个都是在0-k区间内的一个整数,其中k为某个整数.计数排序的基本思想:对于每一个输入元素x, 确定小于x的元素个数,.利用这一信息,就可以直接把x放在它在输出数组中的位置上了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445void countingSort(vector&lt;int&gt; &amp;nums) &#123; if (nums.size() &lt; 2) &#123; return; &#125; int maxVal = -2147483648; for (int i = 0; i &lt; nums.size(); ++i) &#123; maxVal = maxVal &gt; nums[i] ? maxVal : nums[i]; &#125; vector&lt;int&gt; count(maxVal + 1, 0); // count[i]表示数组nums中等于i的元素个数 for (int i = 0; i &lt; nums.size(); ++i) &#123; ++count[nums[i]]; &#125; // count[i]表示数组nums中小于等于i的元素个数 for (int i = 1; i &lt; count.size(); ++i) &#123; count[i] += count[i - 1]; &#125; vector&lt;int&gt; aux(nums.size()); for (int i = 0; i &lt; nums.size(); ++i) &#123; // count[nums[i]]表示数组nums中小于等于nums[i]的元素个数,因此count[nums[i]]也就是nums[i]在排序后数组中的位置// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; nums[i] &lt;&lt; " count:" &lt;&lt; count[nums[i]] &lt;&lt; endl; aux[--count[nums[i]]] = nums[i]; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; nums[i] = aux[i]; &#125; cout &lt;&lt; endl;&#125;void testcountingSort() &#123;// vector&lt;int&gt; nums&#123;2, 1, 2, 4, 5&#125;; vector&lt;int&gt; nums&#123;5, 4, 3, 2, 2, 4, 1&#125;; for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; countingSort(nums); for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 基数排序假设n个d位的元素存放在数组A中, 其中第1位是最低位, 第d位是最高位. 123radixSort(A, d) for i = 1 to d use a stable sort to sort array A on digit i]]></content>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork函数]]></title>
    <url>%2F2019%2F08%2F24%2Ffork%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[fork基本概念一个进程, 包括代码, 数据和分配给该进程的资源. fork()通过系统调用创建一个与原来进程几乎完全相同的进程.也就是两个进程做完全相同的事.但是如果初始参数或者传入的变量不同,两个进程也可以做不同的事情. 一个进程调用fork()函数后,系统先给新的进程分配资源.如存储数据和代码的存储空间.然后吧原来的进程的所有值都复制到新进程中,只有少数值与原来的进程的值不同.相当于克隆了一个自己.创建新进程成功后, 系统中出现两个几乎完全相同的进程,这两个进程执行没有固定的先后顺序, 哪个进程先执行要看系统的进程调度策略. 由fork函数创建的新进程被称为子进程。fork函数被调用一次，但是返回两次。父进程返回的值是新进程的进程ID，而子进程返回的值是0。 fork函数返回值的三种情况 返回子进程Id给父进程 因为一个进程的子进程可能有多个，并且没有一个函数可以获得一个进程的所有子进程ID。 返回给子进程值为0 一个进程只会有一个父进程，所以子进程总是可以调用getpid以获得当前进程Id以及调用getppid获得父进程Id. 出现错误，返回负值 当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN 系统内存不足，这时errno的值被设置为ENOMEM 子进程执行代码开始位置 fork可以创建一个子进程并完全复制父进程,但是子进程是从fork后面那条指令开始执行的.如果子进程也从main开始执行所有指令,那么它执行到fork指令时必然会创建一个新的子进程. 从而导致不停地创建子进程,程序永不结束 示例1fork创建子进程1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); break; case 0: message = "this is the child"; n = 5; break; default: message = "this is the parent"; n = 3; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(3); &#125; return 0;&#125; 运行结果 123456789101112xixi@xixi:~/linux_cource/11.3$ ./a.out fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childxixi@xixi:~linux_cource/11.3$ this is the childxixi@xixi:~/linux_cource/11.3$ 程序在调用fork时被分为两个独立的进程.当用fork启动一个子进程时, 子进程就有了它自己的生命周期并将独立运行.父进程在子进程之前结束, 因此在输出内容中有一个shell提示符. 让父进程等待子进程结束如果希望父进程等待子进程结束,可以调用wait函数.函数原型: pid_t wait(int* stat_loc);wait系统调用返回子进程的pid, 通常是已经结束运行的子进程的pid.状态信息允许父进程了解子进程的退出状态, 即子进程的main函数返回的值或者子进程中exit函数的退出码.如果stat_loc不是空指针, 状态信息将被写入到它所指向的位置. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 3; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行结果 1234567891011fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childthis is the childchild has finished: PID: 15467child exited with code 37 查看僵尸进程子进程终止时,它与父进程之间的关联还会保持, 直到父进程也正常终止或父进程调用wait才会结束.因此,进程表中代表子进程的表项不会立即释放.虽然子进程已经不再运行,但它仍然存在于系统中,因为它的退出码还需要保存起来,以备父进程今后的wait调用使用.这时候它将成为一个死进程或者僵尸进程.所以,僵尸进程就是这样一种进程: 它自身运行已经结束,但是进程控制块还没有释放.因为还有其他进程需要它的运行状态等信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 10; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); // stat_val中保存这子进程的状态信息 cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行过程中在命令行中查看wait进程的信息(上面这个程序在编译时被命名为wait) 12345678xixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 ./waitxixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 [wait] &lt;defunct&gt; 上面的运行结果可以看出,一开始子进程正常运行,后来子进程变成了僵尸进程.如果父进程异常终止, 子进程将自动把pid等于1的进程(即init进程)作为自己的父进程.子进程现在是一个不再运行的僵尸进程,但是由于父进程异常终止,所以它由init进程接管.僵尸进程将一直保留在进程表中知道被init进程发现并释放.进程表越大,这一过程越慢. 常用的两种应用场景 一个父进程希望复制自己,使父子进程同时执行不同的代码段.这在网络服务中是常见的. 父进程等待客户端的服务请求.当这种请求到达时,父进程调用fork,使子进程处理此请求.父进程则继续等待下一个服务请求的到达. 一个进程要执行一个不同的程序.这是shell常见的情况.子进程从fork返回后立即调用exec. 123456789101112131415161718192021pid_t pid;int ctr = 0;cout &lt;&lt; "当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;// 在这个位置,仅仅父进程会执行cout &lt;&lt; "unique" &lt;&lt; endl;pid = fork(); // 仅调用一次,返回两次if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1);&#125; else if (pid == 0) &#123; ++ctr; cout &lt;&lt; "进入子进程, 当前进程id=" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125; else &#123; ++ctr; cout &lt;&lt; "当前进程id=" &lt;&lt; getpid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125;// 在这个位置,则父子进程都会执行cout &lt;&lt; "reduant" &lt;&lt; endl; 执行结果 123456当前进程, id=7346unique当前进程id=7346 ctr=1reduant进入子进程, 当前进程id=7347 父进程id=7346 ctr=1reduant 执行fork前, ctr=0; 执行fork后,对于父进程而言会执行ctr自增和打印进程信息两个操作. 因此打印出的ctr=1.对于子进程而言,由于执行fork前ctr=0,因此在子进程中ctr=0, 同样子进程执行ctr自增和打印进程信息操作.因此打印出的ctr=1 12345678910111213141516pid_t pid;int loop;// cout &lt;&lt; "我是父进程, 当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;for (loop = 0; loop &lt; 2; ++loop) &#123; pid = fork(); //一个子进程第一次调用fork,返回0,表示该进程本身是子进程,第二次fork产生一个以当前子进程为父进程的子进程 if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1); &#125; else if (pid == 0) &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid &lt;&lt; endl; sleep(5); &#125;&#125; 执行结果 123456loop=0 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5948loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0loop=1 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=5949loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0loop=1 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5952loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0 过程解释 进程5947使用fork产生一个子进程5948. fork执行时loop=0.因此子进程5948中loop=0. 子进程5948第一次调用fork的返回值pid是0,表明进程5948是子进程, 因此直接打印出”loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0”; 当进程5948第二次调用fork时, 产生一个新的子进程5949. 在进程5948中,调用fork函数前, loop=1,因此在新的子进程5949中loop=1. 也因此子进程5949只会调用一次fork(就会因为loop&gt;=2而跳出循环). 在子进程5949的运行过程中只会打印出”loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0” 而对于进程5947, 在第一次循环结束后继续执行第二次循环. 此时loop=1. 调用fork后, 产生一个新的子进程5952, 该子进程中loop=1. 因此类似的, 进程5952只会打印出”loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0” 参考文献[1] https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html[2] https://www.jianshu.com/p/586300fdb1ce]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F08%2F19%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树结构 线段树每个节点存储了一个区间上的元素之和． 线段树可以做什么？ 线段树可以在线维护以及查询区间上的最值，求和． 可以扩展到二维线段树（矩阵树）和三维线段树（空间树） 对于一维线段树来说，每次更新以及查询的时间复杂度为O(logn) 线段树中存储树结构所需要的空间大小 无优化的线段树需要2*2k（2k-1&lt;n&lt;2k）空间,一般会开到4*n的空间防止RE Count of Smaller Numbers After Self建立一个线段树，每个节点表示在某个范围内的元素的个数． 参考文献[1] https://www.cnblogs.com/xenny/p/9801703.html[2] 线段树详解: https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++数据类型基础]]></title>
    <url>%2F2019%2F08%2F17%2Fc%2B%2B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文主要是总结一下C++语言常用的数据类型基础知识，如类型转换，整形的最大最小数值等。 无符号数示例1 1234unsigned int u = 0xFFFFFFFF;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //4294967295u -= 31;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl;//4294967264 无符号数0xFFFFFFFF是32位无符号数中的最大值。 示例2：无符号数和有符号数运算 12345unsigned int u = 10;int i = -42;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; // 10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967296 + (-42)cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl; // 4294967264 无符号数u和有符号数i相加前，把有符号数i转换为无符号数，结果等于两个无符号数相加。 示例3： 12345unsigned int u = 10;int i = -1;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967295cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl;//(4294967295 + 10) % (4294967296)，其中4294967296是2的32次方 两个无符号数相加结果超出它表示范围时，先对这个超出表示范围的结果进行取模(对2的n次方进行取模)，则得到了真正的结果。 示例4：无符号数都是整数。若给无符号赋值一个负数，则将该负数+2n得到最后的结果。 123456unsigned int x = 0xFFFFFFFF;unsigned int u = 10;unsigned int v = 42;cout&lt;&lt;"x:"&lt;&lt;x&lt;&lt;endl;cout&lt;&lt;"(v - u):"&lt;&lt;(v - u)&lt;&lt;endl; // 32cout&lt;&lt;"(u - v):"&lt;&lt;(u - v)&lt;&lt;endl; // 4294967264: (-32 + 4294967296) % 4294967296的结果 示例5：当表达式中既有带符号数又有无符号数时，当带符号数值为负数时会出现异常情况，这是因为带符号数会自动转换成无符号数。 123unsigned int x = 1;int y = -1;cout&lt;&lt;"x * y="&lt;&lt;(x * y)&lt;&lt;endl; //4294967295，y转换为无符号数(-1 + 4294967296) = 4294967295 常用的一些16进制数 0xffffffff 0xffffffff是一个十六进制数。把它转换成2进制为：1111111..11(32个1)把它转成10进制无符号数是：0xffffffff = 16x10^7+ 16x10^6+….+16x10^1+16x10^0 = 4294967295把它转成10进制带符号整数为：111111111111111(32个1表示的补码形式)转化为源码形式为10…00001(中间30个0)，即-1。 1234unsigned int a = 0xffffffff;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // 4294967295int b = 0xffffffff; cout&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl; // b = -1 0x3f3f3f3f 0x3f3f3f3f用于表示无穷大．它具有诸多优良性质．无穷大 + 无穷大 ＝ 无穷大无穷大 + 常数 = 无穷大 异或运算异或运算满足交换律与结合律。C = A ^ B (^是异或运算符)，则 A = B ^ C, B = A ^ C 例1. A = 1011, B = 0101 , C= 1110若A和B在某一位上都是1， 则C在该位上为0，则A或B的该位与C的该位相与就是1；若A和B在某一位上都是0， 则C在该位上为0，则A或B的该位与C的该位相与就是0。若A在某一位为1， B在该位为0， 则C在该位上为1，则A的该位与C的该位相与就是0，B的该位与C的该位相与就是1。同理，A在该位为0，B在该位为1时可证成立。 按位取反~1234567int a = -2147483648;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // -2147483648cout&lt;&lt;" ~a="&lt;&lt;~a&lt;&lt;endl; // 2147483647bitset&lt;32&gt; b1(a); bitset&lt;32&gt; b2(~a); cout&lt;&lt;"a: "&lt;&lt;b1.to_string()&lt;&lt;endl;// 10..00cout&lt;&lt;" ~a: "&lt;&lt;b2.to_string()&lt;&lt;endl;// 011..11 补码、原码、求补运算负数的补码由其原码对除符号位外各位取反末位加1，同样，由补码求原码也是对补码除符号位外，各位取反末位加1。求补运算：不考虑符号位，对原码各位取反，并在末位加1。对一个数进行求补运算得到的是其相反数的补码。如对0111进行求补运算，0111的真值为7。其补数为1001（补码），补码1001对应的源码为1111，真值为-7。 n &amp;(~n+1)这个表达式常用来取n中最右侧的1。这是因为, ~n是对进行按位取反。例如：n = 1000，n=0111, ~n+1 = 1000, n &amp; (n+1)=1000，只有n中最右边为1的位置为1。n = 1010， n=0101，n+1=0110, n &amp; (~n+1)=0010。 参考文献[1] 0x3f3f3f3f: https://blog.csdn.net/hzh_0000/article/details/9468377]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>无符号数</tag>
        <tag>补码</tag>
        <tag>原码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404. Sum of Left Leaves]]></title>
    <url>%2F2019%2F08%2F14%2F404.-Sum-of-Left-Leaves%2F</url>
    <content type="text"><![CDATA[题目链接 Find the sum of all left leaves in a given binary tree. Example: 1234567 3 / \ 9 20 / \ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 如何确定左叶子节点，首先该节点必须是一个叶子节点，其次它必须位于其父节点的左子树上．当使用先序遍历时，该节点存在于左子树上且是一个叶子节点． 12345678910111213141516171819202122232425class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; return sumOfLeftLeavesCore(root); &#125; int sumOfLeftLeavesCore(TreeNode* root)&#123; int sum = 0; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while(cur!=nullptr || !st.empty())&#123; if(cur == nullptr)&#123; cur = st.top(); st.pop(); cur = cur-&gt;right; &#125;else&#123; st.push(cur); cur = cur-&gt;left; if(cur &amp;&amp; cur-&gt;left == nullptr &amp;&amp; cur-&gt;right == nullptr)&#123; sum += cur-&gt;val; &#125; &#125; &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeof]]></title>
    <url>%2F2019%2F08%2F12%2Fsizeof%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[sizeof运算符返回一条表达式或一个类型所占的字节数.sizeof运算符的结果是一个size_t类型的值. sizeof运算符满足右结合律.因此,表达式sizeof p等价于sizeof(\p). 这是因为sizeof满足右结合律且与*运算符的优先级相同.所以表达式会按照从右向左的顺序组合. sizoef运算符并不实际求其运算对象的值.因此,sizeof运算可以对一个无效指针进行运算. 以下是各种内置数据类型在64位机器上所占空间大小: 12345678910111213141516171819cout &lt;&lt; "sizeof(int):" &lt;&lt; sizeof(int) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(float):" &lt;&lt; sizeof(float) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(double):" &lt;&lt; sizeof(double) &lt;&lt; endl;// 8cout &lt;&lt; "sizeof(char):" &lt;&lt; sizeof(char) &lt;&lt; endl; // 1int *p = 0;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl;p = new int&#123;12&#125;;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl; sizeof运算符与数组 对数组执行sizeof运算得到整个数组所占空间的大小.sizeof运算不会把数组名转成指针来处理 可以利用sizeof运算符来求数组中元素个数. 12345int arr[] = &#123;1, 2, 3&#125;;cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 12(4x3)int n = sizeof(arr) / sizeof(*arr);cout &lt;&lt; "n=" &lt;&lt; n &lt;&lt; endl; // 3,数组中元素个数 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小,不会计算对象中的元素占用了多少空间 1234vector&lt;int&gt; arr&#123;1, 3, 7, 3&#125;;vector&lt;int&gt; brr(100, 0);cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 24cout &lt;&lt; "sizeof(brr):" &lt;&lt; sizeof(brr) &lt;&lt; endl; // 24]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列2]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[对于类类型的类型转换,通过定义类型转换运算符完成.转换构造函数和类型转换运算符共同定义了类类型转换.类型转换运算符没有显式的返回类型,也没有星灿,而且必须定义成类的成员函数.类型转换运算符一般不改变待转换对象的内容.因此,类型转换运算符一般是const的. 123456789101112131415161718192021222324252627282930/** * SmallInt既定义了向类类型的转换,也定义了从类类型向其他类型的转换 * 构造函数将算类型的值转换成SmallInt类型对象,类型转换运算符将SmallInt对象转换成int */class SmallInt &#123;public: SmallInt(int i = 0) : val(i) &#123; if (i &lt; 0 || i &gt; 255) &#123; throw std::out_of_range("Bad SmallInt value"); &#125; &#125; // 类型转换运算符:把类类型SmallInt转成int类型 operator int() const &#123; return val; &#125;private: std::size_t val;&#125;;int main()&#123; SmallInt s = 4; // s是一个SmallInt类型对象,val=4 cout &lt;&lt; s + 4 &lt;&lt; endl; // 8 SmallInt si = 3.14; // si是一个SmallInt类型对象,val=3 cout &lt;&lt; si + 3.14 &lt;&lt; endl; // 6 return 0;&#125; SmallInt s = 4首先将4隐式地转换为SmallInt,然后调用SmallInt::operator=(拷贝赋值运算符). s + 4首先将s隐式地转换成int,然后执行整数的加法 si = 3.14, 首先内置类型转换将double实参转换成int,然后再调用SmallInt(int)构造函数 在表达式si + 3.14中, 首先SmallInt类型转换运算符将si转换成3,然后内置类型转换将所得int继续转换为double. 编译器一次只能执行一个用户定义的类型转换,但是隐式的用户定义类型转换可以置于一个标准类型转换之前或之后]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>类类型隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum 系列, 和为s的两个数字系列(2sum)]]></title>
    <url>%2F2019%2F07%2F17%2FTwo%20Sum%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[和为S两个数字 题目来源：剑指offer题目链接 题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 1对应每个测试案例，输出两个数，小的先输出。 解法1: 使用set1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; set&lt;int&gt; iset; vector&lt;int&gt; res(2); int mul = INT_MAX; for(int i=0;i&lt;array.size();i++)&#123; if(iset.find(sum - array[i])!=iset.end())&#123; int temp = array[i] * (sum - array[i]); if(temp &lt; mul)&#123; mul = temp; res[0] = sum - array[i]; res[1] = array[i]; &#125; &#125; iset.insert(array[i]); &#125; if(mul == INT_MAX)&#123; return &#123;&#125;; &#125; return res; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(n) 解法2 思路：数组是有序的，可以用双指针。 细节处理稍有不同的两种AC代码。 AC代码： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; if(array.size() &lt; 2)&#123; return &#123;&#125;; &#125; int a = -1, b = -1; int mul = 2147483647; int i = 0, j = array.size() - 1; while(i &lt; j)&#123; if(array[i] + array[j] == sum)&#123; if(array[i] * array[j] &lt; mul)&#123; mul = array[i] * array[j]; a = array[i]; b = array[j]; &#125; &#125; if(array[i] + array[j] &gt; sum)&#123; j--; &#125;else&#123; i++; &#125; &#125; vector&lt;int&gt; res; if(a!=-1 &amp;&amp; b!=-1)&#123; res.push_back(a); res.push_back(b); &#125; return res; &#125;&#125;; AC代码2 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; if(array.size() &lt; 2)&#123; return &#123;&#125;; &#125; int a = -1, b = -1; int mul = 2147483647; int i = 0, j = array.size() - 1; while(i &lt; j)&#123; if(array[i] + array[j] == sum)&#123; if(array[i] * array[j] &lt; mul)&#123; mul = array[i] * array[j]; a = array[i]; b = array[j]; &#125; i++; j--; &#125; else if(array[i] + array[j] &gt; sum)&#123; j--; &#125;else&#123; i++; &#125; &#125; vector&lt;int&gt; res; if(a!=-1 &amp;&amp; b!=-1)&#123; res.push_back(a); res.push_back(b); &#125; return res; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(1) 和为S的连续正数序列题目链接 题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解法112345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; if(sum == 1)&#123; return &#123;&#125;; &#125; int thisSum = 0; vector&lt;vector&lt;int&gt;&gt; res; int n = (sum + 1) / 2; vector&lt;int&gt; ans(n+1, 0); for(int i=1;i&lt;=n;i++)&#123; thisSum += i; ans[i] = thisSum; &#125; for(int i=0;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(ans[j] - ans[i] == sum)&#123; vector&lt;int&gt; tmp; for(int k=i+1;k&lt;=j;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; &#125; &#125; return res; &#125;&#125;; 使用累计和的概念.ans[i]统计0-i的和. 解法21234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; int l = 1, r = 2; int thisSum = l + r; vector&lt;vector&lt;int&gt;&gt; res; while(l&lt;= (1+sum)/2)&#123; if(thisSum == sum)&#123; vector&lt;int&gt; tmp; for(int k=l;k&lt;=r;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; if(thisSum &lt; sum)&#123; thisSum += ++r; &#125;else&#123; thisSum -= l++; &#125; &#125; return res; &#125;&#125;; thisSum表示子数组arr[l,…,r]的累加和. 最初, l=1, r =2, 最小的两个连续正数序列的和为1+2=3.所以,将thisSum初始化为3.循环结束条件为两个数的和大于等于sum时,因此可知,满足这个条件的最大的子数组为[n, n+1], n = (1+sum)/2.因此,需要循环结束条件为l = (1+sum)/2 Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 此题和上题的区别有两点： 返回下标，而不是值 数组不是有序的 若是返回的是值，可以对数组进行排序然后按双指针解。时间复杂度为O(nlogn)。排序的时间复杂度为O(n)。 解法1：暴力破解1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size()-1; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[i] + nums[j] == target)&#123; return &#123;i, j&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n2)，空间复杂度为O(1)。 解法2：两趟哈希表12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; mp[nums[i]] = i; &#125; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!= mp.end() &amp;&amp; mp[complement]!=i)&#123; return &#123;i, mp[complement]&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法3：一趟哈希表1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!=mp.end())&#123; return &#123;mp[complement], i&#125;; &#125; mp[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 3SumMedium Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路：首先对数组进行排序。然后锁定第一个数，如第一个数的索引是i，则此后在front-back范围内（front &gt; i）寻找两个数，使他们的和为0 - nums[i]。随着i后移，front和back指定的范围在缩小。因为nums[i]增大，则0 - nums[i]减小。且移动过程中需要去重。 如将上例数据改为： 1Given array nums = [-1, 0, 1, 0, 1, 2, -1, -4, 2, 3] 则排序后： 1array nums = [-4, -1, -1, 0, 0, 1, 1, 2, 2, 3] 过程如下：注意去重 i = 0, front = 1, back = 9, 在front-back中找两个数的和为4 front = 5, back= 9, nums[5]=1, nums[9]=3(front = 6, nums[front]=1，需要去重) front = 7, back=8, nums[7]=2, nums[8]=2i = 1, front = 1, back = 9, 在front-back中找两个数的和为1 front = 2, back = 8, nums[2] = -1, nums[8] = 2 front = 3, back = 6, nums[3] = 0, nums[6] = 1(后面back=5, nums[5]=0, 需要去重)i = 2(nums[2] = -1需要去重)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortest Unsorted Continuous Subarray]]></title>
    <url>%2F2019%2F07%2F17%2FShortest%20Unsorted%20Continuous%20Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: 123Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 解法1:暴力破解假设数组nums长度为n。考虑每一个可能的子数组nums[i:j]，要使得nums[i:j]是最长的未排序子数组，需要满足以下条件：nums[0:i-1]是有序的，nums[j+1:n-1]是有序的。nums[i:j]是无序的，且nums[i:j]中的最小值大于nums[i-1]，nums[i:j]中的最大值小于nums[j+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int res = nums.size(); for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i;j&lt;nums.size();j++)&#123; int min_val = 2147483647; int max_val = -2147483648; int prev = - 2147483648; for(int k=i;k&lt;j;k++)&#123; min_val = min_val &gt; nums[k]? nums[k]:min_left; max_val = max_val &gt; nums[k]? max_val:nums[k]; &#125; // min_val为nums[i:j]中的最小值，max_val为nums[i:j]中的最大值 //nums[0:i]或者nums[j+1:]不满足有序 if((i&gt;0 &amp;&amp; nums[i-1] &gt; min_val) || (j &lt;nums.size() &amp;&amp; nums[j] &lt; max_val))&#123; continue; &#125; int k = 0; //nums[0:i]是有序的 //若能成立则运行完后prev=nums[i-1] while(k &lt; i &amp;&amp; prev &lt;= nums[k])&#123; prev = nums[k]; k++; &#125; if(k!=i) continue; k = j; //nums[j:]是有序的且nums[j] &gt;= nums[i-1] while(k &lt; nums.size() &amp;&amp; prev&lt;=nums[k])&#123; prev = nums[k]; k++; &#125; // 思考一下：为什么要小于呢？ if(k==nums.size())&#123; res = res &gt; j - i ? j - i:res; &#125; &#125; &#125; return res; &#125;&#125;; 解法2：较好一点的暴力破解如果对于nums[i]来说，其前面的数都小于等于它，后面的数都大于等于它，则它的位置是正确的，否则它的位置是错误的。一对相距最远的数的位置就是我们要找的。遍历数组，每次遇到逆序的数就更新左边界和右边界。左边界取较小的，右边界取较大的。 123456789101112131415class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int l = nums.size(), r = 0; // l是左边界，r是右边界，左边界取较小的，右边界取较大的 for(int i=0;i&lt;nums.size()-1;i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[j] &lt; nums[i])&#123; r = r &gt; j? r : j; l = l &lt; i? l : i; &#125; &#125; &#125; return r - l &lt; 0?0:r - l + 1; &#125;&#125;; 时间复杂度为O(n2)。 解法3：使用栈和解法2的思路一样都是不断更新左边界和左边界。 12345678910111213141516171819202122232425class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; stack&lt;int&gt; st; int l = nums.size(), r = 0; for(int i=0;i&lt;nums.size();i++)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &gt; nums[i])&#123; l = l &gt; st.top()? st.top():l; st.pop(); &#125; st.push(i); &#125; while(!st.empty())&#123; st.pop(); &#125; for(int i=nums.size()-1;i&gt;=0;i--)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i])&#123; r = r &gt; st.top()?r:st.top(); st.pop(); &#125; st.push(i); &#125; return r - l ? r - l + 1: 0; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法4：两次遍历两次遍历，分别找左边界和右边界。左边界是位置最左，且逆序的数，右边界是位置最右且逆序的数。一个数若大于其后任意一个数就可以判断该数是逆序的。因此，一个数若大于其后最小的一个数既可以看做是逆序的。同样，一个数若小于其前面任意一个数即可认定该数是逆序。因此，一个数若小于其前面最大的一个数即可认定该数是逆序的。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2)&#123; return 0; &#125; int leftmost = -1, rightmost = -1; int min_right = nums[nums.size()-1]; int max_left = nums[0]; for(int i=nums.size()-2;i&gt;=0;i--)&#123; if(nums[i] &gt; min_right)&#123; leftmost = i; &#125;else&#123; min_right = nums[i]; &#125; &#125; if(leftmost == -1)&#123; return 0; &#125; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i] &lt; max_left)&#123; rightmost = i; &#125;else&#123; max_left = nums[i]; &#125; &#125; return rightmost - leftmost + 1; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>连续子数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis使用过程中遇到的问题]]></title>
    <url>%2F2019%2F07%2F17%2Fredis%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述redis使用过程中发现redis返回的数据中str类型都是byte类型。byte类型使用很不方便，所以就想转成str类型。 初始时建立redis连接代码为： 1r1 = redis.Redis(host=redis_host, port=6379, db=1) 在网上搜索了一番，在csdn找到这个答案（详见https://ask.csdn.net/questions/381758）：在建立连接时，将decode_responses置为True。即这样建立连接： 1r1 = redis.Redis(host=redis_host, port=6379, db=1, decode_responses=True) 经过测试，这个问题成功解决了。 redis的字符串redis中的字符串是一种名为sds(简单动态字符串)的抽象数据类型来表示.所有sds API都以处理二进制的方式来处理string类型对象的数据,程序中不对数据做任何的限制,过滤或者假设.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Validate Stack Sequences(946)]]></title>
    <url>%2F2019%2F07%2F17%2F946.%20Validate%20Stack%20Sequences%2F</url>
    <content type="text"><![CDATA[Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: 12345Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 Example 2: 123Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 题意是说，给定一个入栈序列和一个可能的出栈序列，问在给定的入栈序列下能否得到出栈序列。如果能返回true，否则返回false。 此题的解决是模拟。模拟入栈入栈并出栈的问题，尽量得到和给定的出栈序列一致的出栈序列。如例1，首先为了得到第一个出栈的是4，则必须将[1,2,3,4]入栈，然后将4出栈，则从栈底到栈顶的元素分别为[1,2,3]。第二步，为了得到出栈序列中的第二位5，必须将5入栈，然后将5出栈，得到出栈序列中的第二位，此时，栈中栈底到栈顶的各元素分别为[1,2,3]。第三步为了得到3，直接将栈顶元素出栈即可。第四步和第五步同第三步。 对于例2，同样，第一步为了得到出栈序列中的4，将1,2,3,4依次入栈，并将4出栈，得到出栈序列中的第一位，此时栈底到栈顶的各元素为[1,2,3]。第二步，为了得到出栈序列中的第二位3，将此时的栈顶元素3直接出栈即可。第三步，为了得到5，将5入栈，继而出栈，得到出栈序列[4,3,5]。第四步，需要得到出栈序列中的第四位1，每一步当我们希望得到出栈序列中的下一位时，我们有两个选择，要么这一位还未入栈，如第一步中的4，对于这种情况，我们需要将后续元素入栈，另一种情况是，这一位就是栈顶元素，如第二步中的3。此时，所有入栈序列中的元素都已经入栈，那么只有一种可能了，那就是出栈序列中的下一位就是栈顶元素。但是，通过比较出栈序列中的下一位和栈顶元素可知，栈顶元素不是出栈序列中的下一位，因此，此出栈序列无法由入栈序列得到，返回false。 AC代码 123456789101112131415161718class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int k = 0; for(int i=0;i&lt;popped.size();i++)&#123; while(k &lt; pushed.size() &amp;&amp; (st.empty() || st.top()!=popped[i]))&#123; st.push(pushed[k++]); &#125; if(st.top()==popped[i])&#123; st.pop(); &#125;else&#123; return false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[877. Stone Game]]></title>
    <url>%2F2019%2F07%2F17%2F877.Stone-Game%2F</url>
    <content type="text"><![CDATA[Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. 相关题目: 486. Predict the Winner Example 1: 12345678Input: [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. 错误的思路一开始以为可以用双指针的方式解决：每次贪心，选择从排在最前面和最后面的石头堆里选择数量较大的那堆。后来发现我太天真了。比如说这个例子： Example 1[5,3,2,7,5,2] 如果按照上面的贪心办法，那么alex会选到:5,2(选择最前面的2),5 5+2+5=12lee选到剩下的3,7,2 3+7+2=12所以结果返回false.但是如果alex这么选：5, 2（选择排序最后的2）,7 5+2+7 =14. lee选择剩下的3,2,5 3+2+5=10结果返回true。 123456789101112131415161718192021222324252627bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k; k = 0; i = 0, j = piles.size()-1; int sum_alex=0, sum_lee=0; while(k&lt;piles.size())&#123; int select; if(piles[i]&gt;=piles[j])&#123; select = piles[i]; i++; &#125;else&#123; select = piles[j]; j--; &#125; if(k&amp;1)&#123; // lee sum_lee += select; &#125;else&#123; // alex sum_alex+= select; &#125; k++; &#125; cout&lt;&lt;"sum_alex="&lt;&lt;sum_alex&lt;&lt;" sum_lee="&lt;&lt;sum_lee&lt;&lt;endl; if(sum_alex &gt; sum_lee)&#123; return true; &#125; return false;&#125; 想到的第二种解法：回溯. 悲催的是，超时了。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k, ans, best; k = 0; i = 0, j = piles.size()-1; ans = 0, best = 0; int sum = 0; for(auto pile:piles)&#123; sum+=pile; &#125; dfs(ans, best, k, piles, i, j); if(best &gt; sum - best)&#123; return true; &#125; return false; &#125; void dfs(int &amp;ans,int &amp;best, int k, vector&lt;int&gt;&amp;piles, int i, int j)&#123; if(i==j)&#123; if(best &lt; ans)&#123; best = ans; &#125; return; &#125; // 选择i ans += k%2==0?piles[i]:0; dfs(ans, best, k+1, piles, i+1, j); ans -= k%2==0?piles[i]:0; // 选择j ans += k%2==0?piles[j]:0; dfs(ans, best, k+1, piles, i, j-1); ans -= k%2==0?piles[j]:0; &#125;&#125;; 那么接下来，我能想到的唯一可能求解的方法就是动态规划的了，那么问题来了，状态转移方程怎么写呢？ 暴力搜索自顶向下1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), -1)); int stoneNum = getStones(piles, 0, piles.size()-1, nums); return stoneNum &gt; (sum / 2); &#125; int getStones(vector&lt;int&gt;&amp; stones, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp;nums)&#123; if(i &lt;= j)&#123; if(nums[i][j]!=-1)&#123; return nums[i][j]; &#125; int sn1 = 0, sn2 = 0, sn = 0; // when there are even number of piles stones, it`s Alex`s turn if((j - i + 1) % 2 == 0)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) + stones[i] : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) + stones[j] : nums[i][j-1] ; &#125;else&#123; if(i &lt; j)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) : nums[i][j-1] ; &#125; &#125; sn = sn1 &gt; sn2 ? sn1 : sn2; nums[i][j] = sn; return sn; &#125;else&#123; return 0; &#125; &#125;&#125;; 时间复杂度：当剩余可以选择的石头堆数为偶数时，说明此时轮到Alex选择．当Alex选择时，他可以从最左边也可以从最右边选择一堆石头，若他选择最左边的一堆，左边界i++，否则，右边界j–． 自底向上12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), 0)); for(int i=0;i&lt;piles.size();i++)&#123; nums[i][i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=0;i &lt; nums.size() - k;i++)&#123; if(k % 2 == 0)&#123; nums[i][i+k] = max(nums[i][i+k-1] + piles[i + k], nums[i+1][i+k] + piles[i]); &#125;else&#123; nums[i][i+k] = max(nums[i][i+k-1], nums[i+1][i+k]); &#125; &#125; &#125; return nums[0][nums.size()-1] &lt;= (sum / 2); &#125; &#125;; 时间复杂度：O(n2) 空间复杂度：O(n2) 此时此题被转化成了Lee能够获得的最多的石头个数．nums[i][j]表示的是当Lee只能在第i到第j堆石头之间选择时，他能够获得最大石头数量．显然，nums[i][i]=piles[i]，也就是最后一次选择时，Lee只能选择第i堆石头．当i &lt; j时，当剩余可以选择的石头堆数为奇数时，即轮到Lee选择，此时，Lee有两种选择方法nums[i][j] = max(nums[i][j-1] + piles[j] , nums[i+1][j] + piles[i])Alex取胜的条件时，Lee能获得最多的石头数量仍然小于此时Alex能获得石头数量． 空间压缩12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;int&gt; nums(piles.size(),0); for(int i=0;i&lt;piles.size();i++)&#123; nums[i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=nums.size()-k-1; i &gt;= 0;i--)&#123; if(k % 2 == 0)&#123; nums[i] = max(nums[i] + piles[i + k], nums[i+1] + piles[i]); &#125;else&#123; nums[i] = max(nums[i], nums[i+1]); &#125; &#125; &#125; return nums[0] &lt;= (sum / 2); &#125; &#125;; 代码未能AC, 还需要考虑.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[767. Reorganize String]]></title>
    <url>%2F2019%2F07%2F17%2F767.Reorganize-String%2F</url>
    <content type="text"><![CDATA[Reorganize StringGiven a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example 1: 12Input: S = &quot;aab&quot;Output: &quot;aba&quot; Example 2: 12Input: S = &quot;aaab&quot;Output: &quot;&quot; Note: S will consist of lowercase letters and have length in range [1, 500]. 解法1根据插空法, 当数组中有n个数,且n/2个数都是同一个数.如下所示: 1234567示例1[1,1,1,2,2]1,2,1,2,1示例2[1,1,1,2,2,2]1,2,1,2,1,2 则数组中最多有(n+1)/2个是同一个数,这样可以通过插空法,隔一个位置插一个数保证每两个相邻的数不同.如示例1中如果1的个数再多出一个就无法保证每两个相邻的数不同. 因为通过首先统计数组中是否存在出现次数超过(n+1)/2的数来判断是否存在一种方案能保证任意两个相邻的数不同.然后通过重组数组来给出一种方案.重组数组的过程中,首先将数组中元素按出现次数由少到多排序,然后,将前面一般分布到奇数位置上,将后一般分布到偶数位置上来实现任意两个相邻的元素不同. c++如何对map进行排序 时间复杂度为O(m(n + logn)),其中n是S的长度,m是用于统计每个字符出现次数的map的大小.因此时间复杂度为O(n)空间复杂度为O(n+m) 解法2https://leetcode.com/articles/reorganized-string/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>求众数(出现次数超过n/2的数)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2019%2F07%2F17%2F560.-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[解法1: 遍历子数组当给定i时, sum 表示以arr[i]开始,到arr[j]结束的各个元素的累加和(j&gt;=i). 注意: 这里不需要知道是哪些子数组的和等于k,只需要统计和等于k的子数组的个数,因此这里不必记录子数组的开始和结束索引,只需要依次找出所有子数组,并统计其中和等于k的子数组的个数. 那么如何找出所有可能的子数组呢? 方法一:内存循环找出所有以数组中第i个元素开始的所有子数组,并统计其中和等于k的子数组的个数.而外层循环则依次枚举所有可能的i. 方法二: 下面给出的代码是内层循环统计以数组中第j个元素结尾的子数组的和等于k的子数组的个数, 外层循环列举所有可能的j.具体而言, 内层循环依次计算 arr[j]arr[j-1] + arr[j]arr[j-2] + arr[j-1] + arr[j]…….arr[2] + … + arr[j]arr[1] + arr[2] + … + arr[j] 也就是子数组arr[i,..,j]的和. i = j, j-1,…1若令s[i] 表示arr[1] + arr[2] + … + arr[i]那么子数组arr[i,…j]的和可以表示为s[j] - s[i-1] AC代码１ 123456789101112131415class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum = 0; for(int j=i;j&lt;nums.size();j++)&#123; sum += nums[j]; if(sum == k) ++counter; &#125; &#125; return counter; &#125;&#125;; AC代码2: 12345678910111213141516class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum = 0; for(int i=j;i&gt;=0;i--)&#123; sum += nums[i]; if(sum == k)&#123; ++counter; &#125; &#125; &#125; return counter; &#125;&#125;; 时间复杂度分析 时间复杂度: O(n2). 只用到两重循环, 容易得出时间复杂度空间复杂度:O(1) 解法2如方法二所述, 子数组arr[i, … , j]的和可以表示为s[j] - s[i-1]s[0] = arr[0]这里为了表示空数组的和为0, 不妨令s的下标从1开始.即 s[0] = 0, 表示空数组的和为0s[1] = arr[0]s[2] = arr[0] + arr[1]s[3] = arr[0] + arr[1] + arr[2] 依次类推. 那么各子数组的和可以表示为 arr[0] = s[1] - s[0]arr[0,1] = arr[0] + arr[1] = s[2] - s[0]arr[1] = s[2] - s[1]arr[1,3] = arr[1] + arr[2] + arr[3] = s[4] - s[1] 以此类推,可知 arr[i,….,j] = s[j+1] - s[i] 若要子数组arr[i,…,j]的和等于k,即s[j+1] - s[i] = k, 即s[i] = s[j+1] - k, 即当统计出arr[1,…j]时只需要统计其前面的子数组中和等于s[j+1] - k的子数组的个数就可以统计以第j个元素结尾的子数组中满足和等于k的子数组的个数. AC代码3 1234567891011121314151617181920class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; vector&lt;int&gt; temp; temp.push_back(0); for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; // 统计s[0], s[1], s[2],..,s[j]中和等于s[j+1] - k for(int i=0;i&lt;temp.size();i++)&#123; if(sum - temp[i] == k)&#123; ++counter; &#125; &#125; temp.push_back(sum); &#125; return counter; &#125;&#125;; 可以看到这里的内层使用遍历的方法来统计数组中满足条件的子数组个数.但实际上,我们并不关心哪些子数组满足条件,而只需要知道满足条件的子数组个数,也就是说,我们不必记录s[j+1]之前的每个s[i](i&lt;=j)具体由哪些元素组成, 我们只需要记住,s[i]有哪些可能的值及这些可能值出现的次数.因此,我们可以使用map来记录每个值出现的次数.而从map中取出一个key对应的值只需要常量时间,通过这种方式可以大大降低所需时间.具体代码见下面代码. 解法3: 使用mapAC代码: 使用hashmap 1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; map&lt;int, int&gt; mp; mp[0] = 1; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; counter += mp.find(sum - k) == mp.end() ? 0 : mp[sum - k]; mp[sum] = mp.find(sum) == mp.end() ? 1: mp[sum] + 1; &#125; return counter; &#125;&#125;; 1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; map&lt;int, int&gt; mp; mp[0] = 1; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; counter += mp.find(sum - k) == mp.end() ? 0 : mp[sum - k]; mp[sum] = mp.find(sum) == mp.end() ? 1: mp[sum] + 1; &#125; return counter; &#125;&#125;; mp[sum -k]统计的是arr[i]之前的s[j]是否等于 sum - k.则s[i] - s[j] = arr[j+1] + arr[j+2] + .. + arr[i] = k.这样同样需要注意需要额外设置mp[0] = 1; 表示存在空子数组的和为0.复杂度分析 时间复杂度为O(n).空间复杂度为O(n). 要统计多少个子数组的和为k,则可以分别统计以数组中每个元素结尾的子数组中有多少个子数组的和等于k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和系列</tag>
        <tag>累积和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[523. Continuous Subarray Sum]]></title>
    <url>%2F2019%2F07%2F17%2F523.Continuous-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to nk where n is also an *integer**. Example 1: 123Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. Example 2: 123Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. 相关题目: leetcode 560 解法1: 二重循环枚举所有可能的子数组组合时间复杂度分析 时间复杂度为O(n2) 解法2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2F2019%2F07%2F17%2F494.Target-Sum%2F</url>
    <content type="text"><![CDATA[You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 暴力破解123456789101112131415class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; return dfs(nums, S, 0, 0); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; return dfs(nums, S, index + 1, sum + nums[index]) + dfs(nums, S, index + 1, sum - nums[index]); &#125;&#125;; 自顶向下的记忆化搜索这里会涉及到负值,如何处理呢?加上可能的最小值的负数,进行偏移. 1234567891011121314151617181920212223class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; int sum = 0; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2010, -1)); return dfs(nums, S, 0, 0, res); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; if(res[index][sum + 1000]!=-1)&#123; return res[index][sum + 1000]; &#125; int add = dfs(nums, S, index + 1, sum + nums[index], res); int sub = dfs(nums, S, index + 1, sum - nums[index], res); res[index][sum + 1000] = add + sub; return add + sub; &#125;&#125;; 自底向上 dp[i][j]表示到第i个元素,组成的和为j的方法数.dp[i][sum + nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2F2019%2F07%2F17%2F225.-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 注意点是否需要处理异常情况。 # 两个队列，push(O(1),pop O(n)) 两个队列，push(O(n),pop O(1))一个队列，push(O(n),pop O(1))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2F2019%2F07%2F17%2F221.Maximal-Square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 解法1首先为原矩阵生成一个同样大小的新矩阵dpdp[i][j]表示以index[i][j]作为右下角的正方形的最大边长.dp[i][j] = min{dp[i][j-1], dp[i-1][j-1], dp[i-1][j-1]}.为什么一定要考虑dp[i-1][j-1]呢?下面举个例子说明例如当前dp矩阵为 12[[0,1], [1,1]] 则以位置[1,1]为右下角的最大的正方形的边长为1,因为,位置[0,0]处的边长为0, 即位置[0,0]上的元素为0.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamice programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2F2019%2F07%2F17%2F179.-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; 1234567891011121314151617181920212223242526class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return ""; &#125; vector&lt;string&gt; sarr; for(int i=0;i&lt;nums.size();i++)&#123; sarr.push_back(to_string(nums[i])); &#125; sort(sarr.begin(), sarr.end(), compare); string res = ""; for(int i=0;i&lt;sarr.size();i++)&#123; res += sarr[i]; if(i==0 &amp;&amp; sarr[i]=="0")&#123; break; &#125; &#125; return res; &#125; static int compare(string c, string d)&#123; string s1 = c + d; string s2 = d + c; return s1 &gt; s2; &#125;&#125; 总结:学到一种构造cmp函数的方法.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>谓词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2F2019%2F07%2F17%2F164%20maximum-gap%2F</url>
    <content type="text"><![CDATA[Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 解法1:基数排序12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2F2019%2F07%2F17%2F142.%20Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. 解法1双指针,快指针在前,慢指针在后.快指针一次走两步,慢指针一次走一步.如果链表无环,快指针一定先达到链表尾.否则,快指针比满指针走的快,快指针和慢指针一定会在链表上相遇. 找到快慢指针相遇的环中节点后,接下来要怎么找入环节点呢.我们知道快指针比慢指针快,如果要是能让快指针和慢指针在入环节点处相遇,那么需要快指针比慢指针多走一个环的长度的距离.当快指针和慢指针都在环上走时, 如果让慢指针先出发,当快指针赶上慢指针时,快指针正好比慢指针多走了一个环长的距离.所以,只需要让慢指针先走一个环的长度的距离,然后快指针和慢指针一起走,快指针来追赶慢指针,当慢指针赶上快指针时,正好是在入环节点上. 那么如何求环的长度呢?只需要一个指针从(快慢指针在环上相遇的节点)相遇节点出发, 再次回到该节点所需要走的步数就是环的长度. 为什么必须快指针在前,慢指针在呢?举个例子 如果链表是1-&gt;2-&gt;3.如果初始化时,慢指针在前,指向节点2, 快指针在后,指向1,那么快指针会赶上慢指针,即快慢指针会在节点3相遇,那么结束条件就不能是快指针和慢指针是否相遇.如果如上所示,即使没环,快慢指针也会在节点3处相遇.]]></content>
      <categories>
        <category>leetcode</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[71. Simplify Path]]></title>
    <url>%2F2019%2F07%2F17%2F71.Simplify-Path%2F</url>
    <content type="text"><![CDATA[题目描述Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path. Example 1: 123Input: &quot;/home/&quot;Output: &quot;/home&quot;Explanation: Note that there is no trailing slash after the last directory name. Example 2: 123Input: &quot;/../&quot;Output: &quot;/&quot;Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: 123Input: &quot;/home//foo/&quot;Output: &quot;/home/foo&quot;Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: 12Input: &quot;/a/./b/../../c/&quot;Output: &quot;/c&quot; Example 5: 12Input: &quot;/a/../../b/../c//.//&quot;Output: &quot;/c&quot; Example 6: 12Input: &quot;/a//b////c/d//././/..&quot;Output: &quot;/a/b/c&quot; # 解法1 思路：一次取出path中不等于//的部分（表示的是目录），若该部分是..，表示返回上级目录，若此时不在根目录下则有上级目录可以返回，则返回上级目录，即删除当前的目录。若该部分是.，表示当前目录，则什么也不做。否则，将新的目录加入到当前路径中（这里用vector来存储当前路径中的所有目录名）。最后将整个目录用/连接起来。另外，这里的根目录是隐含的，没有在初始化路径时加入到vector中，这是因为我们知道当前路径中的第一个目录一定是根目录。 注意：vector等的size()都是无符号数，无符号数都大于等于0，无符号数与有符号数做减法时不会产生负数，而是会变成一个很大的整数。参见：c++数据类型基础知识 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string simplifyPath(string path) &#123; if(path.empty() || path[0]!='/')&#123; return ""; &#125; vector&lt;string&gt; vec; int i=1; while(i &lt; path.size())&#123; int j=i; while(j &lt; path.size() &amp;&amp; path[j]=='/')&#123; ++j; &#125; i = j; while(j &lt; path.size() &amp;&amp; path[j]!='/')&#123; ++j; &#125; if(i &lt; j)&#123; string tmp = path.substr(i, j-i); if(tmp == "..")&#123; if(!vec.empty())&#123; vec.pop_back(); &#125; &#125;else if(tmp !=".")&#123; vec.push_back(tmp); &#125; &#125; i = j; &#125; string res = "/"; i = 0; while(vec.size() &gt; 1 &amp;&amp; i &lt; vec.size()-1)&#123; res += vec[i]; res += "/"; ++i; &#125; if(!vec.empty())&#123; res += vec[vec.size()-1]; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度为为O(n)，只从左到右扫描了整个路径字符串一遍。空间复杂度为O(n)，使用了一个vector来存储路径。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[62. Unique Paths]]></title>
    <url>%2F2019%2F07%2F17%2F62.%20Unique%20Paths%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 本题很简单,只需要在暴力搜索的基础上加上计划化搜索就行.这里不再赘述思路,详情请见代码. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m &lt;= 0 || n &lt;= 0)&#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n, -1)); return dfs(m, n, 0, 0, res); &#125; int dfs(int m, int n, int posx, int posy, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(res[posx][posy] != -1)&#123; return res[posx][posy]; &#125; if(posx == m - 1 &amp;&amp; posy == n-1)&#123; res[posx][posy] = 1; return 1; &#125; int s1, s2; if(posx +1 &lt; m)&#123; s1 = res[posx+1][posy] == -1 ? dfs(m, n, posx + 1, posy, res) : res[posx+1][posy]; &#125;else&#123; s1 = 0; &#125; if(posy + 1 &lt; n)&#123; s2 = res[posx][posy+1] == -1 ? dfs(m, n, posx, posy +1, res) : res[posx][posy+1]; &#125;else&#123; s2 = 0; &#125; res[posx][posy] = s1 + s2; return s1 + s2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F07%2F17%2F19.%20Remove%20Nth%20Node%20From%20End%20of%20List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 两趟算法一趟算法用两个指针，一个快指针先走n+2步．指向第n+2个节点．随后慢指针也从头节点出发，两个指针一起向前走．当快指针到达链表尾后节点时，慢指针指向的节点和尾后节点之间隔着n个节点，即慢指针指向倒数第n+1个节点．这时候只需要删除慢指针指向的下一个节点即可．有几种情况需要考虑： 当链表中的总节点个数少于n个．无法删除倒数第n个节点． 当链表中的总结点个数等于n个．要被删除的正好是头结点． 当链表中的总结点个数大于n个．删除倒数第n个节点． 首先让快指针先走，要么走到第n+2个节点，要么走到尾后节点．快指针先走之后，通过判断快指针共走过的节点个数来分情况处理．若快指针共走过k个节点(包括最后一个尾后空节点) 若k&lt;=n，说明链表中节点个数少于n，快指针走过的节点中包括了尾后节点(空节点) 若k==n+1，说明链表中节点个数为n，要删除的正是头结点 若k==n+2，说明链表中至少有n+1个非空节点，可以删除倒数第n个节点． AC代码 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 题目链接 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str == nullptr || pattern == nullptr)&#123; return false; &#125; return matchCore(str, pattern); &#125; bool matchCore(char *str, char* pattern)&#123; if(*str == '\0' &amp;&amp; *pattern == '\0')&#123; return true; &#125; if(str != '\0' &amp;&amp; pattern == '\0')&#123; return false; &#125; if(*(pattern+1)=='*')&#123; if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0'))&#123; return matchCore(str + 1, pattern + 2) // *匹配1个前向字符, 如a*b匹配aab || matchCore(str + 1, pattern) // *匹配多个前向字符, 如a*b匹配aaab || matchCore(str, pattern + 2);// *匹配0个前向字符， 如a*b 匹配ab &#125; return matchCore(str, pattern + 2); // *str与*pattern不等，*匹配0个前向字符 &#125; if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0')) //当前字符的下一个字符不是* return matchCore(str + 1, pattern + 1); return false; &#125;&#125;; 相似题目: Simplify Path]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包管理工具aptitude]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7aptitude%2F</url>
    <content type="text"><![CDATA[来自百度百科的介绍 aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 之所以要来说一说这个包管理工具，是因为在ubuntu中安装软件的时候经常遇到依赖未安装的问题．每次遇到这种情况，就需要包管理工具来帮忙了．]]></content>
      <tags>
        <tag>liunx系统</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是堆我们面临的第一个问题是：什么是堆？ 堆可以定义为一颗二叉树，树的节点中包含键，并且满足两个条件：１．该二叉树是完全二叉树．除了最后一层，树的每一层都是满的．２．父母优势：(以最大堆为例)父节点的键大于或等于孩子节点的键 可以用数组来实现堆． 如何构造一个堆自底向上构造堆 从最后一个非叶节点开始，检查该节点是否满足父母优势．如果不满足，就将该节点与最大孩子节点的键交换，然后再检查新的位置．这个过程持续到被检查节点满足父母优势为止(叶子节点自动满足父母优势)．此过程从最后一个非叶节点一直持续到根节点．最后一个非叶节点：假设堆中有n个节点，则最后一个非叶节点为(n/2)向下取整．例如，n=7,最后一个非叶节点为３. 调整一个堆成为最大堆将以k为根的子树调整为一个堆的过程可以简单描述如下：查看k的孩子节点中是否存在比k大的，如果不存在说明以k为根的子树已经是一个最大堆了（这里存在一个假设：在调整以k为根的子树时，以k的左右孩子节点为根的子树都已经是堆了）．否则，交换k和孩子节点中较大的那个（无论两个孩子节点是否都满足大于k），假设此新节点为n，接下来就是调整以n为根节点的子树了．显然，这就是重复上面的过程，那么这个过程应该持续到什么时候结束呢？答案是到k已经是叶子节点或者没有孩子节点都比它小了． 非递归方式 12345678910111213141516max_heapify_iter(H[1,...,n], k) // 输入：H[1,..,n]是一个数组，表示一个完全二叉树 // k：当前要调整的节点K // 输出：以节点i为根的二叉树调整为一个堆 k = i, v = H[k] // K是当前需要检查的节点 heap = false // 状态变量，表示当前要检查的节点是否满足父母优势 while not heap and 2 * k &lt;= n // 当要检查的节点不满足父母优势且不是叶子节点 j = 2 * k if j &lt; n // 被检查节点有两个孩子节点 if H[j + 1] &gt; H[j] j = j + 1 if v &gt;= H[j] heap = true else H[k] = H[j] // 交换被检查的节点和它最大孩子节点的键 k = j // 继续检查被交换后的最大孩子节点的键 递归方式 123456789101112131415max_heapify_recur(A, i) // 输入：A[1,..,n]是一个数组，表示一个完全二叉树 // i：当前要调整的节点i // 输出：以节点i为根的二叉树调整为一个堆 l = 2 * i // 节点i的左孩子2 * i r = 2 * i + 1 // 节点i的左孩子2 * i + 1 if l &lt;= n and A[l] &gt;= A[i] largest = l else largest = i if r &lt;= n and A[r] &gt;= A[largest] largest = r if largest != i exchange(A[i], A[largest]) max_heapify(A, largest) 建堆非递归方式 123456HeapBottomUp(H[1,...,n]) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组H[1,...,n] // 输出：一个堆H[1,...,n] for i = [n/2] to 1 do max_heapify_iter(H, i) 递归方式 123456build_max_heap(A) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个堆A[1,...,n] for i = n/2 to 1 do // n/2向下取整 max_heapify_recur(A, i) 堆的用处我们都知道使用堆排序算法可以实现一个优化队列．这其实又是另外一个故事了． 堆排序第一步，堆排序首先构造堆，为一个给定的数组构造一个堆．时间复杂度为O(n) 建堆时间复杂度分析： 第二步，从堆中删除最大键，持续此动作n-1次．时间复杂度为O(nlogn) 删除最大键并调整堆的时间复杂度分析： 堆排序的时间效率是O(nlogn)，但是堆排序是原址排序，不需要任何额外的存储空间．堆排序比快速排序运行得慢，但是比合并排序快． 12345678heap_sort(A) // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个排好序的数组A heap_size = n for i = n to 2 exchange(A[i], A[1]) --heap_size; max_heapify_iter(A, 1) // 调整以节点１为根，大小为heap_size的数组为最大堆]]></content>
      <tags>
        <tag>堆数据结构</tag>
        <tag>优先队列</tag>
        <tag>最小堆，最大堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9A%84%E5%BB%B6%E4%BC%B8%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[在数组中找到出现次数大于n/k的数]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8Enk%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这道题十分重要，有诸多解法，且用到许多不同的思想。 在数组中找到出现次数超过n/2的数暴力破解排序法在数组找到出现次数大于n/k的数在数组中找到出现次数大于n/3的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if(nums.empty())&#123; return res; &#125; map&lt;int, int&gt; mp; // cand for(int i=0;i&lt;nums.size();i++)&#123; if(mp.find(nums[i]) == mp.end())&#123; mp[nums[i]] = 1; &#125;else&#123; ++mp[nums[i]]; &#125; if(mp.size() == 3)&#123; allMinusOne(mp); &#125; &#125; map&lt;int,int&gt; counter; countElem(nums, mp, counter); for(auto it=mp.begin();it!=mp.end();it++)&#123; int num = it-&gt;first; if(counter[num]&gt;(nums.size()/3))&#123; res.push_back(num); &#125; &#125; return res; &#125; void allMinusOne(map&lt;int,int&gt; &amp;mp)&#123; auto it= mp.begin(); while(it!=mp.end())&#123; if(it-&gt;second==1)&#123; it = mp.erase(it); &#125;else&#123; --it-&gt;second; it++; &#125; &#125; &#125; void countElem(vector&lt;int&gt;&amp; nums, map&lt;int,int&gt;&amp; mp,map&lt;int,int&gt;&amp; counter)&#123; for(auto num:nums)&#123; if(mp.find(num)!=mp.end())&#123; if(counter.find(num)==counter.end())&#123; counter[num] = 1; &#125;else&#123; ++counter[num]; &#125; &#125; &#125; &#125;&#125;; c++中map的find方法查找一个键的时间复杂度为O(logn)]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F07%2F10%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚函数]]></title>
    <url>%2F2019%2F07%2F08%2F%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数与纯虚函数虚函数基类希望派生类进行覆盖的函数．当我们使用指针或引用调用虚函数时，该调用将被动态绑定．更具体而言，使用基类的引用或指针调用一个虚成员函数时会执行动态绑定．只有使用引用更或者指针调用虚函数时才会发生动态绑定．每一个虚函数都必须提供定义，无论是否用到． 纯虚函数纯虚函数无须定义；可以为纯虚函数提供定义，但是函数体必须定义在类的外部．含有纯虚函数的类是抽象基类，无法被实例化． 静态类型与动态类型一个变量或表达式的静态类型与该表达式表示对象的动态类型必须区分开来．表达式的静态类型和动态类型比较 静态类型 动态类型 变量声明时的类型或表达式生成的类型 变量或表达式表示的内存中的对象的类型 编译时已知 运行时才知道 指针或引用的静态类型和动态类型可能不一致；若表达式既不是引用也不是指针，则它的动态类型和静态类型一致．]]></content>
      <tags>
        <tag>虚函数</tag>
        <tag>动态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[静态内存用来保存局部静态对象,类静态数据成员以及定义在任何函数之外的变量.栈内存用来保存定义在函数内的非static对象.分配在静态或栈内存的对象由编译器自动创建和销毁. 栈对象在其定义的程序块运行时才存在;静态对象在使用之前分配,在程序结束时销毁.堆用来存储动态分配的对象, 即在程序运行时分配的对象.动态对象的生命期由程序控制.也就是说,当动态对象不再使用时,必须在代码中显式地销毁它们.c++动态内存的管理由一对运算符new和delete来完成.new在动态内存中为对象分配空间并返回一个指向该对象的指针.delete:接受一个动态对象的指针,销毁该对象,并释放该对象占用的内存. 常规指针的缺陷如果忘记了释放内存,就会导致内存泄露.如果在还有指针引用内存的情况就释放了内存会产生引用非法内存的指针. 智能指针与常规指针的区别在于, 智能指针是类类型, 在离开作用域时会自动调用析构函数, 自动释放内存. 程序使用动态内存的原因 原因 例子 程序不知道自己需要使用多少对象 容器类 程序不知道所需对象的准确类型 动态绑定 程序需要在多个对象间共享数据 strBlob类 shared_ptr: 多个指针可以指向同一个对象.使用引用计数来记录该对象的资源被多少个指针共享.当引用计数为0时, 资源自动释放. unique_ptr:同一时刻只能有一个unique_ptr指向一个给定对象.unique_ptr独占对象的资源.unique_ptr不支持普通的拷贝和赋值.可以通过release和reset将指针的所有权从一个unique_ptr转移到另一个unique_ptr. weak_ptr:不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象.将一个weak_ptr绑定到一个shared_ptr不会改变该shared_ptr的引用计数.因此, weak_ptr指向的对象可能被释放掉.]]></content>
  </entry>
  <entry>
    <title><![CDATA[未排序数组中累加和为给定值的最长子数组系列问题]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原题给定一个无序数组,其中元素可正,可负,可0.给定一个整数k,求arr所有的子数组中累加和为k的最长子数组长度. 12345678910111213141516171819int maxLength(vector&lt;int&gt; &amp;arr, int k) &#123; if (arr.empty()) &#123; return 0; &#125; map&lt;int, int&gt; mp; mp[0] = -1; int len = 0; int sum = 0; for (int i = 0; i &lt; arr.size(); i++) &#123; sum += arr[i]; if (mp.find(sum - k) != mp.end()) &#123; len = max(len, i - mp[sum - k]); &#125; if (mp.find(sum) == mp.end()) &#123; mp[sum] = i; &#125; &#125; return len;&#125; 补充题1补充题2类似题138. 子数组之和给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置 样例 样例 1: 123输入: [-3, 1, 2, -3, 4]输出: [0,2] 或 [1,3] 样例解释： 返回任意一段和为0的区间即可。 样例 2: 12输入: [-3, 1, -4, 2, -3, 4]输出: [1,5] 样例 3: 12输入: [3,4,5,6,-3,-4,-5,-6]输出: [0,7] 样例 4: 12输入: [1,0,-1]输出: [1,1] 注意事项: 至少有一个子数组的和为 0 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * @param nums: A list of integers * @return: A list of integers includes the index of the first number and the index of the last number */ vector&lt;int&gt; subarraySum(vector&lt;int&gt; &amp;nums) &#123; // write your code here if(nums.empty())&#123; return &#123;&#125;; &#125; int sum = 0; vector&lt;int&gt; res; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();++i)&#123; sum += nums[i]; if(sum == 0)&#123; res.push_back(0); res.push_back(i); return res; &#125; if(mp.find(sum)!=mp.end())&#123; res.push_back(mp[sum]+1); res.push_back(i); return res; &#125; mp[sum] = i; &#125; return res; &#125;&#125;; 此题与上题的相似之处在于:需要用到相同的结论:s[i]= arr[0] + arr[1] +…+arr[i]s[j]= arr[0] + arr[1] +…+arr[j]假设i &gt; j,则s[i] - s[j] = arr[j+1] + arr[j+2] + … + arr[i] 复杂度分析 理论上, 时间复杂度为O(n).但实际实现时,时间复杂度为O(nlogn).因为map的find方法查找一个数的时间复杂度为O(logn)空间复杂度为O(n) 题目来源: leetcode 560. Subarray Sum Equals K930 binary subarrays with sum另有使用三指针的解法,可以尝试看看试用否,三指针解法时间复杂度为O(n),空间复杂度为O(1),是最优解法]]></content>
      <tags>
        <tag>累积和</tag>
        <tag>leetcode</tag>
        <tag>程序员代码面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中数字出现的次数]]></title>
    <url>%2F2019%2F06%2F06%2F%E6%89%BE%E5%87%BA%E7%8E%B0%E4%BB%85%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[数组中只出现一次的数一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。题目来源：剑指offer 56 123456789101112131415161718192021222324252627282930313233unsigned int findFirstBitIs1(int num) &#123; int indexBit = 0; while (((num &amp; 1) == 0) &amp;&amp; (indexBit &lt; 8 * sizeof(int))) &#123; num = num &gt;&gt; 1; ++indexBit; &#125; return indexBit;&#125;bool IsBit1(int num, unsigned int indexBit) &#123; num = num &gt;&gt; indexBit; return (num &amp; 1);&#125;void findNumsAppearOnce(vector&lt;int&gt; data, int *num1, int *num2) &#123; if (data.size() &lt; 2) &#123; return; &#125; int resultExclusiveOR = 0; for (int i = 0; i &lt; data.size(); i++) &#123; resultExclusiveOR ^= data[i]; &#125; unsigned int indexOf1 = findFirstBitIs1(resultExclusiveOR); *num1 = *num2 = 0; for (int i = 0; i &lt; data.size(); i++) &#123; if (IsBit1(data[i], indexOf1)) &#123; *num1 ^= data[i]; &#125; else &#123; *num2 ^= data[i]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变形词]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8F%98%E5%BD%A2%E8%AF%8D%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[此类题比较麻烦，但其实并不难。 242. Valid Anagram49. Group Anagrams找出可以通过改变一个字母变成其他单词的单词许多单词都和另外一些单词想死。例如，通过改变第1个字母，单词wine可以变成dine，fine，line，mine，pine或vine。通过改变第3个字母可以变成wide，wife，wipe或wire以及其他一些单词。通过改变第4个字母可以变成wind，wing，wink或wins以及其他一些单词。我们想要编写一个程序来找出通过单个字母的替换变成至少15个其他单词的单词。假设有一本字典，由大约89000个各种长度的不同单词组成。大部分单词在6到11个字母之间。其中6字母单词8205个，7字母单词11989个，8字母单词13672个，9字母单词13014个，10字母单词11297个，11字母单词8617个。题目来源：数据结构与算法分析(c++语言描述，第4版) p144。]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的最大值]]></title>
    <url>%2F2019%2F06%2F06%2F%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[队列的最大值 Sliding Window Maximum Hard Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 涉及知识点：最小栈，如何用两个队列实现一个栈， 双端队列。 c++ deque基本操作123456void push_front(const T&amp; x) //双端队列头部增加一个元素Xvoid push_back(const T&amp; x) //双端队列尾部增加一个元素xvoid pop_front() //删除双端队列中最前一个元素void pop_back() //删除双端队列中最后一个元素reference front() //返回首元素的引用reference back() //返回尾元素的引用 解法1解法2]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集基础知识]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集(不相交集合)不相交集合数据结构是这样一种数据结构: 它维护了一个不相交动态集的集合 $$S = {s_1, s_2, …, s_i, …, s_k}$$对于每个集合S中的每个元素集合si而言,用集合中的而一个元素来代表该集合.假设x是集合si中的一个元素,则有以下三种操作: make_set(x): 建立一个新的集合,它的唯一成员是x.因为各个集合是不相交的集合, 所以x不会出现在别的集合中.union(x, y): 将包含x和y的两个动态集合(表示为sx和sy合并成一个新的集合, 即这两个集合的并集)find_set(x): 返回一个指针,该指针指向包含x的(唯一)集合的代表.不相交集合可以用于求无向图的连通分量等.待后续加上代码 为了提交效率,建立并查集的过程往往会采用两种策略来提高性能.一种是按秩(秩是指节点高度的一个上界)合并, 另一种是路径压缩.按秩合并是在合并两个集合的过程中, 让具有较小秩的根指向较大秩的根.路径压缩是在查找节点的根节点的过程中, 使查找路径上的每个节点指向指向根(即令根节点成为查找路径上每个节点的父节点). 节点x的秩: 节点x的高度(从节点x到某一后代叶节点的最长简单路径上边的数目)的一个上界.当make_set(x)创建一个单元素x集合时, 节点x的秩为0.使用按秩合并union(x, y)合并两个集合时, 若两个集合的秩不同,则让较大秩的根成为较小秩的根的父节点, 秩本身保持不变.若两个集合的秩相同,则任意选择两个根中的一个作为父节点, 并使它的秩加1. 并查集的实现(伪代码)123456789101112131415161718make_set(x) x.p = x // x的父节点是自己,即x是x所在集合的根节点 x.rank = 0 // x.rank即x的秩link(x, y) if(x.rank &gt; y.rank) y.p = x else x.p = y if(x.rank == y.rank) y.rank = y.rank + 1union(x, y) link(find_set(x), find_set(y))find_set(x) if x != x.p x.p = find_set(x.p) return x.p find_set的非递归形式 12345678find_set(x) a = x while x != x.p x = x.p while a != a.p z = a a = a.p z.p = x]]></content>
      <tags>
        <tag>基础算法</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序链表转成二叉搜索树系列]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[将有序数组转换成二叉搜索树 Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 1234567891011121314151617class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = sortedArrayToBSTCore(nums, 0, nums.size()-1); return root; &#125; TreeNode* sortedArrayToBSTCore(const vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; if(lo &gt; hi)&#123; return nullptr; &#125; int mid = (lo + hi) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = sortedArrayToBSTCore(nums, lo, mid - 1); root-&gt;right = sortedArrayToBSTCore(nums, mid + 1, hi); return root; &#125;&#125;; 将二叉搜索树的根节点传引用进入建立二叉搜索树的函数和返回二叉搜索树的头结点的两种方法，后者更快，但是前者更好理解。 时间复杂度为O(logn)。 将有序链表转换成二叉搜索树 Convert Sorted List to Binary Search Tree Medium Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解法1：递归二叉搜索树的性质：左子树上所有节点的值都小于等于根节点的值，右子树上所有节点的值都大于等于根节点的值。一棵二叉搜索树的左子树和右子树都是二叉搜索树。 给定有序中的中间元素形成二叉搜索树的根节点。根节点左边的节点递归地形成左子树，根节点右的节点递归地形成右子树。这保证了二叉搜索树是平衡的。 思路：首先用快慢双指针找到根节点，然后递归地形成左子树和右子树。 AC代码1 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head == mid)&#123; return root; &#125; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向尾节点 return slow; &#125;&#125;; AC代码2 12345678910111213141516171819202122232425262728293031class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head != mid)&#123; // 当mid不指向链表中的第一个元素时，即左子树上还有节点时 root-&gt;left = sortedListToBST(head); &#125; root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head == nullptr ? nullptr : head-&gt;next; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向头节点 return slow; &#125;&#125;; 两种AC代码的唯一一点小差别在与，寻找中间节点时，当链表中有两个节点时，第一种AC代码返回的是尾节点，而第二种代码返回的是头节点。 时间复杂度为O(nlongn)。假设链表中有n个元素。寻找中间元素需要线性遍历链表，slow指针需要从头节点移动到中间节点，时间复杂度为O(n)。接下来规模为n问题变成两个规模为n/2的子问题。因此，时间复杂度递推公式为:T(n) = O(n) + 2 * T(n/2)最后的时间复杂度为O(nlogn)。空间复杂度为O(logn)。 解法2：转成有序数组 先将有序链表转成有序数组，然后使用第一题的解法解决。 时间复杂度为O(n)。空间复杂度为O(n)。 解法3：中序模拟此解法基于这一事实：二叉搜索树的中序便利序列是有序的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int findSize(ListNode* head)&#123; ListNode* node = head; int c = 0; while(node!=nullptr)&#123; node = node-&gt;next; c += 1; &#125; return c; &#125; TreeNode* convertListToBST(ListNode*&amp; head, int l,int r)&#123; if(l &gt; r)&#123; return nullptr; &#125; int mid = (l + r) / 2; TreeNode* left = convertListToBST(head, l, mid - 1); TreeNode* node = new TreeNode(head-&gt;val); node-&gt;left = left; head = head-&gt;next; node-&gt;right = convertListToBST(head, mid + 1, r); return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; int size = findSize(head); return convertListToBST(head, 0, size - 1); &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(logn)。]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>binary Tree</tag>
        <tag>有序链表</tag>
        <tag>二叉搜索树</tag>
        <tag>有序数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找下一个节点]]></title>
    <url>%2F2019%2F06%2F03%2F%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链接： https://www.nowcoder.com/questionTerminal/60231d6931d543d4aadcb67851b21e4a 请设计一个算法，寻找二叉树中指定结点的下一个结点（即中序遍历的后继）。 给定树的根结点指针TreeNode* root和结点的值int p，请返回值为p的结点的后继结点的值。保证结点的值大于等于零小于等于100000且没有重复值，若不存在后继返回-1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题目链接:https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e 相关题目:寻找下一个节点]]></content>
      <tags>
        <tag>牛客网</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
</search>
