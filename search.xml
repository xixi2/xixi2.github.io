<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[智能指针]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针有三类: shared_ptr, unique_ptr, weak_ptr.其中shared_ptr可以和其他shared_ptr共享内存,指向同一块内存区域,引用计数用于记录指向该内存的shared_ptr个数. unique_ptr只能独占内存.任意时刻,都只有一个unique_ptr指向一个给定对象.当unique_ptr被销毁时, 它所指向的对象也会被销毁. weak_ptr是一种弱引用,指向shared_ptr所管理的对象. shared_ptr 初始化shared_ptr有三种初始化方式: 使用make_shared&lt;T&gt;(obj)初始化 使用同类型内置指针对shared_ptr进行初始化 使用另一个智能指针进行初始化 reset将一个新的内置指针赋予shared_ptr use_count引用计数 默认情况下,一个用来初始化智能指针的内置指针必须指向动态内存,因为智能指针默认使用delete释放它所关联的对象.我们也可以将智能指针绑定一个指向其他类型对象的指针上,但是此时必须提供自己的操作来代替delete.这个自己的操作就是删除器函数,即,我们必须定义一个自己的函数作为新的删除器函数. 1234567891011121314void f1()&#123; // 使用对象初始化智能指针 shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(12); cout &lt;&lt; *p &lt;&lt; " " &lt;&lt; p.use_count() &lt;&lt; endl; // 使用智能指针初始化智能指针 shared_ptr&lt;int&gt; p2(p); cout &lt;&lt; *p2 &lt;&lt; " " &lt;&lt; p2.use_count() &lt;&lt; endl; // 使用内置指针初始化智能指针 int *p3 = new int(193); shared_ptr&lt;int&gt; p4(p3); cout &lt;&lt; *p4 &lt;&lt; " " &lt;&lt; p4.use_count() &lt;&lt; endl;&#125; 运行结果 12312 112 2193 1 reset和use_count的使用 调用p.reset(q)时, 若是p是唯一一个指向其对象的shared_ptr,则reset会释放此对象.若传递了可选的参数内置指针q, 会令p指向q, 否则将p置空.reset会更新p的引用计数. 123456789101112131415161718void f2()&#123; shared_ptr&lt;int&gt; p4(new int(28)); cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p5(new int(109)); cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl; // 调用智能指针类的赋值运算符函数 p4 = p5; cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; // p5不是唯一一个指向其所指对象的shared_ptr,因此,重新制作一份该对象的副本并修改该对象的值 if (!p5.unique()) &#123; p5.reset(new int(*p5)); *p5 += 100; &#125; cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl;&#125; 运行结果 1234*p4: 28 p4.use_count(): 1*p5:109 p5.use_count: 1*p4: 109 p4.use_count(): 2*p5:209 p5.use_count: 1 unique_ptrweak_ptr]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>shared_ptr</tag>
        <tag>unique_ptr</tag>
        <tag>weak_ptr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parentheses系列]]></title>
    <url>%2F2019%2F08%2F12%2FParentheses%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 题目链接 解法1:暴力法依次枚举每个位置上的字符: 对于任意位置i,先将该位置上的字符设为’(‘,然后继续枚举下一个位置,直到所有位置都被枚举完成,判断形成的字符是否有效.处理完第i位上为’(‘之后,继续枚举第i位上为’)’.只需从第0位开始枚举, 将每个位置上都枚举完成,所有可能的字符串都枚举完成,也找出了所有有效的字符串.显然需要递归实现上述思路. 1234567891011121314151617181920212223242526272829bool vaild(string &amp;res) &#123; int bal = 0; for (int i = 0; i &lt; res.size(); ++i) &#123; bal += res[i] == '(' ? 1 : -1; if (bal &lt; 0) &#123; return false; &#125; &#125; return bal == 0;&#125;void generate(string &amp;res, int n) &#123; if (res.size() == n * 2) &#123; if (vaild(res)) &#123; for (auto c : res) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; &#125; else &#123; res.push_back('('); generate(res, n); res.pop_back(); res.push_back(')'); generate(res, n); res.pop_back(); &#125;&#125; 复杂度分析 时间复杂度 当给出n时, 所有可能的字符串有22 * n个. 这是因为共2 * n 个位置上,每个位置上有两种可能. 对于每一个字符串,枚举该字符串并检查该字符串的有效性的时间复杂度为O(n), 因此总的时间复杂度为O(n* 22 * n) 空间复杂度 如上所示,整个递归过程中,只用了一个string,在这个string中,最多只会存放长度为2n的字符串,因此,空间复杂度为O(n) 解法2: 改进版本在上述解法中,当已经能够被枚举的字符串无效时仍然继续枚举下一位置,因此浪费了很多时间.例如,对n=1,当位置0上的字符被设为’)’时,无论后续如何枚举,由这个’)’开始的字符串都是无效的.因此,提前退出枚举过程以减少运行时间. 12345678910111213141516171819void generate(string &amp;res, int n, int bal, vector&lt;string&gt; &amp;ans) &#123; if (res.size() == 2 * n) &#123; if (bal == 0) &#123; ans.push_back(res); &#125; &#125; else &#123; res.push_back('('); generate(res, n, bal + 1, ans); res.pop_back(); // 当我们能确定,被枚举的字符串不可能有效时,提前退出 // 换言之,只有当我们认为被枚举的字符串可能有效时,才继续枚举 if (bal &gt; 0) &#123; res.push_back(')'); generate(res, n, bal - 1, ans); res.pop_back(); &#125; &#125;&#125; 解法3: 闭合数将有效字符串表示为不相交子集的总和.考虑有效括号序列S的闭包数, 至少存在index&gt;=0, 使得S[0], S[1],…,S[2*index+1]是有效的.显然,每个括号序列都有唯一一个的闭包号. 对于每个闭合数c,起始和结束号位于索引0和2c+1.然后位于1-2\c之间的序列和位于2*c+1和2*n之间的序列都是有效序列. 123456789101112131415161718// 生成n对括号的有效序列vector&lt;string&gt; generate(int n) &#123; vector&lt;string&gt; ans; string res = ""; if (n == 0) &#123; ans.push_back(res); &#125; else &#123; for (int i = 0; i &lt; n; ++i) &#123; for (string left: generate(i)) &#123; for (string right: generate(n - 1 - i)) &#123; string tmp = '(' + left + ')' + right; ans.push_back(tmp); &#125; &#125; &#125; &#125; return ans;&#125; valid Parathesis stringGiven a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;. &#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string. An empty string is also valid. Example 1: 12Input: &quot;()&quot;Output: True Example 2: 12Input: &quot;(*)&quot;Output: True Example 3: 12Input: &quot;(*))&quot;Output: True Note: The string size will be in the range [1, 100]. 解法 1:对每个*进行枚举1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool checkValidString(string s) &#123; return checkValidStringCore(s, 0); &#125; bool checkValidStringCore(string&amp; s,int pos)&#123; if(pos == s.size())&#123; return valid(s); &#125; if(s[pos]=='*')&#123; string tmp ="()*"; for(int j=0;j&lt;tmp.size();++j)&#123; s[pos] = tmp[j]; if(checkValidStringCore(s, pos+1))&#123; return true; &#125; &#125; s[pos] = '*'; return false; &#125;else&#123; return checkValidStringCore(s, pos+1); &#125; &#125; bool valid(string s)&#123; int bal = 0; for(int i=0;i&lt;s.size();++i)&#123; if(s[i]=='(')&#123; ++bal; &#125;else if(s[i]==')')&#123; --bal; &#125; if(bal &lt; 0)&#123; return false; &#125; &#125; return bal == 0; &#125;&#125;; 解法2:动态规划 dp[i][j]表示字符串i到j位置上的子串是否有效.若i&gt;j为空串, dp[i][j]=true若i == j, dp[i][j]是否有效取决于字符串i位置上的字符是否为*, 即dp[i][j] = (s[i]==’‘)若i+1==j,则dp[i][j]会在四种情况下有效:s[i] == ‘(‘ &amp;&amp; s[j] == ‘)’s[i] == ‘(‘ &amp;&amp; s[j] == ‘\‘ s[i] == ‘*‘ &amp;&amp; s[j] == ‘)’s[i] == ‘*‘ &amp;&amp; s[j] == ‘*‘ 其余情况下为false若i+1&lt;jdp[i][j] = true只在一种情况下成立,即存在i&lt;k&lt;=j, s[i]和s[k]满足上述四种情况之一,且dp[i][k]=true &amp;&amp; dp[k+1][j]=true 12 复杂度分析 时间复杂度 空间复杂度 解法3: 贪心lo,hi分别表示尚未匹配的左括号的最少和最大数量.尚未匹配的左括号的最少数量在仅把左括号当做左括号时取得.最大数量在把所有*都当做右括号时取得. 当hi&lt;0时,说明即使把所有*都当做左括号也无法满足左括号和右括号之间的匹配关系,因此,此字符串无效. 当hi&gt;0, 而lo&lt;0时,说明将部分*当做左括号才能满足左括号和右括号之间的匹配关系. 当hi&gt;0, 而lo&gt;0时, 说明左括号的数量多于右括号的数量.尚未匹配的左括号的最少数量还是lo. 当hi=0,lo=0时,说明左括号和右括号的数量相等.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeof]]></title>
    <url>%2F2019%2F08%2F12%2Fsizeof%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[sizeof运算符返回一条表达式或一个类型所占的字节数.sizeof运算符的结果是一个size_t类型的值. sizeof运算符满足右结合律.因此,表达式sizeof p等价于sizeof(\p). 这是因为sizeof满足右结合律且与*运算符的优先级相同.所以表达式会按照从右向左的顺序组合. sizoef运算符并不实际求其运算对象的值.因此,sizeof运算可以对一个无效指针进行运算. 以下是各种内置数据类型在64位机器上所占空间大小: 12345678910111213141516171819cout &lt;&lt; "sizeof(int):" &lt;&lt; sizeof(int) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(float):" &lt;&lt; sizeof(float) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(double):" &lt;&lt; sizeof(double) &lt;&lt; endl;// 8cout &lt;&lt; "sizeof(char):" &lt;&lt; sizeof(char) &lt;&lt; endl; // 1int *p = 0;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl;p = new int&#123;12&#125;;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl; sizeof运算符与数组 对数组执行sizeof运算得到整个数组所占空间的大小.sizeof运算不会把数组名转成指针来处理 可以利用sizeof运算符来求数组中元素个数. 12345int arr[] = &#123;1, 2, 3&#125;;cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 12(4x3)int n = sizeof(arr) / sizeof(*arr);cout &lt;&lt; "n=" &lt;&lt; n &lt;&lt; endl; // 3,数组中元素个数 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小,不会计算对象中的元素占用了多少空间 1234vector&lt;int&gt; arr&#123;1, 3, 7, 3&#125;;vector&lt;int&gt; brr(100, 0);cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 24cout &lt;&lt; "sizeof(brr):" &lt;&lt; sizeof(brr) &lt;&lt; endl; // 24]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传参]]></title>
    <url>%2F2019%2F08%2F12%2F%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串基础知识总结]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[有三种类型的字符串： c风格字符串， 字符串字面常量，string类型 c风格字符串 c风格字符串必须符合某种编码(如ASCII),并且除了字符串的末尾之外,字符串里面不能包含空字符(空字符是字符结束的标志).这些限制使得c风格字符串只能保存文本数据,而不能保存二进制数据(如图片,音频等) c风格字符串不保存自身长度,要获取一个c字符串的长度,需要遍历整个字符串,直到遇到代表字符串结尾的空字符为止,这个操作的时间复杂度为O(n)(n是字符串长度). c字符串容易造成缓冲区溢出 如使用strcat函数将src字符串中的内容拼接到字符串的末尾时, 1char *strcat(char* dest, const char* src) 由于c字符串不记录自身的长度,所以strcat假定用户在执行这个函数时,已经为dest分配了足够多的内存,可以容纳src字符串中的所有内容,但是万一这个假设不成立就会造成缓冲区溢出. c字符串修改字符串长度时需要进行内存重分配;内存重分配涉及复杂的算法,而且可能需要执行系统调用,通常来说比较耗时. 字符串,字符数组相关API c标准库string函数, 共有4个函数 strlen(p), strcmp(p1, p2), strcat(p1, p2), strcpy(p1, p2) 传入此类函数的指针必须指向以空字符结尾的数组不能使用strlen函数求”使用列表初始化的字符数组的长度 strlen计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 123456789101112void testCharArray3() &#123; cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // 允许使用以空字符结尾的字符数组类初始化string对象或为string对象赋值 string s("danam"); cout &lt;&lt; "s:" &lt;&lt; s &lt;&lt; " s.size():" &lt;&lt; s.size() &lt;&lt; endl; char c[] = "nice"; cout &lt;&lt; "strlen(c): " &lt;&lt; strlen(c) &lt;&lt; " c:" &lt;&lt; c &lt;&lt; endl; string s1(c); cout &lt;&lt; "s1.size():" &lt;&lt; s1.size() &lt;&lt; " s1:" &lt;&lt; s1 &lt;&lt; endl;&#125; 运行结果 1234strlen("danam"): 5s:danam s.size():5strlen(c): 4 c:nices1.size():4 s1:nice]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组和字符指针]]></title>
    <url>%2F2019%2F08%2F12%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[数组基本概念什么是数组?数组是一组类型相同元素的容器.数组中存放的对象没有名字,必须通过位置来访问.数组的大小确定不变, 一旦数组定义完成,不能再向数组中添加元素. 数组是一种复合类型.数组的声明形如a[d], 其中a是数组的名字,d是数组的维度.维度说明了数组中元素的个数,因此必须大于0. 数组中元素的个数也属于数组类型的一部分,编译时数组的维度必须是已知的. 适用所有数组类型 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。当对数组名称使用decltype关键字时得到的是数组对象类型。 对数组执行下标运算其实是对指向数组元素的指针执行下标运算 内置的下标运算符不是无符号数,标准库类型如vector和string限定使用的下标必须是无符号数 因为数组本身是对象,可以定义数组的指针和数组的引用 适用于字符数组 当使用字符串常量对字符数组进行初始化时, 字符串数组最后一位会被加上一个’\0’空字符但是使用strlen()计算该数组的长度时,该字符串末尾的空字符不计算在内 对字符数组进行列表初始化时,字符数组末尾没有空字符; 但是由于strlen()函数时是使用空字符来判断字符串结束的, 无法对这样的字符数组使用strlen()求长度 代码示例 字符数组初始化和求长度 字符数组初始化有两种方式,列表初始化和字符串常量初始化 字符串常量初始化时,字符串常量末尾的空字符也会拷贝到字符数组中去 12345678910111213141516void testCharArray() &#123; char a1[] = "danam"; // 计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // a1的长度为6字节,字符串字面值的末尾是一个空字符,这个空字符也会像其他字符一样拷贝到字符数组中去 cout &lt;&lt; "a1:" &lt;&lt; a1 &lt;&lt; " sizeof(a1): " &lt;&lt; sizeof(a1) &lt;&lt; " strlen(a1): " &lt;&lt; strlen(a1) &lt;&lt; endl; //a1:danam sizeof(a1): 6 strlen(a1): 5 // 对字符数组进行列表初始化,没有空字符 char a2[] = &#123;'a', 'b', 'c'&#125;; cout &lt;&lt; "a2: " &lt;&lt; a2 &lt;&lt; " sizeof(a2): " &lt;&lt; sizeof(a2) &lt;&lt; endl; // a2的长度为3字节;无法对a2使用strlen函数 // a2: abcdanam sizeof(a2): 3&#125; 运行结果 123strlen("danam"): 5a1:danam sizeof(a1): 6 strlen(a1): 5a2: abcdanam sizeof(a2): 3 数组名和指针,迭代器 数组名通常会自动转换为指向数组首元素的指针 在表达式decltype(arr)时,不会发生自动转换,decltype(arr)的返回类型是一个数组类型,其元素类型和维度都与数组arr相同 1234567891011void testCharArray1() &#123; //===============数组名和指针================= int iarr[] = &#123;1, 2, 3, 4, 5&#125;; // ia是一个指针,在这里使用数组类型对象iarr时,编译器将其替换为一个指向数组首元素的指针 auto ia(iarr); ia = &amp;iarr[1]; // decltype(ia)是一个含有5个整形元素的数组对象,因此iarr2也是一个含有5个元素的数组 decltype(iarr) iarr2 = &#123;22, 33, 444, 55, 99&#125;; iarr2[2] = 1882;&#125; 运行结果 1nice to meet you alice 指针运算 对数组执行下标运算其实是对指向数组元素的指针执行下标运算.标准库类型使用的下标类型必须是无符号类型,内置的下标运算可以是带符号类型 可以从一个指针加上或减去一个整数值,结果仍是指针 指向同一个数组中元素(包括尾元素)的指针可以相减,两个指针相减的结果是一种名为ptrdiff_t的标准库类型.ptrdiff_t类型是一种带符号类型 123456789101112131415161718192021void testCharArray3() &#123; //=======================指针运算===================== string sarr[5] = &#123;"good", "day", "you", "know", "me"&#125;; // sarr[2]是一个使用了数组名字的表达式,对数组执行下标运算其实是对指向数组元素的指针执行下标运算 string s1 = sarr[2]; //sarr转换为指向数组首元素的指针,sarr[2]得到(sarr+2)所指向的元素 string *p = sarr; //sarr转换为指向数组首元素的指针 string s2 = *(p + 2); //等价于sarr[2] cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; s2 = p[3]; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; //=======只要指针指向的是数组中的元素(或者数组中尾元素的下一位置),都可以执行下标运算 //内置的下标运算符使用的不是无符号数,而标准库类型如vector和string限定使用的下标必须是无符号类型 string *p1 = &amp;sarr[2]; string s3 = p1[2]; string s4 = p1[-2]; cout &lt;&lt; "s3: " &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; "s4: " &lt;&lt; s4 &lt;&lt; endl;&#125; 运行结果 12345s1: yous2: yous2: knows3: mes4: good 指针和迭代器 1234567891011121314151617181920void testCharArray2() &#123; //================指针也是迭代器======================== string sarr[5] = &#123;"nice", "to", "meet", "you", "alice"&#125;; //指针e指向sarr尾元素的下一位置的指针,该位置并不存在,因此不能对该指针进行解引用和递增操作 string *e = &amp;sarr[5]; for (string *b = sarr; b != e; b++) &#123; cout &lt;&lt; *b &lt;&lt; " "; &#125; cout &lt;&lt; endl; //=====================标准库begin和end函数====================== int ia1[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *beg = begin(ia1); // 指向ia1首元素的指针 int *last = end(ia1); // 指向ia1尾元素的下一位置的指针 while (beg != last) &#123; cout &lt;&lt; *beg &lt;&lt; " "; ++beg; &#125; cout &lt;&lt; endl;&#125; 运行结果: 10 1 2 3 4 5 6 7 8 9]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载和重写]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%2F</url>
    <content type="text"></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列1]]></title>
    <url>%2F2019%2F08%2F07%2Fc%2B%2B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E4%BA%8C)%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[显式转换旧式转型:T(expression)(T)expression 四种新式转型: cast-name&lt;type&gt;(expression): type是转换的目标类型，expression是要转换的值。若type是引用类型，则结果是左值。cast-name是static_cast，dynamic_cast，const_cast和reinterpret_cast中的一种。 const_cast通常被用来将对象的常量性移除. dynamic_cast主要用来执行“安全向下转型”,也就是用来决定某对象是否归属继承体系中的某个类型.它是唯一无法由旧式语法执行的动作,也是唯一可能耗费重大运行成本的转型动作. reinterpret_cast意图执行低级转型,实际动作(及结果)可能取决于编译器,这也就表示它不可移植.例如将一个pointer to int转型为一个int. 这一类型在低级代码以外很少见. static_cast用来强迫隐式转换.例如将non-const对象转为const对象, 或将int转为double等等.它也可以用来执行上述多种转换的反向转换.例如将void*指针转为typed指针,将point-to-base转为pointer-to-derived.但它无法将const转为non-const,这个只有const_cast才办得到.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>显示转换</tag>
        <tag>cast</tag>
        <tag>static_cast</tag>
        <tag>const_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载new和delete]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete%2F</url>
    <content type="text"><![CDATA[当应用程序对于内存分配有特殊要求时,需要重载operator new和operator delete运算符. new表达式的工作机制 new表达式的工作机理 当我们使用一条new表达式时,实际执行了三步操作. 第一步,调用名为operator new(或operator new[])的标准库函数, 分配一块足够大的, 原始的, 未命名的内存空间以便存储特定类型的对象(或对象数组). 运行相应的构造函数构造这些对象,并初始化这些对象 对象被分配了空间并构造完成,返回一个指向该对象的指针. delete表达式的工作机理 当我们使用一条delete表达式时,实际执行了两步操作. 对delete表达式中指针所指向的对象执行相应的析构函数 调用名为operator delete(或operator delete[])的标准库函数释放对象内存空间 定位new表达式可以通过自定义operator new和operator delete函数来控制内存分配过程. 但是有一个operator new函数不允许被用户重载: 1void *operator new(size_T, void*) 此形式的operator new(定位new)只供标准库使用,不允许用户重载.该函数并不分配内存,而是直接返回void参数传入的指针;然后由new表达式负责在指定的地址初始化对象以完成整个工作.即*定位new允许我们在一个特定的,预先分配的内存地址上构造对象**.传给定位new表达式的指针可以是堆内存,也可以不是. 使用定位new表达式定位new表达式的形式: new (place_address) type [n] {initializer list}其中,place-address是一个指针,指向已经分配好的内存地址, type表示要构造的对象的类型, n可选参数,表示要构造的对象的个数, {initializer list}为初始化列表用于初始化对象. 指针place_address指向的是堆内存 1234567891011void f1()&#123; double *p3, *p4; p3 = new double[N]; // 堆内存,p3指向动态分配的空间 p4 = new(p3) double[N]&#123;1.1, 2.2, 3.0, 4.6, 6.9&#125;; // 定位new允许我们在一个特定的,预先分配的内存地址上构造对象 for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p4[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 11.1 2.2 3 4.6 6.9 指针place_address指向的是静态内存 1234567891011121314151617const int BUF = 512;const int N = 5;char buffer[BUF];void f2()&#123; int *p; p = new(buffer) int[N]; // buffer是静态内存, 定义在任何函数之外的变量 for (int i = 0; i &lt; N; ++i) &#123; p[i] = i * 4; &#125; cout &lt;&lt; "静态分配的地址buffer:" &lt;&lt; (void *) buffer &lt;&lt; endl; cout &lt;&lt; "直接使用placement new的p2地址" &lt;&lt; p &lt;&lt; endl; for (int i = 0; i &lt; N; ++i) &#123; cout&lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 123静态分配的地址buffer: 0x556ab55fd140直接使用placement_new的p2地址: 0x556ab55fd1400 4 8 12 16 指针place_address指向的是栈内存 123456789void f3()&#123; string arr[N]; // 栈内存, arr中保存着定义在函数内的非static对象 string *p; p = new(arr) string[N]&#123;"hello", "world", "a", "good", "day"&#125;; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 1hello world a good day]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>operator new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置指针]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%86%85%E7%BD%AE%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针?指针是一种特殊的变量.它的值是一个对象的地址,也称指针指向该对象.对指针进行解引用可以获取该对象.指针本身是一个对象,可以赋值和拷贝. 指针中保存着它指向的对象的地址.直接输出指针的内容即指针指向的对象的地址.对指针进行解引用得到指针指向的对象 二级指针中保存一个指针的地址, 这个被指向的指针中才真正保存着对象的地址.直接输出指针得到指针指向的一级指针的地址.对二级指针进行解引用得到一级指针指向的最终对象的地址(即一级指针的值).对一级指针进行解引用,得到最终对象 关于指针有一些很容易混淆的地方,下面举几个例子辨析一下. 示例1 1234567int a = 10;int *p = &amp;a;int **pp = &amp;p; // pp是指向指针的指针，它指向指针p。解引用后是指针p。cout&lt;&lt;"pp:"&lt;&lt;(pp)&lt;&lt;" &amp;p"&lt;&lt;(&amp;p)&lt;&lt;endl; // pp是指向指针变量p的指针，所以，pp中存放着整形指针变量p的地址cout&lt;&lt;"*pp:"&lt;&lt;(*pp)&lt;&lt;" p"&lt;&lt;(p)&lt;&lt;endl; // pp是指向指针变量p的指针，*pp解引用pp会得到整形指针变量p，而p的值是一个整形变量a的地址cout&lt;&lt;"p:"&lt;&lt;p&lt;&lt;" &amp;a:"&lt;&lt;(&amp;a)&lt;&lt;endl; // p是指向整形变量a的指针，所以，p中存放着整形变量a的地址cout&lt;&lt;"*p:"&lt;&lt;p&lt;&lt;" a:"&lt;&lt;(a)&lt;&lt;endl; // p是指向整形变量a的指针。*p解引用整形指针p会得到一个整形数 运行结果 1234pp:0x7fff5ce9bf48 &amp;p0x7fff5ce9bf48*pp:0x7fff5ce9bf44 p0x7fff5ce9bf44p:0x7fff5ce9bf44 &amp;a:0x7fff5ce9bf44*p:0x7fff5ce9bf44 a:10 示例2 123456789101112131415161718192021int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p, **k; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *p:" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(p++):" &lt;&lt; *(p++) &lt;&lt; " "; cout &lt;&lt; "after p++" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(++p):" &lt;&lt; *(++p) &lt;&lt; " "; cout &lt;&lt; "after ++p" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; 运行结果 1234567891011a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *p:1k:0x7ffcd38cc920 *k:0x7ffcd38cc930 **k:1=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(p++):1 after p++0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(++p):2 after ++p0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2 可知, a是数组的名字,也是指向数组首元素的指针.p=a将指针p指向数组首元素.因此p的值是数组首元素的地址. p是数组首元素的值.\*k表明k是指向指向指针的指针, k指向指针p,因此,k中保存这指针p的地址,*k是指针p的值,也就是指针指向的对象地址,这里就是数组a首元素的地址.**k就是*(p)就是指针p指向的对象的值.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板实参推断和引用]]></title>
    <url>%2F2019%2F08%2F04%2F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[从左值引用函数参数推断类型从右值引用函数参数推断类型]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>函数参数</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[856. Score of Parentheses]]></title>
    <url>%2F2019%2F07%2F31%2F856.Score-of-Parentheses%2F</url>
    <content type="text"><![CDATA[Given a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: 12Input: &quot;()&quot;Output: 1 Example 2: 12Input: &quot;(())&quot;Output: 2 Example 3: 12Input: &quot;()()&quot;Output: 2 Example 4: 12Input: &quot;(()(()))&quot;Output: 6 Note: S is a balanced parentheses string, containing only ( and ). 2 &lt;= S.length &lt;= 50 解法1:分而治之首先把整个字符串S分成多个子串s1, s2, …,sn.score(S) = score(s1)+score(s1)+…+score(sn) 接下来,计算每个子串si&gt;的分数,子串si有两种可能: 长度为2: score(si)=1 长度大于2:score(si) = 2 * score(si[1:n-1])(假设n为si.size()) 栈count cores]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>括号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纸牌博弈问题系列]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%BA%B8%E7%89%8C%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[几道同类题目: stone game 此题首先需要定义递归函数,写出最简朴的做法 如何确定循环变量i和j的遍历方向 是否可以进行空间压缩,如何可以,如何压缩 Predict the Winner 题号486 此题与上题几乎一模一样,但是需要注意,当player1与player2相等时的边界情况.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++数据类型基础]]></title>
    <url>%2F2019%2F07%2F31%2Fc%2B%2B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文主要是总结一下C++语言常用的数据类型基础知识，如类型转换，整形的最大最小数值等。 无符号数示例1 1234unsigned int u = 0xFFFFFFFF;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //4294967295u -= 31;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl;//4294967264 无符号数0xFFFFFFFF是32位无符号数中的最大值。 示例2：无符号数和有符号数运算 12345unsigned int u = 10;int i = -42;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; // 10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967296 + (-42)cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl; // 4294967264 无符号数u和有符号数i相加前，把有符号数i转换为无符号数，结果等于两个无符号数相加。 示例3： 12345unsigned int u = 10;int i = -1;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967295cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl;//(4294967295 + 10) % (4294967296)，其中4294967296是2的32次方 两个无符号数相加结果超出它表示范围时，先对这个超出表示范围的结果进行取模(对2的n次方进行取模)，则得到了真正的结果。 示例4：无符号数都是整数。若给无符号赋值一个负数，则将该负数+2n得到最后的结果。 123456unsigned int x = 0xFFFFFFFF;unsigned int u = 10;unsigned int v = 42;cout&lt;&lt;"x:"&lt;&lt;x&lt;&lt;endl;cout&lt;&lt;"(v - u):"&lt;&lt;(v - u)&lt;&lt;endl; // 32cout&lt;&lt;"(u - v):"&lt;&lt;(u - v)&lt;&lt;endl; // 4294967264: (-32 + 4294967296) % 4294967296的结果 示例5：当表达式中既有带符号数又有无符号数时，当带符号数值为负数时会出现异常情况，这是因为带符号数会自动转换成无符号数。 123unsigned int x = 1;int y = -1;cout&lt;&lt;"x * y="&lt;&lt;(x * y)&lt;&lt;endl; //4294967295，y转换为无符号数(-1 + 4294967296) = 4294967295 16进制数0xffffffff0xffffffff是一个十六进制数。把它转换成2进制为：1111111..11(32个1)把它转成10进制无符号数是：0xffffffff = 16x10^7+ 16x10^6+….+16x10^1+16x10^0 = 4294967295把它转成10进制带符号整数为：111111111111111(32个1表示的补码形式)转化为源码形式为10…00001(中间30个0)，即-1。 1234unsigned int a = 0xffffffff;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // 4294967295int b = 0xffffffff; cout&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl; // b = -1 异或运算异或运算满足交换律与结合律。C = A ^ B (^是异或运算符)，则 A = B ^ C, B = A ^ C 例1. A = 1011, B = 0101 , C= 1110若A和B在某一位上都是1， 则C在该位上为0，则A或B的该位与C的该位相与就是1；若A和B在某一位上都是0， 则C在该位上为0，则A或B的该位与C的该位相与就是0。若A在某一位为1， B在该位为0， 则C在该位上为1，则A的该位与C的该位相与就是0，B的该位与C的该位相与就是1。同理，A在该位为0，B在该位为1时可证成立。 按位取反~1234567int a = -2147483648;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // -2147483648cout&lt;&lt;" ~a="&lt;&lt;~a&lt;&lt;endl; // 2147483647bitset&lt;32&gt; b1(a); bitset&lt;32&gt; b2(~a); cout&lt;&lt;"a: "&lt;&lt;b1.to_string()&lt;&lt;endl;// 10..00cout&lt;&lt;" ~a: "&lt;&lt;b2.to_string()&lt;&lt;endl;// 011..11 补码、原码、求补运算负数的补码由其原码对除符号位外各位取反末位加1，同样，由补码求原码也是对补码除符号位外，各位取反末位加1。求补运算：不考虑符号位，对原码各位取反，并在末位加1。对一个数进行求补运算得到的是其相反数的补码。如对0111进行求补运算，0111的真值为7。其补数为1001（补码），补码1001对应的源码为1111，真值为-7。 n &amp;(~n+1)这个表达式常用来取n中最右侧的1。这是因为, ~n是对进行按位取反。例如：n = 1000，n=0111, ~n+1 = 1000, n &amp; (n+1)=1000，只有n中最右边为1的位置为1。n = 1010， n=0101，n+1=0110, n &amp; (~n+1)=0010。]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>无符号数</tag>
        <tag>补码</tag>
        <tag>原码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列2]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[对于类类型的类型转换,通过定义类型转换运算符完成.转换构造函数和类型转换运算符共同定义了类类型转换.类型转换运算符没有显式的返回类型,也没有星灿,而且必须定义成类的成员函数.类型转换运算符一般不改变待转换对象的内容.因此,类型转换运算符一般是const的. 123456789101112131415161718192021222324252627282930/** * SmallInt既定义了向类类型的转换,也定义了从类类型向其他类型的转换 * 构造函数将算类型的值转换成SmallInt类型对象,类型转换运算符将SmallInt对象转换成int */class SmallInt &#123;public: SmallInt(int i = 0) : val(i) &#123; if (i &lt; 0 || i &gt; 255) &#123; throw std::out_of_range("Bad SmallInt value"); &#125; &#125; // 类型转换运算符:把类类型SmallInt转成int类型 operator int() const &#123; return val; &#125;private: std::size_t val;&#125;;int main()&#123; SmallInt s = 4; // s是一个SmallInt类型对象,val=4 cout &lt;&lt; s + 4 &lt;&lt; endl; // 8 SmallInt si = 3.14; // si是一个SmallInt类型对象,val=3 cout &lt;&lt; si + 3.14 &lt;&lt; endl; // 6 return 0;&#125; SmallInt s = 4首先将4隐式地转换为SmallInt,然后调用SmallInt::operator=(拷贝赋值运算符). s + 4首先将s隐式地转换成int,然后执行整数的加法 si = 3.14, 首先内置类型转换将double实参转换成int,然后再调用SmallInt(int)构造函数 在表达式si + 3.14中, 首先SmallInt类型转换运算符将si转换成3,然后内置类型转换将所得int继续转换为double. 编译器一次只能执行一个用户定义的类型转换,但是隐式的用户定义类型转换可以置于一个标准类型转换之前或之后]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>类类型隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列1]]></title>
    <url>%2F2019%2F07%2F31%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[显式转换cast-name&lt;type&gt;(expression): type是转换的目标类型，expression是要转换的值。若type是引用类型，则结果是左值。cast-name是static_cast，dynamic_cast，const_cast和reinterpret_cast中的一种。]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>类型转换</tag>
        <tag>显示转换</tag>
        <tag>cast</tag>
        <tag>static_cast</tag>
        <tag>const_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 易混淆概念之常量指针]]></title>
    <url>%2F2019%2F07%2F31%2Fc%2B%2B-%E6%98%93%E6%B7%B7%E6%B7%86%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指向常量的指针常量是这样一种变量:它的值不能被改变,因此,常量必须初始化. 指向常量的指针,可以指向常量或者非常量.但是要想用指针来存放常量对象的地址,只能用指向常量的指针.指向常量的指针仅仅要求不能通过该指针改变对象的值,而没有规定该对象的值不能通过其他方式改变.可以这样想: 指向常量的指针, 自以为是地以为自己指向了常量,所以自觉地不去改变该对象的值.同样,可以认为指向非常量的指针,会认为自己指向的是非常量,因此,可能会改变自己指向的变量,因此不能用指向非常量的指针保存常量对象的地址.因为,指向非常量的指针可能会试图改变其指向的常量对象的值. 非常量可以转化为常量.反之则不行. 123456const double pi = 3.14;const double *pip = &amp;pi; // 正确:指向常量的指针const double pi1 = 3.1415;pip = &amp;pi; // 使指向常量的指针pip指向另一个常量double pi2 = 3.1415926;pip = &amp;pi2; // 指向常量的指针pip指向一个非常量 常量指针常量指针是指指针本身是常量,即指针一旦指向某个对象就不能再改变(指针中保存的那个地址就不再改变了).因此同常量一样,常量指针必须初始化. 指针本身是常量只规定了指针不能指向其他对象,而并没有规定不能通过指针修改其所指向对象的值,能否只有做完全取决于所指对象的类型.常量指针既可以指向常量也可以指向非常量,具体指向的是常量还是非常量,取决于定义该指针时所指向对象的基本数据类型. 12345int errNumb = 0;int *const curErr = &amp;errNumb; // 指向非常量的常量指针 curErr常量指针,始终指向errNumb*curErr = 1; // 通过指向非常量的常量指针修改其所指向对象的值const double pi = 3.14;const double *const pip = &amp;pi; // 指向常量的常量指针pip 常量指针this类的成员函数调用时,用请求该函数的对象地址初始化this.在整个调用过程中,this所指向的都是发起该调用的对象.默认情况下,this的类型是指向非常量版本的常量指针.如类类型的名为sales_data, 则this指针的类型是sales_data *const. 又如果想要用指针来保存常量对象的地址,只能使用指向常量的指针, 所以,我们不能把类型为sales_data const的this指向一个常量对象.也因此,不能在一个常量对象上调用普通的成员函数.如果想要常量对象也能调用该成员函数,那么必须要把this指针的类型设置成指向常量的常量指针,即*const sales_data const*声明成员函数时,紧随参数列表的const的作用就是将this指针的类型声明成指向常量的常量指针.像这样使用construction的成员函数被称作常量成员函数,常量成员函数内部不能改变this指针所指向的对象的内容(即调用此成员函数的对象的内容). 1234class sales_data&#123; void f(); // 常量对象不能调用此函数 void f() const; // 此函数是常量成员函数,常量对象也可以调用,this指针指向的是常量对象(也可以是非常量对象)&#125;]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数指针]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[函数指针指向的是函数而非对象.和其他指针一样,函数指针指向某种特定类型.函数的类型由它的返回类型和形参类型共同决定,与函数名无关. 123456789101112131415161718bool lengthCompare(const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size();&#125;bool (*pf)(const string &amp;a, const string &amp;b); // pf是一个未初始化的函数指针bool (*pf1)(const string &amp;a, const string &amp;b); // pf是一个未初始化的函数指针int main()&#123; // 以下两种写法都是等价的 pf = lengthCompare; pf1 = &amp;lengthCompare; // 以下是三个等价的调用 bool fa = pf("hello", "goodbye"); bool fb = pf1("hello", "goodbye"); bool fc = lengthCompare("hello", "goodbye"); return 0; &#125; 当把函数名作为一个值使用时,该函数自动转换为指针,所以, pf = lengthCompare和 pf1 = &amp;lengthCompare是等价的. 函数指针作为实参不能定义函数类型的形参,但是&lt;形参可以使指向函数的指针 12345// 第三个形参是函数类型,它会自动转换为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// 显式地将形参定义为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 定义函数类型别名和函数指针类型别名decltype返回函数类型,不会将函数类型自动转换为指针类型 12345678// Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2; // 等价的类型// FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; useBigger的另外两种等价的声明(使用了类型别名) 12void useBigger(const string &amp;s1, const string &amp;s2,Func);void useBigger(const string &amp;s1, const string &amp;s2,FuncP2); 返回函数指针12using F = int(int*, int); // F是函数类型,不是指针using PF = int(*)(int*,int); // PF是指针类型 使用类型别名定义返回类型为函数指针的函数 1234567PF f1(int); // PF是指向函数的指针,f1返回指向函数的指针F f1(int); // F是函数类型,f1不能返回一个函数类型F* f1(int); // F*是函数类型int (*f1(int))(int *,int); // 直接声明f1// 尾置返回类型auto f1(int) -&gt; int(*)(int *,int); 首先f1有形参列表,所以,f1是个函数,f1的返回值是一个指针.该指针也有形参列表,所以,该指针指向函数.该函数的形参是int和int,返回int.所以,f1是一个返回一个函数int(\)(int *,int)的函数. 一个复杂点的例子 12345678910111213141516171819202122232425262728293031string::size_type sumLength(const string &amp;a, const string &amp;b) &#123; return a.size() + b.size();&#125;string::size_type largerLength(const string &amp;a, const string &amp;b) &#123; return a.size() &gt; b.size() ? a.size() : b.size();&#125;decltype(sumLength) *getFcn(const string &amp;s) &#123; if (s == "+") &#123; return sumLength; &#125; else &#123; return largerLength; &#125;&#125;int main()&#123; typedef string::size_type (*Func)(const string &amp;, const string &amp;); Func fcn = getFcn("+"); // fcn是一个函数指针 // 一种等价形式// auto fcn = getFcn("+"); string::size_type sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; fcn = getFcn("-"); sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; return 0;&#125; 由于函数的类型由它的返回类型和形参类型决定,而与函数名无关,可知sumLength和largerLength属于相同的类型.所以,我们可以向getFcn传入参数,获取指向同一种函数类型的不同的函数指针.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[void*指针]]></title>
    <url>%2F2019%2F07%2F31%2Fvoid*%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[void*是一种特殊的指针类型,可以用于存放任意类型的对象地址.但是我们不知道该指针着存放的地址指向的对象的类型. 1234int d = 102;void *p = &amp;d;int *pa = static_cast&lt;int *&gt;(p);cout &lt;&lt; *pa &lt;&lt; endl; // 102 将指针p强制为int*类型,强制转换过程中应该确保指针的值即指针指向的对象地址不变; 因此我们进行强制转换时,必须确保转换的目标类型就是指针所指的类型,否则,将产生未定义的结果. 那么什么时候使用void*指针呢?未完待续]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>static_cast</tag>
        <tag>void*指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可调用对象]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[可调用对象有函数,函数指针,lambda表达式,函数对象, bind创建的对象等.函数和函数指针不必多说.那么什么是函数对象呢?函数对象是一种重载了调用运算符的类类型.因为重载了调用运算符,所以我们可以像调用函数一样调用类的对象,因为称为函数对象.lambda表达式表示一个可调用的代码单元. 函数对象12345678910111213141516/** * absInt类只定义了一种操作:函数调用运算符 * 此类为函数对象 */struct absInt &#123; int operator()(int val) const &#123; return val &lt; 0 ? -val : val; &#125;&#125;;int main()&#123; absInt absObj; cout &lt;&lt; absObj(42) &lt;&lt; endl; // 42 cout &lt;&lt; absObj(-10) &lt;&lt; endl; // 10 return 0;&#125; 以上代码即定义了一个函数对象.调用该对象就像调用函数一样.仿佛该类型对象是一个函数.还可以定义有数据成员的函数对象 123456789101112131415161718class PrintString &#123;public: PrintString(ostream &amp;o = cout, char c = ' ') : os(o), sep(c) &#123;&#125; void operator()(const string &amp;s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: ostream &amp;os; char sep;&#125;;int main()&#123; PrintString printer; printer("hello"); // 输出hello PrintString errors(cerr, '\n'); string s = "wrong answer"; errors(s); // 输出wrong answer return 0;&#125; lambda表达式lambda表达式在很多语言中都有.lambda可以理解为一个未命名的内联函数,但是与普通函数不同的是,lambda可能定义在函数内部;lambda表达式必须尾置返回; lambda表达式不能有默认参数; lambda表达式的参数列表和返回类型可以省略. 那么在c++中该怎么定义一个lambda表达式呢?一个lambda表达式具有以下形式: 1[capure list](parameter list)-&gt; return type &#123;function body&#125; 其中,捕获列表(capure list)是该lambda表达式所在函数中定义的局部变量(通常为空).参数列表(parameter list), 返回类型, 返回类型(return type)和函数体(function body)与普通函数相同. 当定义一个lambda时,编译器生成一个与lambda对象的新的(未命名的)类类型.当向一个函数传递一个lambda时,同时定义了一个新类型和该类型的一个对象. 123456vector&lt;string&gt; vc&#123;"good", "to", "see", "you", "again"&#125;;for_each(vc.begin(), vc.end(), PrintString(cout, '\n')); // 函数对象// 等价的lambda表达式string sep("\n");for_each(vc.begin(), vc.end(), [sep](const string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; sep; &#125;); 使用函数对象打印出可变数组vc中的元素.同时定义了一个与函数对象PrintString等价的lambda表达式. 捕获变量与参数传递类似,捕获变量也有两种方式,值捕获和引用捕获.采用值捕获需要变量可以拷贝.与参数传递不同,被捕获的变量的值是在lambda创建时拷贝,而不是调用时拷贝.引用捕获需要保证lambda表达式执行时,该引用指向的对象仍然存在. 在一个基本类型为string类型的可变数组中找出第一个长度大于给定值sz的元素.下面分别用函数对象和lambda表达式的形式实现. 123456789101112131415161718192021222324252627class SizeCmp &#123;public: SizeCmp(size_t n) : sz(n) &#123;&#125; bool operator()(const string &amp;a) &#123; return a.size() &gt;= sz; &#125;private: size_t sz;&#125;;int main()&#123; vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;; size_t sz = 6; // 使用lambda表达式// auto wc = find_if(vc.begin(), vc.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;); // 使用等价的函数对象 auto wc = find_if(vc.begin(), vc.end(), SizeCmp(sz)); // wc 为指向第一个长度不小于给定值sz的元素的迭代器 if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl; else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; &#125; //当sz=5时,输出mango;当sz=6时,输出empty result&#125; bind参数绑定标准库的bind函数可以看做一个函数适配器.它接受一个可调用对象,生成一个新的可调用对象. 123456789101112131415// 给check_size函数的第一个参数绑定一个值// auto check6 = bind(check_size, std::placeholders::_1, 6);auto check6 = bind(check_size, std::placeholders::_1, 5);// 调用check6函数string s = "hello";cout &lt;&lt; check6(s) &lt;&lt; endl;vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;;auto wc = find_if(vc.begin(), vc.end(), check6);// wc 为指向第一个长度不小于给定值sz的元素的迭代器if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl;else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; 可调用对象与function每一个lambda表达式都是一种未命名的新类型;函数对象的类型是该对象的类类型;函数和函数指针的类型由参数列表和返回值决定. 多个调用对象有不同的类型,但是却共享相同的调用形式.调用形式指明了调用返回的类型以及传递给调用的实参类型(如何SizeCmp类型的函数对象和lambda表达式,类型不同,调用形式相同).一种调用形式对应一个函数类型.标准库中function模板可以表示函数类型. 123456789101112map&lt;string, function&lt;int(int, int)&gt;&gt; binops = &#123; &#123;"+", add&#125;, &#123;"-", std::minus&lt;int&gt;()&#125;, &#123;"/", Divide()&#125;, &#123;"*", [](int i, int j) &#123; return i * j; &#125;&#125;, &#123;"%", mod&#125;&#125;;cout &lt;&lt; binops["+"](10, 5) &lt;&lt; endl; // 15cout &lt;&lt; binops["-"](10, 5) &lt;&lt; endl; // 5cout &lt;&lt; binops["%"](11, 4) &lt;&lt; endl; // 3cout &lt;&lt; binops["*"](13, 2) &lt;&lt; endl; // 26 add, Divide(),mod等各个可调用对象的类型各不相同,但是它们都是调用形式为int(int, int)的可调用对象,因此可以赋值给function&lt;int(int,int)&gt;类型的对象.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>可调用对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置指针]]></title>
    <url>%2F2019%2F07%2F31%2Fc%2B%2B%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[什么是指针?指针是一种特殊的变量.它的值是一个对象的地址,也称指针指向该对象.对指针进行解引用可以获取该对象.指针本身是一个对象,可以赋值和拷贝. 指针中保存着它指向的对象的地址.直接输出指针的内容即指针指向的对象的地址.对指针进行解引用得到指针指向的对象 二级指针中保存一个指针的地址, 这个被指向的指针中才真正保存着对象的地址.直接输出指针得到指针指向的一级指针的地址.对二级指针进行解引用得到一级指针指向的最终对象的地址(即一级指针的值).对一级指针进行解引用,得到最终对象 关于指针有一些很容易混淆的地方,下面举几个例子辨析一下. 示例1 1234567int a = 10;int *p = &amp;a;int **pp = &amp;p; // pp是指向指针的指针，它指向指针p。解引用后是指针p。cout&lt;&lt;"pp:"&lt;&lt;(pp)&lt;&lt;" &amp;p"&lt;&lt;(&amp;p)&lt;&lt;endl; // pp是指向指针变量p的指针，所以，pp中存放着整形指针变量p的地址cout&lt;&lt;"*pp:"&lt;&lt;(*pp)&lt;&lt;" p"&lt;&lt;(p)&lt;&lt;endl; // pp是指向指针变量p的指针，*pp解引用pp会得到整形指针变量p，而p的值是一个整形变量a的地址cout&lt;&lt;"p:"&lt;&lt;p&lt;&lt;" &amp;a:"&lt;&lt;(&amp;a)&lt;&lt;endl; // p是指向整形变量a的指针，所以，p中存放着整形变量a的地址cout&lt;&lt;"*p:"&lt;&lt;p&lt;&lt;" a:"&lt;&lt;(a)&lt;&lt;endl; // p是指向整形变量a的指针。*p解引用整形指针p会得到一个整形数 运行结果 1234pp:0x7fff5ce9bf48 &amp;p0x7fff5ce9bf48*pp:0x7fff5ce9bf44 p0x7fff5ce9bf44p:0x7fff5ce9bf44 &amp;a:0x7fff5ce9bf44*p:0x7fff5ce9bf44 a:10 示例2 123456789101112131415161718192021int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p, **k; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *p:" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(p++):" &lt;&lt; *(p++) &lt;&lt; " "; cout &lt;&lt; "after p++" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(++p):" &lt;&lt; *(++p) &lt;&lt; " "; cout &lt;&lt; "after ++p" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; 运行结果 1234567891011a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *p:1k:0x7ffcd38cc920 *k:0x7ffcd38cc930 **k:1=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(p++):1 after p++0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(++p):2 after ++p0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2 可知, a是数组的名字,也是指向数组首元素的指针.p=a将指针p指向数组首元素.因此p的值是数组首元素的地址. p是数组首元素的值.**k表明k是指向指向指针的指针, k指向指针p,因此,k中保存这指针p的地址,\k是指针p的值,也就是指针指向的对象地址,这里就是数组a首元素的地址.**k就是*(p)就是指针p指向的对象的值.]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum 系列, 和为s的两个数字系列(2sum)]]></title>
    <url>%2F2019%2F07%2F17%2FTwo%20Sum%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[和为S两个数字 题目来源：剑指offer题目链接 题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 1对应每个测试案例，输出两个数，小的先输出。 解法1: 使用set1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; set&lt;int&gt; iset; vector&lt;int&gt; res(2); int mul = INT_MAX; for(int i=0;i&lt;array.size();i++)&#123; if(iset.find(sum - array[i])!=iset.end())&#123; int temp = array[i] * (sum - array[i]); if(temp &lt; mul)&#123; mul = temp; res[0] = sum - array[i]; res[1] = array[i]; &#125; &#125; iset.insert(array[i]); &#125; if(mul == INT_MAX)&#123; return &#123;&#125;; &#125; return res; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(n) 解法2 思路：数组是有序的，可以用双指针。 细节处理稍有不同的两种AC代码。 AC代码： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; if(array.size() &lt; 2)&#123; return &#123;&#125;; &#125; int a = -1, b = -1; int mul = 2147483647; int i = 0, j = array.size() - 1; while(i &lt; j)&#123; if(array[i] + array[j] == sum)&#123; if(array[i] * array[j] &lt; mul)&#123; mul = array[i] * array[j]; a = array[i]; b = array[j]; &#125; &#125; if(array[i] + array[j] &gt; sum)&#123; j--; &#125;else&#123; i++; &#125; &#125; vector&lt;int&gt; res; if(a!=-1 &amp;&amp; b!=-1)&#123; res.push_back(a); res.push_back(b); &#125; return res; &#125;&#125;; AC代码2 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; if(array.size() &lt; 2)&#123; return &#123;&#125;; &#125; int a = -1, b = -1; int mul = 2147483647; int i = 0, j = array.size() - 1; while(i &lt; j)&#123; if(array[i] + array[j] == sum)&#123; if(array[i] * array[j] &lt; mul)&#123; mul = array[i] * array[j]; a = array[i]; b = array[j]; &#125; i++; j--; &#125; else if(array[i] + array[j] &gt; sum)&#123; j--; &#125;else&#123; i++; &#125; &#125; vector&lt;int&gt; res; if(a!=-1 &amp;&amp; b!=-1)&#123; res.push_back(a); res.push_back(b); &#125; return res; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(1) 和为S的连续正数序列题目链接 题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解法112345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; if(sum == 1)&#123; return &#123;&#125;; &#125; int thisSum = 0; vector&lt;vector&lt;int&gt;&gt; res; int n = (sum + 1) / 2; vector&lt;int&gt; ans(n+1, 0); for(int i=1;i&lt;=n;i++)&#123; thisSum += i; ans[i] = thisSum; &#125; for(int i=0;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(ans[j] - ans[i] == sum)&#123; vector&lt;int&gt; tmp; for(int k=i+1;k&lt;=j;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; &#125; &#125; return res; &#125;&#125;; 使用累计和的概念.ans[i]统计0-i的和. 解法21234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; int l = 1, r = 2; int thisSum = l + r; vector&lt;vector&lt;int&gt;&gt; res; while(l&lt;= (1+sum)/2)&#123; if(thisSum == sum)&#123; vector&lt;int&gt; tmp; for(int k=l;k&lt;=r;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; if(thisSum &lt; sum)&#123; thisSum += ++r; &#125;else&#123; thisSum -= l++; &#125; &#125; return res; &#125;&#125;; thisSum表示子数组arr[l,…,r]的累加和. 最初, l=1, r =2, 最小的两个连续正数序列的和为1+2=3.所以,将thisSum初始化为3.循环结束条件为两个数的和大于等于sum时,因此可知,满足这个条件的最大的子数组为[n, n+1], n = (1+sum)/2.因此,需要循环结束条件为l = (1+sum)/2 Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 此题和上题的区别有两点： 返回下标，而不是值 数组不是有序的 若是返回的是值，可以对数组进行排序然后按双指针解。时间复杂度为O(nlogn)。排序的时间复杂度为O(n)。 解法1：暴力破解1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size()-1; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[i] + nums[j] == target)&#123; return &#123;i, j&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n2)，空间复杂度为O(1)。 解法2：两趟哈希表12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; mp[nums[i]] = i; &#125; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!= mp.end() &amp;&amp; mp[complement]!=i)&#123; return &#123;i, mp[complement]&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法3：一趟哈希表1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!=mp.end())&#123; return &#123;mp[complement], i&#125;; &#125; mp[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 3SumMedium Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路：首先对数组进行排序。然后锁定第一个数，如第一个数的索引是i，则此后在front-back范围内（front &gt; i）寻找两个数，使他们的和为0 - nums[i]。随着i后移，front和back指定的范围在缩小。因为nums[i]增大，则0 - nums[i]减小。且移动过程中需要去重。 如将上例数据改为： 1Given array nums = [-1, 0, 1, 0, 1, 2, -1, -4, 2, 3] 则排序后： 1array nums = [-4, -1, -1, 0, 0, 1, 1, 2, 2, 3] 过程如下：注意去重 i = 0, front = 1, back = 9, 在front-back中找两个数的和为4 front = 5, back= 9, nums[5]=1, nums[9]=3(front = 6, nums[front]=1，需要去重) front = 7, back=8, nums[7]=2, nums[8]=2i = 1, front = 1, back = 9, 在front-back中找两个数的和为1 front = 2, back = 8, nums[2] = -1, nums[8] = 2 front = 3, back = 6, nums[3] = 0, nums[6] = 1(后面back=5, nums[5]=0, 需要去重)i = 2(nums[2] = -1需要去重)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortest Unsorted Continuous Subarray]]></title>
    <url>%2F2019%2F07%2F17%2FShortest%20Unsorted%20Continuous%20Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: 123Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 解法1:暴力破解假设数组nums长度为n。考虑每一个可能的子数组nums[i:j]，要使得nums[i:j]是最长的未排序子数组，需要满足以下条件：nums[0:i-1]是有序的，nums[j+1:n-1]是有序的。nums[i:j]是无序的，且nums[i:j]中的最小值大于nums[i-1]，nums[i:j]中的最大值小于nums[j+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int res = nums.size(); for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i;j&lt;nums.size();j++)&#123; int min_val = 2147483647; int max_val = -2147483648; int prev = - 2147483648; for(int k=i;k&lt;j;k++)&#123; min_val = min_val &gt; nums[k]? nums[k]:min_left; max_val = max_val &gt; nums[k]? max_val:nums[k]; &#125; // min_val为nums[i:j]中的最小值，max_val为nums[i:j]中的最大值 //nums[0:i]或者nums[j+1:]不满足有序 if((i&gt;0 &amp;&amp; nums[i-1] &gt; min_val) || (j &lt;nums.size() &amp;&amp; nums[j] &lt; max_val))&#123; continue; &#125; int k = 0; //nums[0:i]是有序的 //若能成立则运行完后prev=nums[i-1] while(k &lt; i &amp;&amp; prev &lt;= nums[k])&#123; prev = nums[k]; k++; &#125; if(k!=i) continue; k = j; //nums[j:]是有序的且nums[j] &gt;= nums[i-1] while(k &lt; nums.size() &amp;&amp; prev&lt;=nums[k])&#123; prev = nums[k]; k++; &#125; // 思考一下：为什么要小于呢？ if(k==nums.size())&#123; res = res &gt; j - i ? j - i:res; &#125; &#125; &#125; return res; &#125;&#125;; 解法2：较好一点的暴力破解如果对于nums[i]来说，其前面的数都小于等于它，后面的数都大于等于它，则它的位置是正确的，否则它的位置是错误的。一对相距最远的数的位置就是我们要找的。遍历数组，每次遇到逆序的数就更新左边界和右边界。左边界取较小的，右边界取较大的。 123456789101112131415class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int l = nums.size(), r = 0; // l是左边界，r是右边界，左边界取较小的，右边界取较大的 for(int i=0;i&lt;nums.size()-1;i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[j] &lt; nums[i])&#123; r = r &gt; j? r : j; l = l &lt; i? l : i; &#125; &#125; &#125; return r - l &lt; 0?0:r - l + 1; &#125;&#125;; 时间复杂度为O(n2)。 解法3：使用栈和解法2的思路一样都是不断更新左边界和左边界。 12345678910111213141516171819202122232425class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; stack&lt;int&gt; st; int l = nums.size(), r = 0; for(int i=0;i&lt;nums.size();i++)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &gt; nums[i])&#123; l = l &gt; st.top()? st.top():l; st.pop(); &#125; st.push(i); &#125; while(!st.empty())&#123; st.pop(); &#125; for(int i=nums.size()-1;i&gt;=0;i--)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i])&#123; r = r &gt; st.top()?r:st.top(); st.pop(); &#125; st.push(i); &#125; return r - l ? r - l + 1: 0; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法4：两次遍历两次遍历，分别找左边界和右边界。左边界是位置最左，且逆序的数，右边界是位置最右且逆序的数。一个数若大于其后任意一个数就可以判断该数是逆序的。因此，一个数若大于其后最小的一个数既可以看做是逆序的。同样，一个数若小于其前面任意一个数即可认定该数是逆序。因此，一个数若小于其前面最大的一个数即可认定该数是逆序的。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2)&#123; return 0; &#125; int leftmost = -1, rightmost = -1; int min_right = nums[nums.size()-1]; int max_left = nums[0]; for(int i=nums.size()-2;i&gt;=0;i--)&#123; if(nums[i] &gt; min_right)&#123; leftmost = i; &#125;else&#123; min_right = nums[i]; &#125; &#125; if(leftmost == -1)&#123; return 0; &#125; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i] &lt; max_left)&#123; rightmost = i; &#125;else&#123; max_left = nums[i]; &#125; &#125; return rightmost - leftmost + 1; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>连续子数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis使用过程中遇到的问题]]></title>
    <url>%2F2019%2F07%2F17%2Fredis%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述redis使用过程中发现redis返回的数据中str类型都是byte类型。byte类型使用很不方便，所以就想转成str类型。 初始时建立redis连接代码为： 1r1 = redis.Redis(host=redis_host, port=6379, db=1) 在网上搜索了一番，在csdn找到这个答案（详见https://ask.csdn.net/questions/381758）：在建立连接时，将decode_responses置为True。即这样建立连接： 1r1 = redis.Redis(host=redis_host, port=6379, db=1, decode_responses=True) 经过测试，这个问题成功解决了。 redis的字符串redis中的字符串是一种名为sds(简单动态字符串)的抽象数据类型来表示.所有sds API都以处理二进制的方式来处理string类型对象的数据,程序中不对数据做任何的限制,过滤或者假设.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork函数]]></title>
    <url>%2F2019%2F07%2F17%2Ffork%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[fork基本概念一个进程, 包括代码, 数据和分配给该进程的资源. fork()通过系统调用创建一个与原来进程几乎完全相同的进程.也就是两个进程做完全相同的事.但是如果初始参数或者传入的变量不同,两个进程也可以做不同的事情. 一个进程调用fork()函数后,系统先给新的进程分配资源.如存储数据和代码的存储空间.然后吧原来的进程的所有值都复制到新进程中,只有少数值与原来的进程的值不同.相当于克隆了一个自己.创建新进程成功后, 系统中出现两个几乎完全相同的进程,这两个进程执行没有固定的先后顺序, 哪个进程先执行要看系统的进程调度策略. 由fork函数创建的新进程被称为子进程。fork函数被调用一次，但是返回两次。父进程返回的值是新进程的进程ID，而子进程返回的值是0。 fork函数返回值的三种情况 返回子进程Id给父进程 因为一个进程的子进程可能有多个，并且没有一个函数可以获得一个进程的所有子进程ID。 返回给子进程值为0 一个进程只会有一个父进程，所以子进程总是可以调用getpid以获得当前进程Id以及调用getppid获得父进程Id. 出现错误，返回负值 当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN 系统内存不足，这时errno的值被设置为ENOMEM 子进程执行代码开始位置 fork可以创建一个子进程并完全复制父进程,但是子进程是从fork后面那条指令开始执行的.如果子进程也从main开始执行所有指令,那么它执行到fork指令时必然会创建一个新的子进程. 从而导致不停地创建子进程,程序永不结束 示例1fork创建子进程1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); break; case 0: message = "this is the child"; n = 5; break; default: message = "this is the parent"; n = 3; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(3); &#125; return 0;&#125; 运行结果 123456789101112xixi@xixi:~/linux_cource/11.3$ ./a.out fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childxixi@xixi:~linux_cource/11.3$ this is the childxixi@xixi:~/linux_cource/11.3$ 程序在调用fork时被分为两个独立的进程.当用fork启动一个子进程时, 子进程就有了它自己的生命周期并将独立运行.父进程在子进程之前结束, 因此在输出内容中有一个shell提示符. 让父进程等待子进程结束如果希望父进程等待子进程结束,可以调用wait函数.函数原型: pid_t wait(int* stat_loc);wait系统调用返回子进程的pid, 通常是已经结束运行的子进程的pid.状态信息允许父进程了解子进程的退出状态, 即子进程的main函数返回的值或者子进程中exit函数的退出码.如果stat_loc不是空指针, 状态信息将被写入到它所指向的位置. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 3; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行结果 1234567891011fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childthis is the childchild has finished: PID: 15467child exited with code 37 查看僵尸进程子进程终止时,它与父进程之间的关联还会保持, 直到父进程也正常终止或父进程调用wait才会结束.因此,进程表中代表子进程的表项不会立即释放.虽然子进程已经不再运行,但它仍然存在于系统中,因为它的退出码还需要保存起来,以备父进程今后的wait调用使用.这时候它将成为一个死进程或者僵尸进程.所以,僵尸进程就是这样一种进程: 它自身运行已经结束,但是进程控制块还没有释放.因为还有其他进程需要它的运行状态等信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 10; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); // stat_val中保存这子进程的状态信息 cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行过程中在命令行中查看wait进程的信息(上面这个程序在编译时被命名为wait) 12345678xixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 ./waitxixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 [wait] &lt;defunct&gt; 上面的运行结果可以看出,一开始子进程正常运行,后来子进程变成了僵尸进程.如果父进程异常终止, 子进程将自动把pid等于1的进程(即init进程)作为自己的父进程.子进程现在是一个不再运行的僵尸进程,但是由于父进程异常终止,所以它由init进程接管.僵尸进程将一直保留在进程表中知道被init进程发现并释放.进程表越大,这一过程越慢. 常用的两种应用场景 一个父进程希望复制自己,使父子进程同时执行不同的代码段.这在网络服务中是常见的. 父进程等待客户端的服务请求.当这种请求到达时,父进程调用fork,使子进程处理此请求.父进程则继续等待下一个服务请求的到达. 一个进程要执行一个不同的程序.这是shell常见的情况.子进程从fork返回后立即调用exec. 123456789101112131415161718192021pid_t pid;int ctr = 0;cout &lt;&lt; "当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;// 在这个位置,仅仅父进程会执行cout &lt;&lt; "unique" &lt;&lt; endl;pid = fork(); // 仅调用一次,返回两次if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1);&#125; else if (pid == 0) &#123; ++ctr; cout &lt;&lt; "进入子进程, 当前进程id=" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125; else &#123; ++ctr; cout &lt;&lt; "当前进程id=" &lt;&lt; getpid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125;// 在这个位置,则父子进程都会执行cout &lt;&lt; "reduant" &lt;&lt; endl; 执行结果 123456当前进程, id=7346unique当前进程id=7346 ctr=1reduant进入子进程, 当前进程id=7347 父进程id=7346 ctr=1reduant 执行fork前, ctr=0; 执行fork后,对于父进程而言会执行ctr自增和打印进程信息两个操作. 因此打印出的ctr=1.对于子进程而言,由于执行fork前ctr=0,因此在子进程中ctr=0, 同样子进程执行ctr自增和打印进程信息操作.因此打印出的ctr=1 12345678910111213141516pid_t pid;int loop;// cout &lt;&lt; "我是父进程, 当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;for (loop = 0; loop &lt; 2; ++loop) &#123; pid = fork(); //一个子进程第一次调用fork,返回0,表示该进程本身是子进程,第二次fork产生一个以当前子进程为父进程的子进程 if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1); &#125; else if (pid == 0) &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid &lt;&lt; endl; sleep(5); &#125;&#125; 执行结果 123456loop=0 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5948loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0loop=1 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=5949loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0loop=1 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5952loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0 过程解释 进程5947使用fork产生一个子进程5948. fork执行时loop=0.因此子进程5948中loop=0. 子进程5948第一次调用fork的返回值pid是0,表明进程5948是子进程, 因此直接打印出”loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0”; 当进程5948第二次调用fork时, 产生一个新的子进程5949. 在进程5948中,调用fork函数前, loop=1,因此在新的子进程5949中loop=1. 也因此子进程5949只会调用一次fork(就会因为loop&gt;=2而跳出循环). 在子进程5949的运行过程中只会打印出”loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0” 而对于进程5947, 在第一次循环结束后继续执行第二次循环. 此时loop=1. 调用fork后, 产生一个新的子进程5952, 该子进程中loop=1. 因此类似的, 进程5952只会打印出”loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0” 参考文献[1] https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html[2] https://www.jianshu.com/p/586300fdb1ce]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Validate Stack Sequences(946)]]></title>
    <url>%2F2019%2F07%2F17%2F946.%20Validate%20Stack%20Sequences%2F</url>
    <content type="text"><![CDATA[Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: 12345Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 Example 2: 123Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 题意是说，给定一个入栈序列和一个可能的出栈序列，问在给定的入栈序列下能否得到出栈序列。如果能返回true，否则返回false。 此题的解决是模拟。模拟入栈入栈并出栈的问题，尽量得到和给定的出栈序列一致的出栈序列。如例1，首先为了得到第一个出栈的是4，则必须将[1,2,3,4]入栈，然后将4出栈，则从栈底到栈顶的元素分别为[1,2,3]。第二步，为了得到出栈序列中的第二位5，必须将5入栈，然后将5出栈，得到出栈序列中的第二位，此时，栈中栈底到栈顶的各元素分别为[1,2,3]。第三步为了得到3，直接将栈顶元素出栈即可。第四步和第五步同第三步。 对于例2，同样，第一步为了得到出栈序列中的4，将1,2,3,4依次入栈，并将4出栈，得到出栈序列中的第一位，此时栈底到栈顶的各元素为[1,2,3]。第二步，为了得到出栈序列中的第二位3，将此时的栈顶元素3直接出栈即可。第三步，为了得到5，将5入栈，继而出栈，得到出栈序列[4,3,5]。第四步，需要得到出栈序列中的第四位1，每一步当我们希望得到出栈序列中的下一位时，我们有两个选择，要么这一位还未入栈，如第一步中的4，对于这种情况，我们需要将后续元素入栈，另一种情况是，这一位就是栈顶元素，如第二步中的3。此时，所有入栈序列中的元素都已经入栈，那么只有一种可能了，那就是出栈序列中的下一位就是栈顶元素。但是，通过比较出栈序列中的下一位和栈顶元素可知，栈顶元素不是出栈序列中的下一位，因此，此出栈序列无法由入栈序列得到，返回false。 AC代码 123456789101112131415161718class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int k = 0; for(int i=0;i&lt;popped.size();i++)&#123; while(k &lt; pushed.size() &amp;&amp; (st.empty() || st.top()!=popped[i]))&#123; st.push(pushed[k++]); &#125; if(st.top()==popped[i])&#123; st.pop(); &#125;else&#123; return false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[907. Sum of Subarray Minimums]]></title>
    <url>%2F2019%2F07%2F17%2F907.Sum-of-Subarray-Minimums%2F</url>
    <content type="text"><![CDATA[Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7. Example 1: 1234Input: [3,1,2,4]Output: 17Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. 解法1统计以a[j]为right-most最小值的子数组的个数, 记作s[j].这样, 结果就是sum(s[j] * a[j]). 必须以right-most为条件,因为只有如此,才能把子数组分为不重合的集合以免重复计算.问题于是转化为, 求最小的i(i&lt;=j), a[i] , a[i+1] , …., a[j]都是大于等于a[j]的.以及最大的k(k&gt;=j) , a[j+1], a[j+2],….,a[k]都大于a[j]. 对于一个数组[2,3,4,1]来说,包含3的子数组有6个.这是因为3的左边有一个数, 右边有2个数.3可以在它的左边选择0个或者1个数, 在右边选择0或1个或2个构成子数组.因为包括3的子数组个数共有6个,分别是:即包括3的子数组的个数是(j-i+1) * (k - j + 1), 设j表示3的索引1, i=0, k = 3. 1[[3],[2,3],[3,4],[3,4,1], [2,3,4],[2,3,4,1]] 过程设a = [10,3,4,5,3,2,3,10], 我们想知道以j=4(即以a中第三个3为right-most最小值的子数组的个数), 首先我们找出i = 1, k = 5; 则以这个3为right-most最小值的子数组的个数为(5-5+1) *(5-1+1) = 5, 即子数组[[3],[5,3],[4,5,3],[3,4,5,3]]然后使用单调栈来求数组a中a[j]左边第一个小于a[j]的元素a[i]和右边第一个小于等于a[j]的元素a[k]. 代码未测试: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*** * 找出nums中元素nums[j]左边第一个小于nums[j]的元素nums[i], * 及nums[j]右边第一个小于等于nums[j]的元素nums[k * @param nums */vector&lt;vector&lt;int&gt;&gt; singleStack(vector&lt;int&gt; &amp;nums) &#123; stack&lt;int&gt; st; if (nums.size() &lt; 1) &#123; return &#123;&#125;; &#125; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2, -1)); for (int i = 0; i &lt; nums.size(); ++i) &#123; while (!st.empty() &amp;&amp; nums[st.top()] &gt;= nums[i]) &#123; int index = st.top(); st.pop(); int l = st.empty() ? -1 : st.top(); int r = i; res[index][0] = l; res[index][1] = r; &#125; st.push(i); &#125; // 下面这些元素右边没有元素比它们小 while (!st.empty()) &#123; int index = st.top(); st.pop(); int l = st.empty() ? -1 : st.top(); int r = nums.size(); res[index][0] = l; res[index][1] = r; &#125; return res;&#125;void testsingleStack() &#123;// vector&lt;int&gt; nums&#123;2, 3, 2, 3, 5, 2, 3, 3&#125;; vector&lt;int&gt; nums&#123;3, 1, 2, 4&#125;; vector&lt;vector&lt;int&gt;&gt; res = singleStack(nums); int total = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "] " &lt;&lt; nums[i] &lt;&lt; ": " &lt;&lt; res[i][0] &lt;&lt; "," &lt;&lt; res[i][1] &lt;&lt; endl; // (i - res[i][0]) * (res[i][1] - i) 表示以nums[i]为最小值的子数组个数 total += (i - res[i][0]) * (res[i][1] - i) * nums[i]; &#125; cout &lt;&lt; total &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[877. Stone Game]]></title>
    <url>%2F2019%2F07%2F17%2F877.Stone-Game%2F</url>
    <content type="text"><![CDATA[Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. 相关题目: 486. Predict the Winner Example 1: 12345678Input: [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. 错误的思路一开始以为可以用双指针的方式解决：每次贪心，选择从排在最前面和最后面的石头堆里选择数量较大的那堆。后来发现我太天真了。比如说这个例子： Example 1[5,3,2,7,5,2] 如果按照上面的贪心办法，那么alex会选到:5,2(选择最前面的2),5 5+2+5=12lee选到剩下的3,7,2 3+7+2=12所以结果返回false.但是如果alex这么选：5, 2（选择排序最后的2）,7 5+2+7 =14. lee选择剩下的3,2,5 3+2+5=10结果返回true。 123456789101112131415161718192021222324252627bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k; k = 0; i = 0, j = piles.size()-1; int sum_alex=0, sum_lee=0; while(k&lt;piles.size())&#123; int select; if(piles[i]&gt;=piles[j])&#123; select = piles[i]; i++; &#125;else&#123; select = piles[j]; j--; &#125; if(k&amp;1)&#123; // lee sum_lee += select; &#125;else&#123; // alex sum_alex+= select; &#125; k++; &#125; cout&lt;&lt;"sum_alex="&lt;&lt;sum_alex&lt;&lt;" sum_lee="&lt;&lt;sum_lee&lt;&lt;endl; if(sum_alex &gt; sum_lee)&#123; return true; &#125; return false;&#125; 想到的第二种解法：回溯. 悲催的是，超时了。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k, ans, best; k = 0; i = 0, j = piles.size()-1; ans = 0, best = 0; int sum = 0; for(auto pile:piles)&#123; sum+=pile; &#125; dfs(ans, best, k, piles, i, j); if(best &gt; sum - best)&#123; return true; &#125; return false; &#125; void dfs(int &amp;ans,int &amp;best, int k, vector&lt;int&gt;&amp;piles, int i, int j)&#123; if(i==j)&#123; if(best &lt; ans)&#123; best = ans; &#125; return; &#125; // 选择i ans += k%2==0?piles[i]:0; dfs(ans, best, k+1, piles, i+1, j); ans -= k%2==0?piles[i]:0; // 选择j ans += k%2==0?piles[j]:0; dfs(ans, best, k+1, piles, i, j-1); ans -= k%2==0?piles[j]:0; &#125;&#125;; 那么接下来，我能想到的唯一可能求解的方法就是动态规划的了，那么问题来了，状态转移方程怎么写呢？ 暴力搜索自顶向下1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), -1)); int stoneNum = getStones(piles, 0, piles.size()-1, nums); return stoneNum &gt; (sum / 2); &#125; int getStones(vector&lt;int&gt;&amp; stones, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp;nums)&#123; if(i &lt;= j)&#123; if(nums[i][j]!=-1)&#123; return nums[i][j]; &#125; int sn1 = 0, sn2 = 0, sn = 0; // when there are even number of piles stones, it`s Alex`s turn if((j - i + 1) % 2 == 0)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) + stones[i] : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) + stones[j] : nums[i][j-1] ; &#125;else&#123; if(i &lt; j)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) : nums[i][j-1] ; &#125; &#125; sn = sn1 &gt; sn2 ? sn1 : sn2; nums[i][j] = sn; return sn; &#125;else&#123; return 0; &#125; &#125;&#125;; 时间复杂度：当剩余可以选择的石头堆数为偶数时，说明此时轮到Alex选择．当Alex选择时，他可以从最左边也可以从最右边选择一堆石头，若他选择最左边的一堆，左边界i++，否则，右边界j–． 自底向上12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), 0)); for(int i=0;i&lt;piles.size();i++)&#123; nums[i][i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=0;i &lt; nums.size() - k;i++)&#123; if(k % 2 == 0)&#123; nums[i][i+k] = max(nums[i][i+k-1] + piles[i + k], nums[i+1][i+k] + piles[i]); &#125;else&#123; nums[i][i+k] = max(nums[i][i+k-1], nums[i+1][i+k]); &#125; &#125; &#125; return nums[0][nums.size()-1] &lt;= (sum / 2); &#125; &#125;; 时间复杂度：O(n2) 空间复杂度：O(n2) 此时此题被转化成了Lee能够获得的最多的石头个数．nums[i][j]表示的是当Lee只能在第i到第j堆石头之间选择时，他能够获得最大石头数量．显然，nums[i][i]=piles[i]，也就是最后一次选择时，Lee只能选择第i堆石头．当i &lt; j时，当剩余可以选择的石头堆数为奇数时，即轮到Lee选择，此时，Lee有两种选择方法nums[i][j] = max(nums[i][j-1] + piles[j] , nums[i+1][j] + piles[i])Alex取胜的条件时，Lee能获得最多的石头数量仍然小于此时Alex能获得石头数量． 空间压缩12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;int&gt; nums(piles.size(),0); for(int i=0;i&lt;piles.size();i++)&#123; nums[i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=nums.size()-k-1; i &gt;= 0;i--)&#123; if(k % 2 == 0)&#123; nums[i] = max(nums[i] + piles[i + k], nums[i+1] + piles[i]); &#125;else&#123; nums[i] = max(nums[i], nums[i+1]); &#125; &#125; &#125; return nums[0] &lt;= (sum / 2); &#125; &#125;; 代码未能AC, 还需要考虑.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[767. Reorganize String]]></title>
    <url>%2F2019%2F07%2F17%2F767.Reorganize-String%2F</url>
    <content type="text"><![CDATA[Reorganize StringGiven a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example 1: 12Input: S = &quot;aab&quot;Output: &quot;aba&quot; Example 2: 12Input: S = &quot;aaab&quot;Output: &quot;&quot; Note: S will consist of lowercase letters and have length in range [1, 500]. 解法1根据插空法, 当数组中有n个数,且n/2个数都是同一个数.如下所示: 1234567示例1[1,1,1,2,2]1,2,1,2,1示例2[1,1,1,2,2,2]1,2,1,2,1,2 则数组中最多有(n+1)/2个是同一个数,这样可以通过插空法,隔一个位置插一个数保证每两个相邻的数不同.如示例1中如果1的个数再多出一个就无法保证每两个相邻的数不同. 因为通过首先统计数组中是否存在出现次数超过(n+1)/2的数来判断是否存在一种方案能保证任意两个相邻的数不同.然后通过重组数组来给出一种方案.重组数组的过程中,首先将数组中元素按出现次数由少到多排序,然后,将前面一般分布到奇数位置上,将后一般分布到偶数位置上来实现任意两个相邻的元素不同. c++如何对map进行排序 时间复杂度为O(m(n + logn)),其中n是S的长度,m是用于统计每个字符出现次数的map的大小.因此时间复杂度为O(n)空间复杂度为O(n+m) 解法2https://leetcode.com/articles/reorganized-string/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>求众数(出现次数超过n/2的数)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2019%2F07%2F17%2F560.-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[解法1: 遍历子数组当给定i时, sum 表示以arr[i]开始,到arr[j]结束的各个元素的累加和(j&gt;=i). 注意: 这里不需要知道是哪些子数组的和等于k,只需要统计和等于k的子数组的个数,因此这里不必记录子数组的开始和结束索引,只需要依次找出所有子数组,并统计其中和等于k的子数组的个数. 那么如何找出所有可能的子数组呢? 方法一:内存循环找出所有以数组中第i个元素开始的所有子数组,并统计其中和等于k的子数组的个数.而外层循环则依次枚举所有可能的i. 方法二: 下面给出的代码是内层循环统计以数组中第j个元素结尾的子数组的和等于k的子数组的个数, 外层循环列举所有可能的j.具体而言, 内层循环依次计算 arr[j]arr[j-1] + arr[j]arr[j-2] + arr[j-1] + arr[j]…….arr[2] + … + arr[j]arr[1] + arr[2] + … + arr[j] 也就是子数组arr[i,..,j]的和. i = j, j-1,…1若令s[i] 表示arr[1] + arr[2] + … + arr[i]那么子数组arr[i,…j]的和可以表示为s[j] - s[i-1] AC代码１ 123456789101112131415class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum = 0; for(int j=i;j&lt;nums.size();j++)&#123; sum += nums[j]; if(sum == k) ++counter; &#125; &#125; return counter; &#125;&#125;; AC代码2: 12345678910111213141516class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum = 0; for(int i=j;i&gt;=0;i--)&#123; sum += nums[i]; if(sum == k)&#123; ++counter; &#125; &#125; &#125; return counter; &#125;&#125;; 时间复杂度分析 时间复杂度: O(n2). 只用到两重循环, 容易得出时间复杂度空间复杂度:O(1) 解法2如方法二所述, 子数组arr[i, … , j]的和可以表示为s[j] - s[i-1]s[0] = arr[0]这里为了表示空数组的和为0, 不妨令s的下标从1开始.即 s[0] = 0, 表示空数组的和为0s[1] = arr[0]s[2] = arr[0] + arr[1]s[3] = arr[0] + arr[1] + arr[2] 依次类推. 那么各子数组的和可以表示为 arr[0] = s[1] - s[0]arr[0,1] = arr[0] + arr[1] = s[2] - s[0]arr[1] = s[2] - s[1]arr[1,3] = arr[1] + arr[2] + arr[3] = s[4] - s[1] 以此类推,可知 arr[i,….,j] = s[j+1] - s[i] 若要子数组arr[i,…,j]的和等于k,即s[j+1] - s[i] = k, 即s[i] = s[j+1] - k, 即当统计出arr[1,…j]时只需要统计其前面的子数组中和等于s[j+1] - k的子数组的个数就可以统计以第j个元素结尾的子数组中满足和等于k的子数组的个数. AC代码3 1234567891011121314151617181920class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; vector&lt;int&gt; temp; temp.push_back(0); for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; // 统计s[0], s[1], s[2],..,s[j]中和等于s[j+1] - k for(int i=0;i&lt;temp.size();i++)&#123; if(sum - temp[i] == k)&#123; ++counter; &#125; &#125; temp.push_back(sum); &#125; return counter; &#125;&#125;; 可以看到这里的内层使用遍历的方法来统计数组中满足条件的子数组个数.但实际上,我们并不关心哪些子数组满足条件,而只需要知道满足条件的子数组个数,也就是说,我们不必记录s[j+1]之前的每个s[i](i&lt;=j)具体由哪些元素组成, 我们只需要记住,s[i]有哪些可能的值及这些可能值出现的次数.因此,我们可以使用map来记录每个值出现的次数.而从map中取出一个key对应的值只需要常量时间,通过这种方式可以大大降低所需时间.具体代码见下面代码. 解法3: 使用mapAC代码: 使用hashmap 1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; map&lt;int, int&gt; mp; mp[0] = 1; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; counter += mp.find(sum - k) == mp.end() ? 0 : mp[sum - k]; mp[sum] = mp.find(sum) == mp.end() ? 1: mp[sum] + 1; &#125; return counter; &#125;&#125;; 1234567891011121314class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; map&lt;int, int&gt; mp; mp[0] = 1; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; counter += mp.find(sum - k) == mp.end() ? 0 : mp[sum - k]; mp[sum] = mp.find(sum) == mp.end() ? 1: mp[sum] + 1; &#125; return counter; &#125;&#125;; mp[sum -k]统计的是arr[i]之前的s[j]是否等于 sum - k.则s[i] - s[j] = arr[j+1] + arr[j+2] + .. + arr[i] = k.这样同样需要注意需要额外设置mp[0] = 1; 表示存在空子数组的和为0.复杂度分析 时间复杂度为O(n).空间复杂度为O(n). 要统计多少个子数组的和为k,则可以分别统计以数组中每个元素结尾的子数组中有多少个子数组的和等于k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和系列</tag>
        <tag>累积和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[523. Continuous Subarray Sum]]></title>
    <url>%2F2019%2F07%2F17%2F523.Continuous-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to nk where n is also an *integer**. Example 1: 123Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. Example 2: 123Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. 相关题目: leetcode 560 解法1: 二重循环枚举所有可能的子数组组合时间复杂度分析 时间复杂度为O(n2) 解法2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2F2019%2F07%2F17%2F494.Target-Sum%2F</url>
    <content type="text"><![CDATA[You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 暴力破解123456789101112131415class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; return dfs(nums, S, 0, 0); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; return dfs(nums, S, index + 1, sum + nums[index]) + dfs(nums, S, index + 1, sum - nums[index]); &#125;&#125;; 自顶向下的记忆化搜索这里会涉及到负值,如何处理呢?加上可能的最小值的负数,进行偏移. 1234567891011121314151617181920212223class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; int sum = 0; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2010, -1)); return dfs(nums, S, 0, 0, res); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; if(res[index][sum + 1000]!=-1)&#123; return res[index][sum + 1000]; &#125; int add = dfs(nums, S, index + 1, sum + nums[index], res); int sub = dfs(nums, S, index + 1, sum - nums[index], res); res[index][sum + 1000] = add + sub; return add + sub; &#125;&#125;; 自底向上 dp[i][j]表示到第i个元素,组成的和为j的方法数.dp[i][sum + nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2F2019%2F07%2F17%2F225.-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 注意点是否需要处理异常情况。 # 两个队列，push(O(1),pop O(n)) 两个队列，push(O(n),pop O(1))一个队列，push(O(n),pop O(1))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2F2019%2F07%2F17%2F221.Maximal-Square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 解法1首先为原矩阵生成一个同样大小的新矩阵dpdp[i][j]表示以index[i][j]作为右下角的正方形的最大边长.dp[i][j] = min{dp[i][j-1], dp[i-1][j-1], dp[i-1][j-1]}.为什么一定要考虑dp[i-1][j-1]呢?下面举个例子说明例如当前dp矩阵为 12[[0,1], [1,1]] 则以位置[1,1]为右下角的最大的正方形的边长为1,因为,位置[0,0]处的边长为0, 即位置[0,0]上的元素为0.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamice programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2F2019%2F07%2F17%2F179.-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; 1234567891011121314151617181920212223242526class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return ""; &#125; vector&lt;string&gt; sarr; for(int i=0;i&lt;nums.size();i++)&#123; sarr.push_back(to_string(nums[i])); &#125; sort(sarr.begin(), sarr.end(), compare); string res = ""; for(int i=0;i&lt;sarr.size();i++)&#123; res += sarr[i]; if(i==0 &amp;&amp; sarr[i]=="0")&#123; break; &#125; &#125; return res; &#125; static int compare(string c, string d)&#123; string s1 = c + d; string s2 = d + c; return s1 &gt; s2; &#125;&#125; 总结:学到一种构造cmp函数的方法.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>谓词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2F2019%2F07%2F17%2F164%20maximum-gap%2F</url>
    <content type="text"><![CDATA[Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 解法1:基数排序12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2F2019%2F07%2F17%2F142.%20Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. 解法1双指针,快指针在前,慢指针在后.快指针一次走两步,慢指针一次走一步.如果链表无环,快指针一定先达到链表尾.否则,快指针比满指针走的快,快指针和慢指针一定会在链表上相遇. 找到快慢指针相遇的环中节点后,接下来要怎么找入环节点呢.我们知道快指针比慢指针快,如果要是能让快指针和慢指针在入环节点处相遇,那么需要快指针比慢指针多走一个环的长度的距离.当快指针和慢指针都在环上走时, 如果让慢指针先出发,当快指针赶上慢指针时,快指针正好比慢指针多走了一个环长的距离.所以,只需要让慢指针先走一个环的长度的距离,然后快指针和慢指针一起走,快指针来追赶慢指针,当慢指针赶上快指针时,正好是在入环节点上. 那么如何求环的长度呢?只需要一个指针从(快慢指针在环上相遇的节点)相遇节点出发, 再次回到该节点所需要走的步数就是环的长度. 为什么必须快指针在前,慢指针在呢?举个例子 如果链表是1-&gt;2-&gt;3.如果初始化时,慢指针在前,指向节点2, 快指针在后,指向1,那么快指针会赶上慢指针,即快慢指针会在节点3相遇,那么结束条件就不能是快指针和慢指针是否相遇.如果如上所示,即使没环,快慢指针也会在节点3处相遇.]]></content>
      <categories>
        <category>leetcode</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[71. Simplify Path]]></title>
    <url>%2F2019%2F07%2F17%2F71.Simplify-Path%2F</url>
    <content type="text"><![CDATA[题目描述Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path. Example 1: 123Input: &quot;/home/&quot;Output: &quot;/home&quot;Explanation: Note that there is no trailing slash after the last directory name. Example 2: 123Input: &quot;/../&quot;Output: &quot;/&quot;Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: 123Input: &quot;/home//foo/&quot;Output: &quot;/home/foo&quot;Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: 12Input: &quot;/a/./b/../../c/&quot;Output: &quot;/c&quot; Example 5: 12Input: &quot;/a/../../b/../c//.//&quot;Output: &quot;/c&quot; Example 6: 12Input: &quot;/a//b////c/d//././/..&quot;Output: &quot;/a/b/c&quot; # 解法1 思路：一次取出path中不等于//的部分（表示的是目录），若该部分是..，表示返回上级目录，若此时不在根目录下则有上级目录可以返回，则返回上级目录，即删除当前的目录。若该部分是.，表示当前目录，则什么也不做。否则，将新的目录加入到当前路径中（这里用vector来存储当前路径中的所有目录名）。最后将整个目录用/连接起来。另外，这里的根目录是隐含的，没有在初始化路径时加入到vector中，这是因为我们知道当前路径中的第一个目录一定是根目录。 注意：vector等的size()都是无符号数，无符号数都大于等于0，无符号数与有符号数做减法时不会产生负数，而是会变成一个很大的整数。参见：c++数据类型基础知识 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string simplifyPath(string path) &#123; if(path.empty() || path[0]!='/')&#123; return ""; &#125; vector&lt;string&gt; vec; int i=1; while(i &lt; path.size())&#123; int j=i; while(j &lt; path.size() &amp;&amp; path[j]=='/')&#123; ++j; &#125; i = j; while(j &lt; path.size() &amp;&amp; path[j]!='/')&#123; ++j; &#125; if(i &lt; j)&#123; string tmp = path.substr(i, j-i); if(tmp == "..")&#123; if(!vec.empty())&#123; vec.pop_back(); &#125; &#125;else if(tmp !=".")&#123; vec.push_back(tmp); &#125; &#125; i = j; &#125; string res = "/"; i = 0; while(vec.size() &gt; 1 &amp;&amp; i &lt; vec.size()-1)&#123; res += vec[i]; res += "/"; ++i; &#125; if(!vec.empty())&#123; res += vec[vec.size()-1]; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度为为O(n)，只从左到右扫描了整个路径字符串一遍。空间复杂度为O(n)，使用了一个vector来存储路径。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[62. Unique Paths]]></title>
    <url>%2F2019%2F07%2F17%2F62.%20Unique%20Paths%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 本题很简单,只需要在暴力搜索的基础上加上计划化搜索就行.这里不再赘述思路,详情请见代码. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m &lt;= 0 || n &lt;= 0)&#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n, -1)); return dfs(m, n, 0, 0, res); &#125; int dfs(int m, int n, int posx, int posy, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(res[posx][posy] != -1)&#123; return res[posx][posy]; &#125; if(posx == m - 1 &amp;&amp; posy == n-1)&#123; res[posx][posy] = 1; return 1; &#125; int s1, s2; if(posx +1 &lt; m)&#123; s1 = res[posx+1][posy] == -1 ? dfs(m, n, posx + 1, posy, res) : res[posx+1][posy]; &#125;else&#123; s1 = 0; &#125; if(posy + 1 &lt; n)&#123; s2 = res[posx][posy+1] == -1 ? dfs(m, n, posx, posy +1, res) : res[posx][posy+1]; &#125;else&#123; s2 = 0; &#125; res[posx][posy] = s1 + s2; return s1 + s2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F07%2F17%2F19.%20Remove%20Nth%20Node%20From%20End%20of%20List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 两趟算法一趟算法用两个指针，一个快指针先走n+2步．指向第n+2个节点．随后慢指针也从头节点出发，两个指针一起向前走．当快指针到达链表尾后节点时，慢指针指向的节点和尾后节点之间隔着n个节点，即慢指针指向倒数第n+1个节点．这时候只需要删除慢指针指向的下一个节点即可．有几种情况需要考虑： 当链表中的总节点个数少于n个．无法删除倒数第n个节点． 当链表中的总结点个数等于n个．要被删除的正好是头结点． 当链表中的总结点个数大于n个．删除倒数第n个节点． 首先让快指针先走，要么走到第n+2个节点，要么走到尾后节点．快指针先走之后，通过判断快指针共走过的节点个数来分情况处理．若快指针共走过k个节点(包括最后一个尾后空节点) 若k&lt;=n，说明链表中节点个数少于n，快指针走过的节点中包括了尾后节点(空节点) 若k==n+1，说明链表中节点个数为n，要删除的正是头结点 若k==n+2，说明链表中至少有n+1个非空节点，可以删除倒数第n个节点． AC代码 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 题目链接 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str == nullptr || pattern == nullptr)&#123; return false; &#125; return matchCore(str, pattern); &#125; bool matchCore(char *str, char* pattern)&#123; if(*str == '\0' &amp;&amp; *pattern == '\0')&#123; return true; &#125; if(str != '\0' &amp;&amp; pattern == '\0')&#123; return false; &#125; if(*(pattern+1)=='*')&#123; if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0'))&#123; return matchCore(str + 1, pattern + 2) // *匹配1个前向字符, 如a*b匹配aab || matchCore(str + 1, pattern) // *匹配多个前向字符, 如a*b匹配aaab || matchCore(str, pattern + 2);// *匹配0个前向字符， 如a*b 匹配ab &#125; return matchCore(str, pattern + 2); // *str与*pattern不等，*匹配0个前向字符 &#125; if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0')) //当前字符的下一个字符不是* return matchCore(str + 1, pattern + 1); return false; &#125;&#125;; 相似题目: Simplify Path]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包管理工具aptitude]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7aptitude%2F</url>
    <content type="text"><![CDATA[来自百度百科的介绍 aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 之所以要来说一说这个包管理工具，是因为在ubuntu中安装软件的时候经常遇到依赖未安装的问题．每次遇到这种情况，就需要包管理工具来帮忙了．]]></content>
      <tags>
        <tag>liunx系统</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序和计数排序]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[比较排序,例如归并排序, 堆排序, 快速排序等等. 在比较排序中, 各元素的次序依赖于它们之间的比较.任何比较排序在最坏情况下都要经过O(nlogn)次比较. 桶排序假设输入数据服从均匀分布, 平均情况下它的时间代价为O(n). 与计数排序类似,因为对输入数据做了某种假设, 桶排序的速度也很快.具体来说,计数排序假设数据都属于一个小区间内的整数, 而桶排序假设输入是由一个随机过程产生,该过程将元素均匀,独立地分布在[0,1]区间内.桶排序将[0,1]区间划分为n个相同大小的子区间, 或称为桶.然后将n个输入数分别放在各个桶中.因为输入数据是均匀,独立地分布在[0,1]区间上,所以一般不会出现很多数落在同一个桶中的情况.为了得到输出结果, 先对每个桶中的数进行排序,然后遍历每个桶,按照次序将各个桶中的元素列出来即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344void bucketSort1(vector&lt;int&gt; &amp;nums, int bucketSize) &#123; if (nums.size() &lt; 2) &#123; return; &#125; vector&lt;vector&lt;int&gt;&gt; help(nums.size(), vector&lt;int&gt;(0)); int i; int maxVal, minVal; maxVal = nums[0]; minVal = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; minVal) &#123; minVal = nums[i]; &#125; else if (nums[i] &gt; maxVal) &#123; maxVal = nums[i]; &#125; &#125; int bucketCount = (maxVal - minVal) / bucketSize + 1; vector&lt;vector&lt;int&gt;&gt; buckets(bucketCount, vector&lt;int&gt;(0)); for (int i = 0; i &lt; nums.size(); ++i) &#123; int index = (nums[i] - minVal) / bucketSize;// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; nums[i] &lt;&lt; " index:" &lt;&lt; index &lt;&lt; endl; buckets[index].push_back(nums[i]); &#125; int arrIndex = 0; for (int i = 0; i &lt; buckets.size(); ++i) &#123; if (buckets[i].empty()) &#123; continue; &#125; insectionSort(buckets[i]); // cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个桶中:";// for (int j = 0; j &lt; buckets[i].size(); ++j) &#123;// cout &lt;&lt; buckets[i][j] &lt;&lt; " ";// &#125;// cout &lt;&lt; endl; for (int value : buckets[i]) &#123; nums[arrIndex++] = value; &#125; &#125;&#125; 另一种与桶排序相关的排序方法. 12345678910111213141516171819202122232425262728293031323334// max是数组中元素的最大值, 数组中的元素都在0-max之间void bucketSort(vector&lt;int&gt; &amp;arr, int max) &#123; int i, j; vector&lt;int&gt; buckets(max, 0); // 桶数组,所有 if (arr.empty() || max &lt; 1) &#123; return; &#125; for (int i = 0; i &lt; arr.size(); ++i) &#123; buckets[arr[i]]++; &#125; // bucket[i]表示数组arr中等于i的元素个数 for (int i = 0, j = 0; i &lt; maxVal; ++i) &#123; // 当数组arr中等于i的元素个数不为0,就把元素i加入到原来的数组arr中 while ((buckets[i]--) &gt; 0) &#123; arr[j++] = i; &#125; &#125;&#125;void testBucketSort() &#123; vector&lt;int&gt; arr = &#123;8, 2, 3, 4, 3, 6, 6, 3, 9&#125;; for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; bucketSort(arr, 10); for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 计数排序计数排序假设n个输入元素的每一个都是在0-k区间内的一个整数,其中k为某个整数.计数排序的基本思想:对于每一个输入元素x, 确定小于x的元素个数,.利用这一信息,就可以直接把x放在它在输出数组中的位置上了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445void countingSort(vector&lt;int&gt; &amp;nums) &#123; if (nums.size() &lt; 2) &#123; return; &#125; int maxVal = -2147483648; for (int i = 0; i &lt; nums.size(); ++i) &#123; maxVal = maxVal &gt; nums[i] ? maxVal : nums[i]; &#125; vector&lt;int&gt; count(maxVal + 1, 0); // count[i]表示数组nums中等于i的元素个数 for (int i = 0; i &lt; nums.size(); ++i) &#123; ++count[nums[i]]; &#125; // count[i]表示数组nums中小于等于i的元素个数 for (int i = 1; i &lt; count.size(); ++i) &#123; count[i] += count[i - 1]; &#125; vector&lt;int&gt; aux(nums.size()); for (int i = 0; i &lt; nums.size(); ++i) &#123; // count[nums[i]]表示数组nums中小于等于nums[i]的元素个数,因此count[nums[i]]也就是nums[i]在排序后数组中的位置// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; nums[i] &lt;&lt; " count:" &lt;&lt; count[nums[i]] &lt;&lt; endl; aux[--count[nums[i]]] = nums[i]; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; nums[i] = aux[i]; &#125; cout &lt;&lt; endl;&#125;void testcountingSort() &#123;// vector&lt;int&gt; nums&#123;2, 1, 2, 4, 5&#125;; vector&lt;int&gt; nums&#123;5, 4, 3, 2, 2, 4, 1&#125;; for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; countingSort(nums); for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 基数排序假设n个d位的元素存放在数组A中, 其中第1位是最低位, 第d位是最高位. 123radixSort(A, d) for i = 1 to d use a stable sort to sort array A on digit i]]></content>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是堆我们面临的第一个问题是：什么是堆？ 堆可以定义为一颗二叉树，树的节点中包含键，并且满足两个条件：１．该二叉树是完全二叉树．除了最后一层，树的每一层都是满的．２．父母优势：(以最大堆为例)父节点的键大于或等于孩子节点的键 可以用数组来实现堆． 如何构造一个堆自底向上构造堆 从最后一个非叶节点开始，检查该节点是否满足父母优势．如果不满足，就将该节点与最大孩子节点的键交换，然后再检查新的位置．这个过程持续到被检查节点满足父母优势为止(叶子节点自动满足父母优势)．此过程从最后一个非叶节点一直持续到根节点．最后一个非叶节点：假设堆中有n个节点，则最后一个非叶节点为(n/2)向下取整．例如，n=7,最后一个非叶节点为３. 调整一个堆成为最大堆将以k为根的子树调整为一个堆的过程可以简单描述如下：查看k的孩子节点中是否存在比k大的，如果不存在说明以k为根的子树已经是一个最大堆了（这里存在一个假设：在调整以k为根的子树时，以k的左右孩子节点为根的子树都已经是堆了）．否则，交换k和孩子节点中较大的那个（无论两个孩子节点是否都满足大于k），假设此新节点为n，接下来就是调整以n为根节点的子树了．显然，这就是重复上面的过程，那么这个过程应该持续到什么时候结束呢？答案是到k已经是叶子节点或者没有孩子节点都比它小了． 非递归方式 12345678910111213141516max_heapify_iter(H[1,...,n], k) // 输入：H[1,..,n]是一个数组，表示一个完全二叉树 // k：当前要调整的节点K // 输出：以节点i为根的二叉树调整为一个堆 k = i, v = H[k] // K是当前需要检查的节点 heap = false // 状态变量，表示当前要检查的节点是否满足父母优势 while not heap and 2 * k &lt;= n // 当要检查的节点不满足父母优势且不是叶子节点 j = 2 * k if j &lt; n // 被检查节点有两个孩子节点 if H[j + 1] &gt; H[j] j = j + 1 if v &gt;= H[j] heap = true else H[k] = H[j] // 交换被检查的节点和它最大孩子节点的键 k = j // 继续检查被交换后的最大孩子节点的键 递归方式 123456789101112131415max_heapify_recur(A, i) // 输入：A[1,..,n]是一个数组，表示一个完全二叉树 // i：当前要调整的节点i // 输出：以节点i为根的二叉树调整为一个堆 l = 2 * i // 节点i的左孩子2 * i r = 2 * i + 1 // 节点i的左孩子2 * i + 1 if l &lt;= n and A[l] &gt;= A[i] largest = l else largest = i if r &lt;= n and A[r] &gt;= A[largest] largest = r if largest != i exchange(A[i], A[largest]) max_heapify(A, largest) 建堆非递归方式 123456HeapBottomUp(H[1,...,n]) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组H[1,...,n] // 输出：一个堆H[1,...,n] for i = [n/2] to 1 do max_heapify_iter(H, i) 递归方式 123456build_max_heap(A) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个堆A[1,...,n] for i = n/2 to 1 do // n/2向下取整 max_heapify_recur(A, i) 堆的用处我们都知道使用堆排序算法可以实现一个优化队列．这其实又是另外一个故事了． 堆排序第一步，堆排序首先构造堆，为一个给定的数组构造一个堆．时间复杂度为O(n) 建堆时间复杂度分析： 第二步，从堆中删除最大键，持续此动作n-1次．时间复杂度为O(nlogn) 删除最大键并调整堆的时间复杂度分析： 堆排序的时间效率是O(nlogn)，但是堆排序是原址排序，不需要任何额外的存储空间．堆排序比快速排序运行得慢，但是比合并排序快． 12345678heap_sort(A) // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个排好序的数组A heap_size = n for i = n to 2 exchange(A[i], A[1]) --heap_size; max_heapify_iter(A, 1) // 调整以节点１为根，大小为heap_size的数组为最大堆]]></content>
      <tags>
        <tag>堆数据结构</tag>
        <tag>优先队列</tag>
        <tag>最小堆，最大堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9A%84%E5%BB%B6%E4%BC%B8%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[类的５大控制成员]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%B1%BB%E7%9A%84%EF%BC%95%E5%A4%A7%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[基础概念拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数． 拷贝初始化通常由拷贝构造函数来完成．但是如果一个类有一个移动构造函数，则拷贝初始化会使用移动构造函数而非拷贝构造函数来完成．总之，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的． 合成的拷贝构造函数与默认构造函数不同, 即使类中存在其他构造函数, 编译也会自动合成一个拷贝构造函数.合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中,编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中. 每个成员的类型决定了它如何拷贝:对于类类型成员,会使用其拷贝构造函数来拷贝;内置类型的成员直接拷贝. 虽然数组不能直接拷贝,但是合成拷贝构造函数会逐元素地拷贝一个数组类型的成员.如果数组元素是类类型,则使用元素的拷贝构造函数来进行拷贝. 直接初始化和拷贝初始化直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数.使用拷贝初始化则要求编译器将右侧运算对象拷贝到我们正在创建的对象中.如果必要的话还需要进行类型转换.拷贝初始化要么通过拷贝构造函数,要么通过移动构造函数完成.拷贝初始化在以下情况下发生： 当我们用=定义变量时将一个对象作为实参传递给一个引用类型的形参从一个返回类型为非引用类型的函数返回一个对象用花括号列表初始化一个数组中的元素或一个聚合类中的成员 拷贝赋值运算符赋值运算符返回一个指向其左侧运算对象的引用． 析构函数构造函数初始化对象的非static数据成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员．在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁． 移动构造函数移动赋值运算符关联以上五个函数统称为拷贝控制操作．各个拷贝控制操作之间的关系是：通常如果一个类需要一个析构函数，那么它也需要一个拷贝构造函数和一个拷贝赋值运算符．但需要拷贝或赋值操作时，不一定需要析构函数．如果一个类需要一个拷贝构造函数，那么它也需要一个拷贝构造函数．]]></content>
      <tags>
        <tag>c++ 类基础知识</tag>
        <tag>c++ premiere 5th</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在数组中找到出现次数大于n/k的数]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8Enk%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这道题十分重要，有诸多解法，且用到许多不同的思想。 在数组中找到出现次数超过n/2的数暴力破解排序法在数组找到出现次数大于n/k的数在数组中找到出现次数大于n/3的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if(nums.empty())&#123; return res; &#125; map&lt;int, int&gt; mp; // cand for(int i=0;i&lt;nums.size();i++)&#123; if(mp.find(nums[i]) == mp.end())&#123; mp[nums[i]] = 1; &#125;else&#123; ++mp[nums[i]]; &#125; if(mp.size() == 3)&#123; allMinusOne(mp); &#125; &#125; map&lt;int,int&gt; counter; countElem(nums, mp, counter); for(auto it=mp.begin();it!=mp.end();it++)&#123; int num = it-&gt;first; if(counter[num]&gt;(nums.size()/3))&#123; res.push_back(num); &#125; &#125; return res; &#125; void allMinusOne(map&lt;int,int&gt; &amp;mp)&#123; auto it= mp.begin(); while(it!=mp.end())&#123; if(it-&gt;second==1)&#123; it = mp.erase(it); &#125;else&#123; --it-&gt;second; it++; &#125; &#125; &#125; void countElem(vector&lt;int&gt;&amp; nums, map&lt;int,int&gt;&amp; mp,map&lt;int,int&gt;&amp; counter)&#123; for(auto num:nums)&#123; if(mp.find(num)!=mp.end())&#123; if(counter.find(num)==counter.end())&#123; counter[num] = 1; &#125;else&#123; ++counter[num]; &#125; &#125; &#125; &#125;&#125;; c++中map的find方法查找一个键的时间复杂度为O(logn)]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F07%2F10%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚函数]]></title>
    <url>%2F2019%2F07%2F08%2F%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数与纯虚函数虚函数基类希望派生类进行覆盖的函数．当我们使用指针或引用调用虚函数时，该调用将被动态绑定．更具体而言，使用基类的引用或指针调用一个虚成员函数时会执行动态绑定．只有使用引用更或者指针调用虚函数时才会发生动态绑定．每一个虚函数都必须提供定义，无论是否用到． 纯虚函数纯虚函数无须定义；可以为纯虚函数提供定义，但是函数体必须定义在类的外部．含有纯虚函数的类是抽象基类，无法被实例化． 静态类型与动态类型一个变量或表达式的静态类型与该表达式表示对象的动态类型必须区分开来．表达式的静态类型和动态类型比较 静态类型 动态类型 变量声明时的类型或表达式生成的类型 变量或表达式表示的内存中的对象的类型 编译时已知 运行时才知道 指针或引用的静态类型和动态类型可能不一致；若表达式既不是引用也不是指针，则它的动态类型和静态类型一致．]]></content>
      <tags>
        <tag>虚函数</tag>
        <tag>动态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[静态内存用来保存局部静态对象,类静态数据成员以及定义在任何函数之外的变量.栈内存用来保存定义在函数内的非static对象.分配在静态或栈内存的对象由编译器自动创建和销毁. 栈对象在其定义的程序块运行时才存在;静态对象在使用之前分配,在程序结束时销毁.堆用来存储动态分配的对象, 即在程序运行时分配的对象.动态对象的生命期由程序控制.也就是说,当动态对象不再使用时,必须在代码中显式地销毁它们.c++动态内存的管理由一对运算符new和delete来完成.new在动态内存中为对象分配空间并返回一个指向该对象的指针.delete:接受一个动态对象的指针,销毁该对象,并释放该对象占用的内存. 常规指针的缺陷如果忘记了释放内存,就会导致内存泄露.如果在还有指针引用内存的情况就释放了内存会产生引用非法内存的指针. 智能指针与常规指针的区别在于, 智能指针是类类型, 在离开作用域时会自动调用析构函数, 自动释放内存. 程序使用动态内存的原因 原因 例子 程序不知道自己需要使用多少对象 容器类 程序不知道所需对象的准确类型 动态绑定 程序需要在多个对象间共享数据 strBlob类 shared_ptr: 多个指针可以指向同一个对象.使用引用计数来记录该对象的资源被多少个指针共享.当引用计数为0时, 资源自动释放. unique_ptr:同一时刻只能有一个unique_ptr指向一个给定对象.unique_ptr独占对象的资源.unique_ptr不支持普通的拷贝和赋值.可以通过release和reset将指针的所有权从一个unique_ptr转移到另一个unique_ptr. weak_ptr:不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象.将一个weak_ptr绑定到一个shared_ptr不会改变该shared_ptr的引用计数.因此, weak_ptr指向的对象可能被释放掉.]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分查找各种不同的应用场景]]></title>
    <url>%2F2019%2F07%2F01%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[从有序数组中大于等于某个数的元素第一次出现的位置 123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出大于某个值的元素第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例: 1234[1, 3, 3, 3, 3] // 1, 元素3(最早出现的元素3)[1, 2, 4, 5, 6] // 2, 元素4[1, 2, 2, 2, 2] // -1, 所有元素都比3小[4, 5, 6, 9, 12] // 0, 所有元素都比3大 从有重复元素的有序数组中找出某个元素第一次出现的位置123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出某个值第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例 123[1, 3, 3, 3, 3] // 1, 第一个元素3[-1, 1, 2, 3, 5] //3, 元素3[1, 2, 4, 5, 6] // -1, 不存在元素3 题目https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/]]></content>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未排序数组中累加和为给定值的最长子数组系列问题]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原题给定一个无序数组,其中元素可正,可负,可0.给定一个整数k,求arr所有的子数组中累加和为k的最长子数组长度. 12345678910111213141516171819int maxLength(vector&lt;int&gt; &amp;arr, int k) &#123; if (arr.empty()) &#123; return 0; &#125; map&lt;int, int&gt; mp; mp[0] = -1; int len = 0; int sum = 0; for (int i = 0; i &lt; arr.size(); i++) &#123; sum += arr[i]; if (mp.find(sum - k) != mp.end()) &#123; len = max(len, i - mp[sum - k]); &#125; if (mp.find(sum) == mp.end()) &#123; mp[sum] = i; &#125; &#125; return len;&#125; 补充题1补充题2类似题138. 子数组之和给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置 样例 样例 1: 123输入: [-3, 1, 2, -3, 4]输出: [0,2] 或 [1,3] 样例解释： 返回任意一段和为0的区间即可。 样例 2: 12输入: [-3, 1, -4, 2, -3, 4]输出: [1,5] 样例 3: 12输入: [3,4,5,6,-3,-4,-5,-6]输出: [0,7] 样例 4: 12输入: [1,0,-1]输出: [1,1] 注意事项: 至少有一个子数组的和为 0 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * @param nums: A list of integers * @return: A list of integers includes the index of the first number and the index of the last number */ vector&lt;int&gt; subarraySum(vector&lt;int&gt; &amp;nums) &#123; // write your code here if(nums.empty())&#123; return &#123;&#125;; &#125; int sum = 0; vector&lt;int&gt; res; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();++i)&#123; sum += nums[i]; if(sum == 0)&#123; res.push_back(0); res.push_back(i); return res; &#125; if(mp.find(sum)!=mp.end())&#123; res.push_back(mp[sum]+1); res.push_back(i); return res; &#125; mp[sum] = i; &#125; return res; &#125;&#125;; 此题与上题的相似之处在于:需要用到相同的结论:s[i]= arr[0] + arr[1] +…+arr[i]s[j]= arr[0] + arr[1] +…+arr[j]假设i &gt; j,则s[i] - s[j] = arr[j+1] + arr[j+2] + … + arr[i] 复杂度分析 理论上, 时间复杂度为O(n).但实际实现时,时间复杂度为O(nlogn).因为map的find方法查找一个数的时间复杂度为O(logn)空间复杂度为O(n) 题目来源: leetcode 560. Subarray Sum Equals K930 binary subarrays with sum另有使用三指针的解法,可以尝试看看试用否,三指针解法时间复杂度为O(n),空间复杂度为O(1),是最优解法]]></content>
      <tags>
        <tag>累积和</tag>
        <tag>leetcode</tag>
        <tag>程序员代码面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中数字出现的次数]]></title>
    <url>%2F2019%2F06%2F06%2F%E6%89%BE%E5%87%BA%E7%8E%B0%E4%BB%85%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[数组中只出现一次的数一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。题目来源：剑指offer 56 123456789101112131415161718192021222324252627282930313233unsigned int findFirstBitIs1(int num) &#123; int indexBit = 0; while (((num &amp; 1) == 0) &amp;&amp; (indexBit &lt; 8 * sizeof(int))) &#123; num = num &gt;&gt; 1; ++indexBit; &#125; return indexBit;&#125;bool IsBit1(int num, unsigned int indexBit) &#123; num = num &gt;&gt; indexBit; return (num &amp; 1);&#125;void findNumsAppearOnce(vector&lt;int&gt; data, int *num1, int *num2) &#123; if (data.size() &lt; 2) &#123; return; &#125; int resultExclusiveOR = 0; for (int i = 0; i &lt; data.size(); i++) &#123; resultExclusiveOR ^= data[i]; &#125; unsigned int indexOf1 = findFirstBitIs1(resultExclusiveOR); *num1 = *num2 = 0; for (int i = 0; i &lt; data.size(); i++) &#123; if (IsBit1(data[i], indexOf1)) &#123; *num1 ^= data[i]; &#125; else &#123; *num2 ^= data[i]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>剑指offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变形词]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8F%98%E5%BD%A2%E8%AF%8D%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[此类题比较麻烦，但其实并不难。 242. Valid Anagram49. Group Anagrams找出可以通过改变一个字母变成其他单词的单词许多单词都和另外一些单词想死。例如，通过改变第1个字母，单词wine可以变成dine，fine，line，mine，pine或vine。通过改变第3个字母可以变成wide，wife，wipe或wire以及其他一些单词。通过改变第4个字母可以变成wind，wing，wink或wins以及其他一些单词。我们想要编写一个程序来找出通过单个字母的替换变成至少15个其他单词的单词。假设有一本字典，由大约89000个各种长度的不同单词组成。大部分单词在6到11个字母之间。其中6字母单词8205个，7字母单词11989个，8字母单词13672个，9字母单词13014个，10字母单词11297个，11字母单词8617个。题目来源：数据结构与算法分析(c++语言描述，第4版) p144。]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的最大值]]></title>
    <url>%2F2019%2F06%2F06%2F%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[队列的最大值 Sliding Window Maximum Hard Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 涉及知识点：最小栈，如何用两个队列实现一个栈， 双端队列。 c++ deque基本操作123456void push_front(const T&amp; x) //双端队列头部增加一个元素Xvoid push_back(const T&amp; x) //双端队列尾部增加一个元素xvoid pop_front() //删除双端队列中最前一个元素void pop_back() //删除双端队列中最后一个元素reference front() //返回首元素的引用reference back() //返回尾元素的引用 解法1解法2]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集基础知识]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集(不相交集合)不相交集合数据结构是这样一种数据结构: 它维护了一个不相交动态集的集合 $$S = {s_1, s_2, …, s_i, …, s_k}$$对于每个集合S中的每个元素集合si而言,用集合中的而一个元素来代表该集合.假设x是集合si中的一个元素,则有以下三种操作: make_set(x): 建立一个新的集合,它的唯一成员是x.因为各个集合是不相交的集合, 所以x不会出现在别的集合中.union(x, y): 将包含x和y的两个动态集合(表示为sx和sy合并成一个新的集合, 即这两个集合的并集)find_set(x): 返回一个指针,该指针指向包含x的(唯一)集合的代表.不相交集合可以用于求无向图的连通分量等.待后续加上代码 为了提交效率,建立并查集的过程往往会采用两种策略来提高性能.一种是按秩(秩是指节点高度的一个上界)合并, 另一种是路径压缩.按秩合并是在合并两个集合的过程中, 让具有较小秩的根指向较大秩的根.路径压缩是在查找节点的根节点的过程中, 使查找路径上的每个节点指向指向根(即令根节点成为查找路径上每个节点的父节点). 节点x的秩: 节点x的高度(从节点x到某一后代叶节点的最长简单路径上边的数目)的一个上界.当make_set(x)创建一个单元素x集合时, 节点x的秩为0.使用按秩合并union(x, y)合并两个集合时, 若两个集合的秩不同,则让较大秩的根成为较小秩的根的父节点, 秩本身保持不变.若两个集合的秩相同,则任意选择两个根中的一个作为父节点, 并使它的秩加1. 并查集的实现(伪代码)123456789101112131415161718make_set(x) x.p = x // x的父节点是自己,即x是x所在集合的根节点 x.rank = 0 // x.rank即x的秩link(x, y) if(x.rank &gt; y.rank) y.p = x else x.p = y if(x.rank == y.rank) y.rank = y.rank + 1union(x, y) link(find_set(x), find_set(y))find_set(x) if x != x.p x.p = find_set(x.p) return x.p find_set的非递归形式 12345678find_set(x) a = x while x != x.p x = x.p while a != a.p z = a a = a.p z.p = x]]></content>
      <tags>
        <tag>基础算法</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序链表转成二叉搜索树系列]]></title>
    <url>%2F2019%2F06%2F05%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[将有序数组转换成二叉搜索树 Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 1234567891011121314151617class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = sortedArrayToBSTCore(nums, 0, nums.size()-1); return root; &#125; TreeNode* sortedArrayToBSTCore(const vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; if(lo &gt; hi)&#123; return nullptr; &#125; int mid = (lo + hi) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = sortedArrayToBSTCore(nums, lo, mid - 1); root-&gt;right = sortedArrayToBSTCore(nums, mid + 1, hi); return root; &#125;&#125;; 将二叉搜索树的根节点传引用进入建立二叉搜索树的函数和返回二叉搜索树的头结点的两种方法，后者更快，但是前者更好理解。 时间复杂度为O(logn)。 将有序链表转换成二叉搜索树 Convert Sorted List to Binary Search Tree Medium Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解法1：递归二叉搜索树的性质：左子树上所有节点的值都小于等于根节点的值，右子树上所有节点的值都大于等于根节点的值。一棵二叉搜索树的左子树和右子树都是二叉搜索树。 给定有序中的中间元素形成二叉搜索树的根节点。根节点左边的节点递归地形成左子树，根节点右的节点递归地形成右子树。这保证了二叉搜索树是平衡的。 思路：首先用快慢双指针找到根节点，然后递归地形成左子树和右子树。 AC代码1 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head == mid)&#123; return root; &#125; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向尾节点 return slow; &#125;&#125;; AC代码2 12345678910111213141516171819202122232425262728293031class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head != mid)&#123; // 当mid不指向链表中的第一个元素时，即左子树上还有节点时 root-&gt;left = sortedListToBST(head); &#125; root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head == nullptr ? nullptr : head-&gt;next; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向头节点 return slow; &#125;&#125;; 两种AC代码的唯一一点小差别在与，寻找中间节点时，当链表中有两个节点时，第一种AC代码返回的是尾节点，而第二种代码返回的是头节点。 时间复杂度为O(nlongn)。假设链表中有n个元素。寻找中间元素需要线性遍历链表，slow指针需要从头节点移动到中间节点，时间复杂度为O(n)。接下来规模为n问题变成两个规模为n/2的子问题。因此，时间复杂度递推公式为:T(n) = O(n) + 2 * T(n/2)最后的时间复杂度为O(nlogn)。空间复杂度为O(logn)。 解法2：转成有序数组 先将有序链表转成有序数组，然后使用第一题的解法解决。 时间复杂度为O(n)。空间复杂度为O(n)。 解法3：中序模拟此解法基于这一事实：二叉搜索树的中序便利序列是有序的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int findSize(ListNode* head)&#123; ListNode* node = head; int c = 0; while(node!=nullptr)&#123; node = node-&gt;next; c += 1; &#125; return c; &#125; TreeNode* convertListToBST(ListNode*&amp; head, int l,int r)&#123; if(l &gt; r)&#123; return nullptr; &#125; int mid = (l + r) / 2; TreeNode* left = convertListToBST(head, l, mid - 1); TreeNode* node = new TreeNode(head-&gt;val); node-&gt;left = left; head = head-&gt;next; node-&gt;right = convertListToBST(head, mid + 1, r); return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; int size = findSize(head); return convertListToBST(head, 0, size - 1); &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(logn)。]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>binary Tree</tag>
        <tag>有序链表</tag>
        <tag>二叉搜索树</tag>
        <tag>有序数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找下一个节点]]></title>
    <url>%2F2019%2F06%2F03%2F%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链接： https://www.nowcoder.com/questionTerminal/60231d6931d543d4aadcb67851b21e4a 请设计一个算法，寻找二叉树中指定结点的下一个结点（即中序遍历的后继）。 给定树的根结点指针TreeNode* root和结点的值int p，请返回值为p的结点的后继结点的值。保证结点的值大于等于零小于等于100000且没有重复值，若不存在后继返回-1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题目链接:https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e 相关题目:寻找下一个节点]]></content>
      <tags>
        <tag>牛客网</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
</search>
