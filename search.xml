<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSL/TLS与https]]></title>
    <url>%2F2019%2F10%2F19%2FSSLTLS%E4%B8%8Ehttps%2F</url>
    <content type="text"><![CDATA[加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。 在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。双钥加密的原理如下：a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。b) 所有的（公钥, 私钥）对都是不同的。c) 用公钥可以解开私钥加密的信息，反之亦成立。d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。 数字签名是什么鲍勃有两把钥匙，一把是公钥，另一把是私钥。鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。鲍勃将这个签名，附在信件下面，一起发给苏珊。苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书“（Digital Certificate）。鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 在双钥体系中，公钥用来加密信息，私钥用来数字签名。 客户端如何获取证书中心的公钥？服务端如何拿到自己的数字证书？为什么不必担心CA的公钥被被人偷偷替换？ 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 SSL/TLS协议运行机制的概述基本的运行过程SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。但是，这里有两个问题。 （1）如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 （2）公钥加密计算量太大，如何减少耗用的时间？ 解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： （1） 客户端向服务器端索要并验证公钥。（2） 双方协商生成”对话密钥”。（3） 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。”握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 客户端发出请求（ClientHello） 首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息。 （1） 支持的协议版本，比如TLS 1.0版。（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。（3） 支持的加密方法，比如RSA(双钥加密算法)公钥加密。（4） 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。 服务器回应（SeverHello） 服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。 （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。（3） 确认使用的加密方法，比如RSA公钥加密。（4） 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应 客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 服务器的最后回应 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 参考文献[1]公钥、私钥、加密：http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html[2]数字签名是什么：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html[3]SSL/TLS协议运行机制的概述：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html[4]图解SSL/TLS协议：http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html[5]从 HTTP 到 HTTPS - 什么是 HTTPS：https://tasaid.com/Blog/20161003001126.html?sgs=sf1190000007064737[6]HTTPS工作原理：https://cattail.me/tech/2015/11/30/how-https-works.html]]></content>
      <categories>
        <category>安全基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP通信实例实现]]></title>
    <url>%2F2019%2F10%2F18%2FTCP%E5%92%8CUDP%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B1%2F</url>
    <content type="text"><![CDATA[首先实现一个简单的服务器端和客户端通信的小例子． TCP方式服务器端调用步骤： 调用socket函数创建套接字 调用bind函数分配IP地址和端口号 调用listen函数将套接字转为可接收连接状态 调用accept函数受理连接请求。如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止。 使用write函数用于向客户端传输数据。 客户端： 调用客户端创建套接字 TCP相关API创建socket函数原型如下： 1int socket(int domain, int type, int protocol) socket函数成功时返回一个文件描述符(见后续其他相关知识)，失败则返回-1. domain: 套接字中使用的协议族信息 PF_INET表示IPV4互联网协议族 type: 套接字数据传输类型信息 SOCK_STREAM表示面向连接的套接字 SOCK_DGRAM表示面向消息的套接字． 创建TCP套接字和UDP套接字： 12tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); protocol: 计算机间通信中使用的协议信息 描述socket 接下来代码描述socket文件，包括socket文件的大小，接受的内容等 1234memset(&amp;serv_addr, ０, sizeof(serv_addr));serv_addr.sin_family = AF_INET;serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);serv_addr.sin_port = htons(atoi(argv[1])); sin_family: 地址族 每种协议族适用的地址族不同．IPV4使用4字节地址族．IPV6使用16字节地址族． AF_INET IPV4网络协议中使用的地址族 AF_INET6 IPV6网络协议中使用的地址族 sin_port: 该成员保存16位端口号，它以网络字节序保存 sin_addr: 该成员保存32位IP地址信息，且也以网络字节序保存． 地址绑定给套接字分配地址信息（IP地址和端口号） 1int bind(int sockfd, struct sockaddr* myaddr, socklen_t addrlen); 成功时返回0,失败时返回-1.sockfd: 要分配地址(IP地址和端口号)的套接字文件描述符myaddr: 存有地址信息的结构体变量地址值addrlen: 第二个结构体变量的长度 监听 绑定了地址信息后，只需要最后一步接收来自客户的连接请求了．这就是让套接字变成监听状态，之后，只要客户端向服务器发送请求，服务器就可以接收到了．通过listen函数进入等待连接请求状态．只有调用了listen函数，客户端才能进入可发出连接请求的状态．换言之，这时客户端才能调用connect函数(若提前调用将发生错误)． 1int listen(int sock, int backlog); 成功时返回0,失败时返回-1.sock：希望进入等待连接请求状态的套接字文件描述符，传递的描述符套接字参数成为服务器端套接字(监听套接字)backlog: 连接请求等待队列的长度, 若为5，则队列长度为5,表示最多使5个连接请求进入队列． 等待连接请求状态： 服务端处于等待连接请求状态是指，客户端请求连接时，受理连接前一直使请求处于等待状态． 连接请求队列：允许的连接请求的客户端个数 接受连接函数原型如下： 1int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); sock: 服务器套接字的文件描述符 addr: 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息． addrlen: 第二个参数addr结构体的长度，但是存有长度的变量地址．函数调用完成后，该变量即被填入客户端地址长度． 返回值：accept函数成功时返回文件描述符，失败时返回-1 accept函数受理连接请求队列中待处理的客户端连接请求．函数调用成功时，accept函数内部将产生用于数据IO的套接字，并返回其文件描述符．套接字是自动创建的，并自动与发起连接请求的客户端建立连接 一个服务器端socket可以接收很多客户端的连接请求．当客户端发起连接请求时，服务器端需要调用accept函数受理客户端的请求．同时来自不同客户端的连接也会当成不同的socket文件，返回不同的文件描述符． connect1int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen); 功能：客户端调用connect函数后，发生以下情况之一才会返回(完成函数调用) 服务器接收连接请求 注意：接收连接请求并不意味着服务器调用accept函数，而是指服务器把连接请求信息记录到等待队列 所以，connect函数返回后并不立即进行数据交换 发生断网等异常情况而中断连接请求 sock: 客户端套接字文件描述符 servaddr: 保存目标服务端地址信息的变量地址值 addrlen: 以字节为单位传递已传递给第二个结构体参数servaddr的地址变量长度 read和write1ssize_t read(int fd, void* buf, size_t nbytes); 成功时返回接收的字节数(但遇到文件结尾则返回0)，失败时返回-1.fd: 显示数据接收对象的文件描述符．buf: 要保存接收数据的缓冲地址值．nbytes: 要接收数据的最大字节数． 1ssize_t write(int fd, const void* buf, size_t nbytes); 成功时返回写入的字节数，失败时返回-1.fd: 显示数据传输对象的文件描述符．buf: 要保存传输数据的缓冲地址值．nbytes: 要传输数据的最大字节数． freadsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 功能：从给定流 stream 读取数据到 ptr 所指向的数组中 ptr – 这是指向带有最小尺寸 size\nmemb* 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 fgets函数原型为：char *fgets(char *str, int n, FILE *stream) 功能：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。fgets会把读到字符写到s指向的字符串里，直到出现下面某种情况： 遇到换行符 已经传输了n-1个字节 到达文件尾 它会把遇到的换行符也保存到s中．最后在s末尾加上一个表示结尾的空字符\0．一次调用最多只能传输n-1个字符，因为它必须把空字符加到字符串表示结尾． gets函数类似于fgets，但是它从标准输入流中取数据并丢弃遇到的换行符．它在接收字符串的尾部加上一个空字节(一个字符占一个字节)． fgetcfgetc从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节。 fputc功能：把一个字符写到一个输出文件流中．它返回写入的值，如果失败，则返回EOF．putc函数的作用相当于fputc，但它可能被实现为一个宏．putchar相当于putc(c, stdout)，但它把单个字符写到标准输出．注意：putchar和getchar都是把字符当做int类型而不是char类型来使用的．这就允许文件尾标识取值-1，这是一个超出字符数字编码范围的值． fopenhttps://blog.csdn.net/hairetz/article/details/4150193 sigaction1sigaction(int signo, const sigaction* act, struct sigaction *oldact); 功能： signo：与signal函数相同，传递信号信息 act：对应于第一个参数的信号处理函数(信号处理器)信息 oldact：通过此参数获取之前注册的信号处理函数指针，若不需要则传递0 返回值：成功时返回0,失败时返回-1 UDP方式服务端：客户端： UDP相关APITCP套接字将会保持与对方套接字的连接。换言之，TCP套接字知道目标地址信息。但UDP套接字不会保持连接状态，因此每次传输数据都要添加目标地址信息。 sendto12#include&lt;sys/socket.h&gt;ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr* to, socklen_t addrlen); 功能：返回值：成功时返回传输的字节数，失败时返回-1。sock：用于传输数据的UDP套接字文件描述符。buff：保存待传输数据的缓冲地址值。nbytes：待传输的数据长度，以字节为单位。flags：可选项参数，若没有则传递0。to：存有目标地址信息的sockaddr结构体变量的地址值。addlen：传递给参数to的地址值结构体变量长度。这个函数在发送端主机上被调用，而发送数据的UDP套接字只有在发送端主机才有意义。 recvfrom12#include&lt;sys/socket.h&gt;ssize_t recvfrom(int sock, void* buff, size_t nbytes, int flags, struct sockaddr* from, socklen_t *addrlen); 返回值：成功时返回接收的字节数，失败时返回-1。sock：用于接收数据的UDP套接字文件描述符。buff：保存接收数据的缓冲地址值。nbytes：可接收的最大字节数，故无法超过参数buff所指的缓冲区大小。flags：可选项参数，若没有则传入0。from：存有发送端地址信息的sockaddr结构体变量的地址值。addlen：保存参数from的结构体变量长度的变量地址值。 其他相关知识 文件描述符 对linux来说，一切皆文件．套接字和本地的文件都是文件． 文件描述符是系统分配给文件或套接字的整数．是为了方便称呼操作系统分配的文件或套接字． 结构体sockaddr_in 参考文献[1] TCP/IP网络编程：https://blog.csdn.net/u011675745/article/details/78555250]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO复用]]></title>
    <url>%2F2019%2F10%2F18%2FTCPIP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B9%8BIO%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[IO复用是在阻塞IO基础上，通过某种机制同时对多个文件描述符进行监视的一种方式。 select服务端接收到来自客户端的消息后，不立即返回，而是等待几秒钟才继续向客户端回复消息。在客户端等待服务器回复的消息时，客户端处于睡眠状态，说明write系统调用是阻塞的。 epollepoll_create函数原型 1int epoll_create(int size); 功能：创建保存epoll文件描述符的空间。这些文件描述符正是监视对象。调用epoll_create函数时创建的文件描述符保存空间称为“epoll例程”。通过参数size传递的值决定epoll例程的大小，但该值只是向操作系统的建议。也就是该值并非用来决定epoll例程的大小，而仅供操作系统参考。epoll_create创建的这块空间归操作系统管理。因此，epoll_create返回文件描述符，此文件描述法主要用于区分epoll例程。返回值：成功时返回文件描述符，失败时返回-1。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector的实现]]></title>
    <url>%2F2019%2F10%2F18%2Fvector%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[STL SGI 2.9.2版本源码中vector的实现细节。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * 从position处（包括）开始插入n个相同的元素x * */template&lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert(iterator position, size_type n, const T &amp;x) &#123; if (n != 0) &#123; // end_of_storage表示可用空间的尾, finish表示未使用空间内存的起始处 // 可用空间个数大于等于n if (size_type(end_of_storage - finish) &gt;= n) &#123; T x_copy = x; const size_type elems_after = finish - position; iterator old_finish = finish; // 插入点之后的现有元素个数大于新增元素个数 if (elems_after &gt; n) &#123; // uninitialized_copy将迭代器first和last指定的范围内中的元素拷贝到以迭代器result起始的区域内 // 从finish - n 到finish(不包括finish)共有n个元素 uninitialized_copy(finish - n, finish, finish); finish += n; // 把[position, old_finish - n)中的元素拷贝到[old_finish - n - position, old_finish)指定的范围内 copy_backward(position, old_finish - n, old_finish); fill(position, position + n, x_copy); &#125; else &#123; // 插入点之后的现有元素个数小于新增元素个数 // 为以finish开始的内存空间指定n-elems_after个x_copy的初值 // 返回值：被赋值的尾元素下一位置的迭代器 uninitialized_fill_n(finish, n - elems_after, x_copy); finish += n - elems_after; uninitialized_copy(position, old_finish, finish); finish += elems_after; fill(position, old_finish, x_copy); &#125; &#125; else &#123; const size_type old_size = size(); const size_type len = old_size + max(old_size, n); iterator new_start = data_allocator::allocate(len); // 配置新的内存空间 iterator new_finish = new_start; __STL_TRY&#123; // 将插入点之前的元素拷贝到新空间中 new_finish = uninitialized_copy(start, position, new_start); // 插入新元素 new_finish = uninitialized_fill_n(new_finish, n, x); // 将插入点之后的元素拷贝到新空间中 new_finish = uninitialized_copy(position, finish, new_finish); &#125; // 如有异常发生，实现"commit or rollback" semantics# ifdef __STL_USE_EXCEPTIONS catch(...) &#123; destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; &#125;# endif /* __STL_USE_EXCEPTIONS */ // 调用旧的元素的额析构函数,释放旧的内存空间 destroy(start, finish); deallocate(); // 调整迭代器 start = new_start; finish = new_finish; end_of_storage = new_start + len; &#125; &#125;&#125; 向可变数组中position指定的位置之后加入n个元素x_copy。 插入点之后的元素个数大于等于新增元素个数nn=3，elems_after=7，x_copy = 17。 假设vector的当前状态如下： 执行uninitialized_copy(finish - n, finish, finish);之后 执行finish += n;之后， 执行copy_backward(position, old_finish - n, old_finish);之后， 执行fill(position, position + n, x_copy);之后， 插入点之后的元素个数小于新增元素个数nn=3, elems_after = 2, x_copy = 17。 假设vector的当前状态为： 执行uninitialized_fill_n(finish, n - elems_after, x_copy);后的状态： 执行finish += n - elems_after;后 执行uninitialized_copy(position, old_finish, finish);后 执行finish += elems_after;后 执行fill(position, old_finish, x_copy);后]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用函数api]]></title>
    <url>%2F2019%2F10%2F18%2Fc%2B%2BAPI%2F</url>
    <content type="text"><![CDATA[本文档主要整理并记录c++常用的api。 uninitialized_fill_n函数原型： 12template&lt;class ForwardIterator, class Size, class T&gt;ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T&amp;x); 功能：为以迭代器指向的起始位置的n个元素指定相同的初值． first: 迭代器first指向初始化空间的起始处． n: 表示欲初始化空间的大小 x: 初值 返回值：ForwardIterator first：即指向被赋值的尾元素下一位置的迭代器 可参考：http://www.cplusplus.com/reference/memory/uninitialized_fill_n/ uninitialized_copy12template&lt;class InputIterator, class ForwardIterator&gt;ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result); 功能：将迭代器first和last指定的范围内中的元素拷贝到以迭代器result起始的区域内 first: 指向源区域的起始处的迭代器 last: 指向源区域的结尾处的迭代器 result：指向目的区域的起始处的迭代器 返回值：指向新的结束位置的迭代器 copy_backward12template&lt; class BidirIt1, class BidirIt2 &gt;BidirIt2 copy_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last ); copy_backward() 会复制前两个迭代器参数指定的序列到以第三个迭代器为下一个位置的区间内。 第三个参数是目的序列的结束迭代器，通过将源序列中的最后一个元素复制到目的迭代器之前的内存空间内。 copy_backward() 的 3 个参数都必须是可以自增或自减的双向迭代器，这意味着这个算法只能应用到序列容器的序列上。 什么情况下需要用到copy_backward? 测试程序123456789101112131415void test_copy_backward() &#123; vector&lt;int&gt; v1&#123;2, 443, 121, 64&#125;; vector&lt;int&gt; v2(10, -1); auto beg = v2.begin() + v1.size() + 3; copy_backward(v1.begin(), v1.end(), beg); for (int i = 0; i &lt; v2.size(); ++i) &#123; cout &lt;&lt; i &lt;&lt; "\t"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; v2.size(); ++i) &#123; cout &lt;&lt; v2[i] &lt;&lt; "\t"; &#125; cout &lt;&lt; endl;&#125; 运行结果： 120 1 2 3 4 5 6 7 8 9 -1 -1 -1 2 443 121 64 -1 -1 -1 __STL_TRY__STL_TRY是宏定义 https://blog.csdn.net/Windgs_YF/article/details/80909170]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++标准库]]></title>
    <url>%2F2019%2F10%2F18%2Fc%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[几个可以参考的网站：http://www.cplusplus.comhttps://en.cppreference.com/whttps://gcc.gnu.org 如何学习标准库． 标准库源码：gnu c++ 2.9.1版本．如何找到gnu c++2.9.1版本代码？ OOP: 将data和methods关联起来；GP: 将data和methods分开来． 模板分为： 分配器先谈一谈operator new()和malloc()标准库中allocator的实现往往是使用operator new和operator delete，而operator new和operator delete又调用malloc和free来分配和释放内存．SGI主要使用的是alloc．尽量减少调用malloc的次数．当使用自由链表来保存内存空间的大小时，不再需要在 set和map中都有一个rb_tree，set和rb_tree之间的关系是composition. iteratorIterator需要遵循的原则 value_type: Iterator所指向的元素的类型 difference_type: 两个Iterator之间的距离 iterator_category: Iterator有5种类型：输入迭代器，输出迭代器，单向迭代器，双向迭代器(bidirectional_iterator_tag)，随机迭代器(random_access_iterator_tag) 后面两种很少被用到． reference pointer traits机制 如果Iterator是类类型，可以在类中定义value_type等，但若Iterator不是类类型，而是native pointer(native pointer也是一种迭代器).特性萃取机必须有能力分辨它所获取的iterator是class Iterator T还是native pointer to T． type traits &lt;c++/type_traits&gt; type_traits不属于stl，但属于标准库． iterator traits &lt;c++/bits/stl_iterator.h&gt; 属于stl． char traits &lt;c++/bits/char_traits.h&gt;allocator traits &lt;c++/bits/alloc_traits.h&gt;pointer traits &lt;c++/bits/ptr_traits.h&gt;array traits &lt;c++/array&gt; 容器 迭代器类型 array random_access_iterator vector random_access_iterator deque random_access_iterator list bidirectional_iterator forward list forward_iterator rb tree bidirectional_iterator unordered containers 取决于底层的链表是单向还是双向的 istream_iterator的iterator_category某些类之间的继承关系是为了继承typedef outstream_iterator的iterator_category 算法分类（iterator category）和type traits对算法效率的影响： distance advance copy copy_unique 容器vectorvector和array的区别是：array的空间固定，一旦用尽，如果用户还希望使用更多空间，需要自己分配一个更大容量的array，并把旧的元素搬到新的array中，然后将旧的array的内存空间还给系统．而vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素．vector每次扩充空间都分配当前容量两倍的空间． array array没有ctor，dtorarray与其他容器的区别在于，它需要一个size_t类型参数，表示数组的大小．array的迭代器就是指针T* deque扩充：分配一个缓冲区． reallocate_map情形1: map_size = 14, old_num_nodes = 4, nodes_to_add = 2, add_at_front = truenew_num_nodes = 6;map_size &gt; 2 * new_num_nodes 如下图1所示： 接下来我们计算，new_start = map + (14-6)/2 + 2 = map + 6 之后，移动元素，修改start和finish迭代器所在的位置．蓝色部分是新配置的两个map_node. 情形2: map_size = 6, old_num_nodes = 3, nodes_to_add = 1, add_at_front = truenew_num_nodes = 4;map_size &lt; 2 * new_num_nodesnew_map_size = 6 + 6 + 1 = 13new_start = new_map + (13 - 4) / 2 + 2 = new_map + 6 蓝色部分是新配置的map_node hashtableseperate chaing当bucket中的链表过长时，就说明冲突的可能性很大了，需要扩容．扩容过程：首先分配一块更大的内存，新内存的容量是大于旧的内存的两倍的一个质数．stl源码中准备了28个质数备用．然后将旧内存中的每一个元素搬到新内存中去．这个过程中需要为每一个元素重新计算位置．最后，释放旧的内存． bucket所在的内存是连续的吗？底层使用的是什么结构？buckets聚合体底层使用的是vector， 一个万能的hash FunctionAlgorithmfunctor为算法服务． 自己写functor并继承标准库的binary_function和unary_function.functor要被Adapter改造时，Adapter可能会问functor一些问题，所以，自定义的functor应该继承unary_function, binary_function等． 123456789101112template&lt;class Arg, class Result&gt;struct unary_function &#123; typedef Arg argument_type; typedef Result result_type;&#125;;template&lt;class Arg1, class Arg2, class Result&gt; struct binary_function &#123; typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type;&#125;; 自定义的仿函数要能够被适配器改造，应该继承unary_function或者binary_function． Adapter通过内含的方式实现． container adapter：stack，queue functor adapteriterator adapter function Adaptable的条件是：继承unary_function或者binary_function． &lt;c++\backward\backward_warning.h&gt;reverse_iterator inserter ostream_iterator istream_iterator]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis实现分布式锁]]></title>
    <url>%2F2019%2F10%2F18%2Fredis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[分布式锁的特点分布式锁一般有如下的特点： 互斥性： 同一时刻只能有一个线程持有锁 可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁 锁超时：支持锁超时，防止死锁 高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效 具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒 EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。 NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。 1127.0.0.1:6379&gt; set lock_sale_14 33 ex 30 nx 参考文献 http://redisdoc.com/string/set.html https://mp.weixin.qq.com/s/8fdBKAyHZrfHmSajXT_dnA]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RTTI(运行时类型识别)]]></title>
    <url>%2F2019%2F10%2F18%2FRTTI(%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5)%2F</url>
    <content type="text"><![CDATA[运行时类型识别，在C++层面主要体现在dynamic_cast和typeid，VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamice_cast都回去查询type_info。 运行时类型识别RTTI由两个运算符实现： typeid运算符，用于返回表达式的类型 dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。 dynamice_casttypeidtype_info参考C++对象模型系列1中的【示例1：虚拟继承下的C++对象模型】的Point2d的虚函数表可知，在虚函数中的第一个slot即为type_info对象。 参考文献[1]深度探索C++对象模型]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型系列1]]></title>
    <url>%2F2019%2F10%2F18%2FC%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[在C++对象模型中，Nonstatic data members被配置于每一个class object之内，static data members则被放在个别的class object之外。static和nonstatic function members也被放在个别的class object之外。 virtual functions则通过下面两个步骤来实现： 每一个class产生出一堆指向virtual functions的指针，放在表格之中。这个表格被称为virtual table(vtbl)。 每一个class object被安插一个指针，指向相关的virtual table。通常这个指针被称为vtpr。vtpr的设定和重置由每一个class的constructor、destructor和copy assignment运算符自动完成。每一个class所关联的type_info object(用来支持runtime type identification，RTTI)也经由virtual table被指出来，通常放在表格的第一个slot。 示例1：虚拟继承下的C++对象模型在下面的代码示例中，Point3d和Vertex虚拟继承自Point2d，Vertex同时继承自Point3d和Vertex。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;class Point2d &#123;public: virtual void print() &#123; cout &lt;&lt; "I am Point2d" &lt;&lt; endl; &#125; virtual ~Point2d() &#123;&#125;protected: float _x; // 4字节 float _y;&#125;;class Vertex : public virtual Point2d &#123;public: void print() &#123; cout &lt;&lt; "I am Vertex" &lt;&lt; endl; &#125; ~Vertex() &#123;&#125;protected: Vertex *next; // 指针,占8字节&#125;;class Point3d : public virtual Point2d &#123;public: // virtual function print1是Point3d独有的虚函数,不是从基类那里继承来的,但是无论这个虚函数是否存在都不影响Point3d的对象模型 virtual void print1() &#123; cout &lt;&lt; "This is my own virtual function, not inherient from my father" &lt;&lt; endl; &#125; ~Point3d() &#123;&#125;protected: float _z;&#125;;class Vertex3d : public Vertex, public Point3d &#123;public: ~Vertex3d() &#123;&#125;protected: float mumble;&#125;;void test1() &#123; Vertex vx;// vx.print(); cout &lt;&lt; "sizeof(Point2d): " &lt;&lt; sizeof(Point2d) &lt;&lt; endl; // 16 cout &lt;&lt; "sizeof(Point3d): " &lt;&lt; sizeof(Point3d) &lt;&lt; endl; // 32 cout &lt;&lt; "sizeof(Vertex) : " &lt;&lt; sizeof(Vertex) &lt;&lt; endl; // 32 cout &lt;&lt; "sizeof(Vertex3d) : " &lt;&lt; sizeof(Vertex3d) &lt;&lt; endl; // 48&#125;int main() &#123; test1(); return 0;&#125; 写这个示例的目的是为了验证：在Point3d的对象模型中有两个虚表指针，一个是从其基类Point2d那里继承而来的，另一个是Point3d自身的。 Point2d的对象模型： Point3d、Vertex、Vertex3d的对象模型。 从上图可知，在Point2d中有两个float类型的成员变量和一个指针。故Point2d的大小为16字节；Point3d对象有一个Point2d子对象和一个float类型数据成员z、一个虚表指针Point3d，故大小为16+4+8 = 28，但是因为28不是8的倍数(在64位系统上运行的)，所以28被边界对齐到32字节。同理Vertex的大小为16+8+8=32字节。对于Vertex3d，其大小为16+4+8+4+8+8 = 48字节。 示例2：继承模型下的地址多重继承下的对象模型 123456789101112131415161718192021222324class A &#123; public: virtual ~A() &#123;&#125;&#125;;class B &#123; public: virtual ~B() &#123;&#125;&#125;;class C : public A, public B &#123;&#125;;void test1() &#123; C *pC = new C(); A *pA = (A *) pC; B *pB = (B *) pC; cout &lt;&lt; pA &lt;&lt; endl; // 0x5652962dbe70 cout &lt;&lt; pB &lt;&lt; endl; // 0x5652962dbe78 cout &lt;&lt; pC &lt;&lt; endl; // 0x5652962dbe70 cout &lt;&lt; "sizeof(*pA):" &lt;&lt; sizeof(*pA) &lt;&lt; endl; cout &lt;&lt; "sizeof(*pB):" &lt;&lt; sizeof(*pB) &lt;&lt; endl; cout &lt;&lt; "sizeof(*pC):" &lt;&lt; sizeof(*pC) &lt;&lt; endl;&#125; A、B和C的对象模型： 在将A类型的指针指向C类型的对象时，因为指针指向的实际上是C类型对象中的class A子对象。因为，在A和C类型对象中，A类型子对象都是位于相同的位置(位于对象开始处，偏移量为0)，因此pA和pC的值相同。而在class C object中，B subobject的偏移量为8(即sizeof(A))，因此,pA和pC的值不同。]]></content>
      <categories>
        <category>C++对象模型</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板实参推断和引用]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E6%8E%A8%E6%96%AD%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板分为类模板，函数模板，还有成员模板。 编译器会对函数模板参数进行推导。 从左值引用函数参数推断类型当一个函数参数是模板参数类型的一个（左值）引用时（即，形如T&amp;），绑定规则告诉我们，只能传递一个左值（如，一个变量或一个返回引用类型的表达式）。实参可以是const类型，也可以不是。如果实参是const的，则T将被推断为const类型： 1234template&lt;typename T&gt; void f1(T&amp;); // 实参必须是一个左值f1(i); // i是一个int，模板参数类型T是intf1(ci); // ci是一个const int ；模板参数类型T是const intf1(5); // 错误：传递给一个&amp;参数的参数必须是一个左值 如果一个函数参数的类型是const T&amp;，正常的绑定规则告诉我们可以传递给它任何类型的实参—一个对象(const 或非const)、一个临时对象或者一个字面常量值。当函数参数本身是const时，T的类型推断的结果不会是一个const类型。const已经是函数参数类型的一部分；因此，它不会是模板参数类型的一部分。 123456template&lt;typename T&gt;void f2(const T&amp;); //可以接受一个右值// f2的参数是const &amp;，实参中的const是无关的// 在每个调用中，f2的函数参数都被推断为const int&amp;f2(i); // i是一个int, 模板参数类型T是intf2(ci); // ci是一个const int，模板参数类型T是intf2(5); // 一个const &amp;可以绑定到一个右值，模板参数类型T是int 从右值引用函数参数推断类型当一个函数参数是一个右值引用类型（即，形如T&amp;&amp;）时，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的T的类型是该右值实参的类型： 12template&lt;typename T&gt; void f3(T&amp;&amp;);f3(42); // 实参是一个int类型的右值；模板参数类型T是int 引用折叠和右值引用参数假定i是一个int对象，我们可能认为像f3(i)这样的调用是不合法的。毕竟，i是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是C++语义在正常绑定规则之外定义了两个例外规则。这两个规则是move这种标准库设施正确工作的基础。 第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值（如i）传递给函数的右值引用类型参数，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用f3(i)时，编译器推断T的类型为int&amp;，而非int。 T被推断为int&amp;好像意味着f3的函数参数应该是一个类型int&amp;的右值引用。通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。 在这种情况下，我们可以使用第二个绑定规则：如果我们间接创建一个引用的引用，则这些引用形成了折叠。对于一个给定的类型X： X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp; 类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp; 如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以对一个左值调用f3。当我们将一个左值传递给f3的（右值引用）函数参数时，编译器推断T为一个左值引用类型。 12f3(i) // 实参是一个左值，模板参数T是int&amp;f3(ci); // 实参是一个左值，模板参数T是一个const int&amp; 当一个模板参数T被推断为引用类型时，折叠规则告诉我们函数参数T&amp;&amp;折叠 为一个左值引用类型。例如，f3(i)的实例化结果可能像下面这样： 12// 无效代码，只是用于演示目的void f3&lt;int&amp;&gt;(int &amp; &amp;&amp;); // 当T是int&amp;时，函数参数为T&amp; &amp;&amp; f3的函数参数是T&amp;&amp;且T是int&amp;，因此，T&amp;&amp;是int&amp; &amp;&amp;，会折叠成int&amp;。因此，即使f3的函数参数形式是一个右值引用（即T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化f3： 1void f3&lt;int&amp;&gt;(int&amp;); // 当T是int&amp;时，函数参数折叠为int&amp; 这两个规则导致了两个重要结果： 如果一个函数参数是一个指向模板实参类型的右值引用，且函数参数被绑定到一个左值；且 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用类型参数。 另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给T&amp;&amp;类型的函数参数。对于这种类型的参数，可以传递给它右值，亦可以传递给它左值。 forward(完美转发)某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>模板</tag>
        <tag>函数参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[move语义]]></title>
    <url>%2F2019%2F10%2F18%2Fmove%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[std::move 右值与右值引用临时对象是一种右值；字面常量是一种右值。右值不可以放在赋值号的左边，即右值不可以被赋值；不可以对右值取地址。 一个左值引用是某个对象的另一个名字。返回左值引用的函数，赋值，下标，解引用和前置递增/递减运算符都是返回左值的表达式的例子。注意：尽管常量无法改变，但是常量是一个左值。 右值引用是必须绑定到右值的引用。不能将一个右值引用绑定到一个左值上。返回非引用类型的函数，包括算术，关系，位及递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但是可以将一个const的左值引用或一个右值引用绑定到这类表达式(返回右值的表达式)上。也就是说不能将左值引用绑定到一个右值上，但是可以将一个const的左值引用和一个右值引用绑定到右值上。 右值引用通常用于两种情况：模板转发其实参或模板被重载。 123456int i = 42; int &amp;r = i; // 正确，r是一个左值引用，绑定到一个左值上int &amp;&amp;rr = i; // 错误，rr是一个右值引用，，不能将一个右值引用绑定到一个左值上int &amp;r2 = i * 42; // 错误，不能将一个左值引用绑定到一个右值上const int &amp;r3 = 42; // 正确，r2是一个const的左值引用，可以将一个const的左值引用绑定到一个右值上int &amp;&amp;rr2 = i * 42; // 正确，可以将一个右值引用绑定到一个右值上 由于右值引用只能绑定到临时对象，所以：右值引用的对象将要销毁，且该对象没有其他用户。因此使用右值引用的代码可以自由地接管所引用的对象的资源。变量是左值，可以把变量看做是只有一个运算对象而没有运算符的表达式，变量表达式都是左值。因此不能将一个右值引用绑定到一个变量上，即使这个变量是右值引用类型，也不行。 12int &amp;&amp;rr1 = 42; // 正确，rr1是一个右值引用类型的变量，绑定到一个右值42int &amp;&amp;rr2 = rr1; // 错误，rr1是一个变量，它的类型是右值引用类型，但是rr1是一个变量，是左值，因此，不能将右值引用绑定到rr1上 标准库move函数尽管不能将一个右值引用直接绑定到一个左值上，但是可以显式地将一个左值转换为对应的右值引用类型。通过调用标准库的move函数来获得绑定到左值上的右值引用。 12int &amp;&amp;rr1 = 42;int &amp;&amp;rr3 = std::move(rr1); // ok，std::move显式地将一个左值转换为对应的右值引用类型 move函数用在某些类的移动构造函数和移动赋值运算符函数中，帮助这些函数实现将资源从给定对象移动而不是拷贝到正在创建的对象中(参考c++primer11，p469)。 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。移后源对象必须可析构，并且移后源对象必须仍然是有效的。对象有效是指可以安全为其赋予新值或者可以安全地使用而不依赖其当前值。 move语义的几个疑问strVec类C++ Primer》中有关右值引用的例子，书中先是定义了一个类StrVec：然后定义了一个移动构造函数： 12345StrVec::StrVec(StrVec &amp;&amp;s) noexcept :elements(s.elements), first_free(s.first_free), cap(s.cap)&#123; s.elements = s.first_free = s.cap = nullptr;&#125; 问：既然elements,first_free和cap都是指针，这里如何体现了一个对象被移动，难道这个函数难道不是仅仅复制了指针，这和一个只执行了浅拷贝的拷贝构造函数的作用有什么区别？ 答：从上述代码中，可以看到，除了浅拷贝(从源对象那里拷贝指针)，还把源对象的指针清零了。浅拷贝是共享资源，而move是独占资源，浅拷贝因共享资源从而可能引发重复析构的问题，而move是独占则不会。具体而言，浅拷贝时，仅仅修改目的对象的成员指针，令它和源对象指向相同的堆内存，而move则会同时修改源对象和目的对象的成员指针，令目的对象指向源对象的堆内存，但是源对象却不再指向这块内存，从而实现了move从源对象处窃取资源。 问：如果把原对象的成员指针变量变为空指针，而原对象的析构函数会执行释放指针指向的资源的操作，运行的时候会不会出现错误。 123456789101112131415StrVec::~StrVec() &#123;free();&#125;void StrVec::free() &#123; // free有两个责任: destory元素,释放StrVec自己分配的内存空间 // 不能给deallocate传一个空指针,因此若elements为空,就什么都不做 if (elements) &#123; // 逆序销毁元素 for (auto p = first_free; p != elements;) &#123; alloc.destroy(--p); &#125; alloc.deallocate(elements, cap - elements); &#125;&#125; 答：不会出现错误。根据前文的代码，释放前会判断elements是否为空指针，所以并不会出现错误。 容器另外一个疑惑是和容器有关的。知乎上的一个问题的回答提到了这两个函数： 12void push_back( const T&amp; value ); // (1)void push_back( T&amp;&amp; value ); // (2) 问：第二个版本的函数为什么能实现对象的移动，容器的存储空间难道不是Allocator分配的一段连续的内存空间，如果只是转移了对象持有资源的所有权，又怎么能保证容器中的存放的对象是在一片连续的内存空间上的？ 答：标准中有明确说明两个版本的push_back并没有语义上的差别，都是在容器末尾追加value的副本。所以题目中声称的实现对象的移动是无稽之谈。追加value的副本的过程传递的是对象的值而非对象本身。参数本身的左右值引用属性，决定了value的值是通过拷贝构造函数还是移动构造函数传递。 问：vector重新申请的内容到底有没有被使用，应为没有复制不就意味着之前的内容依然保存在原内存上，而不能被释放。 答：上一个问题中提到传递的是对象的值，而非对象本身。也就是说，对于int这种内置类型来说，复制和移动没有区别；而对于std::string/std::vector来说，对象除了拥有它本身所占的内存(栈内存)，还拥有由它管理的动态分配出来的内存中的内容，移动相比复制会轻松。 上图是源对象，被移动前，左边是源对象本身所占的内存，右边是源对象管理的内存。 ​ ​ 移动会从源对象那里窃取资源。移动完成后，源对象不再指向被移动的资源—这些资源的所有权已经归属目的 对象。移后源对象应该处于析构安全的状态，并且对象应该还是有效的。 补充几条 move语义必须和RAll结合起来才能安全使用，因为move涉及到堆内存的管理权的转移，如果不RAll，多转移几次，你完全都不知道指针现在归谁管理了。 move语义转移的move构造函数中指定的堆空间使用权，而不是对象，也就是说对于简单对象，比如int，即使对它使用move语义也是没用的。 问题中提到的顺序容器vector，使用move用处不大，因为最终它还是要使用拷贝语义来保证容器的内存顺序 一个例子说明对于使用连续内存空间的容器vector和list而言，移动的区别。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;class A &#123;public: A(int a) &#123; p = new int; *p = a; &#125; A(const A &amp;a) &#123; std::cout &lt;&lt; "this is left-ref copy ctor:" &lt;&lt; *a.p &lt;&lt; std::endl; p = new int; *p = *a.p; &#125; A(A &amp;&amp;a) &#123; std::cout &lt;&lt; "this is move copy ctor" &lt;&lt; std::endl; p = a.p; a.p = nullptr; &#125; void print() const &#123; if (p == nullptr) &#123; std::cout &lt;&lt; "null" &lt;&lt; std::endl; return; &#125; std::cout &lt;&lt; p &lt;&lt; ":" &lt;&lt; *p &lt;&lt; std::endl; return; &#125; ~A() &#123; if (p == nullptr) &#123; return; &#125; delete p; &#125;protected: int *p;&#125;;template&lt;typename T&gt;void test() &#123; A a(123); A b(456); A c(789); cout &lt;&lt; "sizoef(A): " &lt;&lt; sizeof(A) &lt;&lt; endl; // A的大小为8个字节 T v; // 对于vector,插入完成后,容器的可用空间由0变为1,已经用了1 v.push_back(std::move(a)); cout &lt;&lt; endl; // 对于vector,插入完成后,容器的可用空间由1变为2,已经用了2 v.push_back(std::move(b)); cout &lt;&lt; endl; // 对于vector,插入完成后,容器的可用空间由2变为4,已经用了3 v.push_back(std::move(c)); cout &lt;&lt; endl; for (auto it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; "address:" &lt;&lt; &amp;(*it) &lt;&lt; " "; it-&gt;print(); &#125;&#125; 对于list 123void test1() &#123; test&lt;std::list&lt;A&gt;&gt;();&#125; 运行结果 12345678910sizoef(A): 8this is move copy ctorthis is move copy ctorthis is move copy ctoraddress:0x55b0184102f0 0x55b01840fe70:123address:0x55b018410310 0x55b01840fe90:456address:0x55b018410330 0x55b01840feb0:789 list每次分配一个元素的内存空间，并调用元素的移动构造函数构造一个对象，加入到链表中。 对于vector 123void test2() &#123; test&lt;std::vector&lt;A&gt;&gt;();&#125; 运行结果 12345678910111213141516sizoef(A): 8# 插入第一个元素this is move copy ctor# 插入第二个元素，vector需要扩容，所以分配一块更大的内存，将元素拷贝到新内存上this is move copy ctorthis is left-ref copy ctor:123# 插入第三个元素，再次扩容this is move copy ctorthis is left-ref copy ctor:123this is left-ref copy ctor:456address:0x55734343c340 0x55734343c2e0:123address:0x55734343c348 0x55734343be70:456address:0x55734343c350 0x55734343beb0:789 vector要保证所有元素的内存地址连续，所以，每次分配一块内存。当加入新元素时，如果当前还有剩余空间，就把新元素直接加入到尾部，如果没有剩余空间，就需要进行扩容，扩容时会发生元素的拷贝。 参考文献[1]如何理解C++中的move语义：https://www.zhihu.com/question/43513150[2]C++ 11的移动语义：https://www.cnblogs.com/sunchaothu/p/11392116.html]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存分配的几个函数]]></title>
    <url>%2F2019%2F10%2F18%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[用于内存分配的函数有：malloc，calloc、realloc等。]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>malloc</tag>
        <tag>calloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找各种不同的应用场景]]></title>
    <url>%2F2019%2F10%2F17%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[二分查找是一种十分重要的查找算法．通常在有序数组中查找某个指定的数． Find peak Element: https://leetcode.com/problems/find-peak-element 如何处理一个数组中所有元素都相等的情况． https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/&gt; 数字在排序数组中出现的次数：https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking 相似题：https://leetcode.com/problems/first-bad-version/ 12345678910111213int findLastPos(vector&lt;int&gt;&amp; nums, int target)&#123; int i = 0, j = nums.size()-1; int mid = -1; while(i &lt;= j)&#123; mid = (i + j) / 2; if(nums[mid] &gt; target)&#123; j = mid - 1; &#125;else&#123; i = mid; &#125; &#125; return mid;&#125; 从有序数组中大于等于某个数的元素第一次出现的位置123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出大于某个值的元素第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例: 1234[1, 3, 3, 3, 3] // 1, 元素3(最早出现的元素3)[1, 2, 4, 5, 6] // 2, 元素4[1, 2, 2, 2, 2] // -1, 所有元素都比3小[4, 5, 6, 9, 12] // 0, 所有元素都比3大 从有重复元素的有序数组中找出某个元素第一次出现的位置123456789101112131415int getLessIndex(vector&lt;int&gt; &amp;help, int num) &#123; // 从有序数组中找出某个值第一次出现的位置 int l = 0, r = help.size() - 1; int index = -1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (help[mid] &gt;= num) &#123; index = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return index;&#125; 测试用例 123[1, 3, 3, 3, 3] // 1, 第一个元素3[-1, 1, 2, 3, 5] //3, 元素3[1, 2, 4, 5, 6] // -1, 不存在元素3 在有序旋转数组中搜索某个给定的数题目链接]]></content>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147. Insertion Sort List]]></title>
    <url>%2F2019%2F10%2F16%2F147.-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 解法11234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head == nullptr || head-&gt;next == nullptr)&#123; return head; &#125; ListNode* cur = head-&gt;next; ListNode* prev = head; while(cur!=nullptr)&#123; if(head-&gt;val &gt; cur-&gt;val)&#123; prev-&gt;next = cur-&gt;next; cur-&gt;next = head; head = cur; cur = prev-&gt;next; &#125;else&#123; ListNode* p = head; while(p-&gt;next != cur &amp;&amp; p-&gt;next-&gt;val &lt;= cur-&gt;val)&#123; p = p-&gt;next; &#125; if(p-&gt;next != cur)&#123; prev-&gt;next = cur-&gt;next; cur-&gt;next = p-&gt;next; p-&gt;next = cur; cur = prev-&gt;next; &#125;else&#123; prev = cur; cur = cur-&gt;next; &#125; &#125; &#125; return head; &#125;&#125;; 解法212345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head == nullptr || head-&gt;next == nullptr)&#123; return head; &#125; ListNode* pHead = head; ListNode* p = head-&gt;next; pHead-&gt;next = nullptr; while(p)&#123; ListNode* cur = pHead; ListNode* tmp = p-&gt;next; if(pHead-&gt;val &gt; p-&gt;val)&#123; p-&gt;next = pHead; pHead = p; &#125;else&#123; while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;val &lt;= p-&gt;val)&#123; cur = cur-&gt;next; &#125; p-&gt;next = cur-&gt;next; cur-&gt;next = p; &#125; p = tmp; &#125; return pHead; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F10%2F16%2F21.-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 递归解法递归的方法每次确定一个元素的位置，将问题规模减小1。 非递归解法]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>减治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Linked List]]></title>
    <url>%2F2019%2F10%2F16%2FReverse-Linked-List%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Reverse Linked List Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? 解法1：非递归解法解法2：递归解法]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树与双向链表]]></title>
    <url>%2F2019%2F10%2F16%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[将二叉树转成双向链表。 将二叉搜索树转成双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。二叉树与双向链表 递归方法12345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode* lastNode = nullptr; ConvertCore(pRootOfTree, lastNode); while(lastNode &amp;&amp; lastNode-&gt;left) lastNode = lastNode-&gt;left; return lastNode; &#125; void ConvertCore(TreeNode* node, TreeNode* &amp;lastNode)&#123; // lastNode表示双向链表中最后一个节点,node表示当前的根节点 // 首先考虑node的左子树，若左子树不空，则先转换左子树，并且lastNode表示左子树转换成的双向链表中 // 的最后一个节点，那么指向让node-&gt;left = lastNode,若lastNode不为空，令lastNode-&gt;right=node // 返回 if(node == nullptr)&#123; return; &#125; if(node-&gt;left)&#123; ConvertCore(node-&gt;left, lastNode); &#125; node-&gt;left = lastNode; if(lastNode!=nullptr)&#123; lastNode-&gt;right = node; &#125; lastNode = node; if(node-&gt;right!=nullptr)&#123; ConvertCore(node-&gt;right, lastNode); &#125; &#125;&#125;; 非递归解法1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(pRootOfTree==nullptr)&#123; return nullptr; &#125; ConvertCore(pRootOfTree); return pRootOfTree; &#125; void ConvertCore(TreeNode* &amp;root)&#123; stack&lt;TreeNode*&gt; st; TreeNode* cur = nullptr; TreeNode* node = root; while(node!=nullptr || !st.empty())&#123; if(node==nullptr)&#123; node = st.top(); st.pop(); if(cur != nullptr)&#123; cur-&gt;right = node; &#125;else&#123; root = node; &#125; node-&gt;left = cur; cur = node; node = node-&gt;right; &#125;else&#123; st.push(node); node = node-&gt;left; &#125; &#125; &#125;&#125;; 114. Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 参考“参考文献1”，有多种解法。 430. Flatten a Multilevel Doubly Linked List参考文献[1]Flatten Binary Tree to Linked List：https://www.cnblogs.com/grandyang/p/4293853.html]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引是存储引擎用于快速找到记录的一种数据结构。索引是按用户任意指定的字段对数据进行排序的一种数据结构。索引是为了加快查询的速度． 使用索引 优点 通过建立唯一索引或主键索引保证数据库中每一行数据的唯一性，提高检索的数据的效率以及减少表的检索行数 缺点： 创建索引和维护索引会浪费时间，随着数据量的增加而增加； 索引文件会占用磁盘空间(数据库索引存储在磁盘上)； 当对表中的数据进行增删改的时候，也需要动态地维护索引，这样会降低数据更新的速度． 适用的场景： 适合查询操作多于更新操作的场景． 表中数据量较大． 建立索引的字段应该有较多值，比如说实值．比如说，字段gender，只有两个值，男和女，就不适合建立索引． 索引类型 单列索引：一个索引只包含一个列；可以有多个单列索引；主键索引，唯一索引，普通索引 联合索引：一个联合索引包含两个或两个以上的列；当索引包含多个列时，列的顺序十分重要．因为存储引擎只能高效地使用最左前缀列． 查询类型 B-Tree(实际上是B+树)索引适用于全键值，键值范围查询，键前缀查找(最左前缀查找)． 建立索引： 1234567891011121314151617普通索引 create index 索引名 on 表名(字段名);alter table 表名 add index 索引名(字段名)# 唯一索引与普通索引类似，必须唯一，可以有空值 create unique index 索引名 on 表名(字段名)alter table 表名 add unique(字段名)# 主键索引，必须唯一，不可以有空值# 创建表时添加alter table 表名 add primary key(字段);# 组合索引create index 索引名 on 表名(字段名1, 字段名2...);alter table 表名 add index 索引名(字段名1, 字段名2)# 删除索引drop index 索引名 on 表名 B-tree索引B树数据库索引存储在磁盘上，当数据量比较大的时候，索引也很大，可能有几个G甚至更多．当我们利用索引查询的时候，能把整个索引全部加载到内存吗？显然不可能，只能一页一页地加载磁盘页．这里的磁盘页对应着索引树的节点．如果利用二叉查找树作为索引结构，假设二叉查找树的高度为n．那么最差情况下，要查询的节点是处于最深层次上的叶子节点，磁盘IO次数等于树的高度．为了减少磁盘IO次数，需要把原本”瘦高”的树结构变得”矮胖”，这就是B-树的特征之一．B树是一种多路平衡查找树，它的每一个节点最多包含k个孩子，k被称为B树的阶．k的大小取决于磁盘页的大小． 一个m阶的B树具有如下特征：１．根节点至少有两个孩子２．每个中间节点都包含k-1个元素和k个孩子，其中m/2(向上取整) &lt;= k &lt;= m．３．每一个叶子节点都包含k-1个元素，其中m/2(向上取整) &lt;= k &lt;= m４．所有的叶子节点都位于同一层．５．每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域的分割． B树在查询过程中的比较次数并不比二叉查找树少，尤其是当单一节点中的元素数量很多时．可是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略．只要树的高度足够低，IO次数足够少，就可以提升查找性能．在一个节点内的内部元素多一些也没有关系，只不过需要在内存中多做几次比较．B树主要应用于文件系统及部分数据库索引，如非关系型数据库MongoDB．大部分关系型数据库，如mysql，使用B+树作为索引． B树无论中间节点还是叶子节点都既有用于索引的关键字又有数据项(如数据表中的一行)。 B+树 一个m阶的B+树具有如下特征：１．有k个子树的中间节点包含k个元素(B树中是k-1个元素)，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点上．２．所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子节点本身依关键字的大小从小到大顺序链接(每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历)． 更详细版本一个m阶的B树具有如下特征：１．数据项存储在叶子节点上２．非叶节点存储指示m-1个关键字指示搜索的方向；关键字i代表子树i+1中的最小的关键字(每一个父节点的元素都出现在子节点中，是子节点中的最大或最小元素，这里是最小)３．树的根或者是一片树叶，或者其孩子数在2到m之间．４．除根外，所有非叶节点的还在数在[m/2](m/2向上取整)和m之间．５．所有的叶子节点都位于同一层，并且每个叶子节点拥有的数据项的个数在[L/2]和L之间．L是能装入到一个磁盘块中的数据项个数． B树和B+树的区别B+树中数据项只存储在叶子节点中，所以，同样大小的磁盘有可以容纳更多的关键字元素。这意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时的IO次数更少。但是B+树的查询最终必须查找到叶子节点才能获取数据项，而B树只要找到匹配的元素即可。无论匹配元素是在中间节点还是叶子节点。B树的查找性能并不稳定(最好情况是只查根节点，最坏情况是查到叶子节点)。而B+树的每一次查找都是稳定的。 B+树的优点主要体现在查询性能上。分别以单行查询和范围查询为例。B+树的范围查询只需要找到上限和下限所在的叶子节点，然后对链表进行遍历。而B树的范围查询需要通过中序遍历。总的来说，B+与B树相比，优点在于：１．单一节点存储更多的(关键字)元素，使得查询的IO次数更少。２．所有查询都要查询到叶子节点才能获取(关键字)元素对应的数据项，查询性能更加稳定。３．所有叶子节点形成有序链表，便于范围查询。 B+树的增删改查哈希索引哈希索引基于哈希表实现．只有精确匹配索引所有列的查询才有效。对于每一行数据(即每一个记录)，存储引擎会对所有的索引列计算一个哈希码(hash code)。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向所有数据行的指针。 一般而言，对于不同的键值得出的哈希码是不同的，但是如果多个键值的哈希码相同，则将以链表的形式将多个记录指针存放到同一个哈希表条目中。 哈希索引的优缺点： 优点：索引中只存储对应的哈希值，索引的结构十分紧凑，所以哈希查找的速度非常快。 缺点： 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。 哈希索引不支持部分索引列匹配查找，因为哈希索引是使用所有索引列的全部内容来计算哈希值的。例如，在数据列(A,B)上建立哈希索引，如果查询只有数据列A则无法使用该索引 参考文献[1] B+树：B+树[2] B树：B树[3] MySQL索引和SQL调优：https://zhuanlan.zhihu.com/p/76494612[4]可视化插入和删除过程：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html[5]MySQL索引背后的数据结构及算法原理：http://blog.codinglabs.org/articles/theory-of-mysql-index.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[alignment(字节对齐)]]></title>
    <url>%2F2019%2F10%2F16%2Falignment(%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90)%2F</url>
    <content type="text"><![CDATA[什么是字节对齐？ 在C语言中，结构是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构、联合等）的数据单元。在结构中，编译器为结构的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。 为了使CPU能够对变量进行快速的访问,变量的起始地址应该具有某些特性,即所谓的”对齐”。 比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除。 为什么要进行字节对齐字节对齐便于快速访问内存，合理的利用字节对齐可以有效地节省存储空间。对于32位机器来说，4字节对齐能够使cpu访问速度提高。例如一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了(为什么)。另外还需要考虑编译器的类型。在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。 如何进行字节对齐结构体变量在给成员分配内存的时候，是按照字节对齐的方式存储的。以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存的时候都要与这个长度对齐。 几个小例子，可以看出结构体变量在为成员变量分配内存时如何进行字节对齐。 123456789101112131415struct Obj1 &#123; // 结构体中最长成员数据类型是int,占4个字节,则以4字节对齐 char a; int b; char c;&#125;;void test1() &#123; Obj1 data; cout &lt;&lt; "sizeof(int):" &lt;&lt; sizeof(int) &lt;&lt; endl; // sizeof(int):4 //%p是取地址输出控制符 printf("%p, %p, %p\n", &amp;data.a, &amp;data.b, &amp;data.c); //0x7ffe1e35d28c, 0x7ffe1e35d290, 0x7ffe1e35d294 printf("%d\n", sizeof(data)); //12&#125; 第一个char类型占1个字节，但是需要以4字节对齐；同理第二个char类型占1个字节，但以4字节对齐。于是Obj1类型对象data占用的内存为12字节。 123456789101112131415struct Obj2 &#123; // 结构体中最长成员数据类型是double,占8个字节,则以4字节对齐 char a; double b; char c;&#125;;void test2() &#123; Obj2 data; cout &lt;&lt; "sizeof(double):" &lt;&lt; sizeof(double) &lt;&lt; endl; //sizeof(double):8 //%p是取地址输出控制符 printf("%p, %p, %p\n", &amp;data.a, &amp;data.b, &amp;data.c); // 0x7ffe1e35d280, 0x7ffe1e35d288, 0x7ffe1e35d290 printf("%d\n", sizeof(data)); // 24&#125; 这里与上个例子的不同之处在于以8字节对齐，所以占用的内存为8 * 3 = 24字节。 123456789101112struct Obj3 &#123; Obj1 o1; // 12 ==&gt; 16 Obj2 o2; // 24&#125;;void test3() &#123; Obj3 data; printf("%p, %p\n", &amp;data.o1, &amp;data.o2); // 0x7ffe98ca7220, 0x7ffe98ca7230 //%p是取地址输出控制符 printf("%d\n", sizeof(data)); // 40&#125; 参考文献[1]结构体变量字节对齐：http://c.biancheng.net/view/243.html[2]为什么要进行字节对齐：https://blog.csdn.net/21aspnet/article/details/6729724[3]为什么要进行字节：http://blog.chinaunix.net/uid-24118190-id-75219.html]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>对象模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将有序链表转成二叉搜索树系列]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%B0%86%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%88%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[将有序数组转换成二叉搜索树 Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 1234567891011121314151617class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = sortedArrayToBSTCore(nums, 0, nums.size()-1); return root; &#125; TreeNode* sortedArrayToBSTCore(const vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; if(lo &gt; hi)&#123; return nullptr; &#125; int mid = (lo + hi) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = sortedArrayToBSTCore(nums, lo, mid - 1); root-&gt;right = sortedArrayToBSTCore(nums, mid + 1, hi); return root; &#125;&#125;; 将二叉搜索树的根节点传引用进入建立二叉搜索树的函数和返回二叉搜索树的头结点的两种方法，后者更快，但是前者更好理解。 时间复杂度为O(logn)。 将有序链表转换成二叉搜索树 Convert Sorted List to Binary Search Tree Medium Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 解法1：递归二叉搜索树的性质：左子树上所有节点的值都小于等于根节点的值，右子树上所有节点的值都大于等于根节点的值。一棵二叉搜索树的左子树和右子树都是二叉搜索树。 给定有序中的中间元素形成二叉搜索树的根节点。根节点左边的节点递归地形成左子树，根节点右的节点递归地形成右子树。这保证了二叉搜索树是平衡的。 思路：首先用快慢双指针找到根节点，然后递归地形成左子树和右子树。 AC代码1 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head == mid)&#123; return root; &#125; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向尾节点 return slow; &#125;&#125;; AC代码2 12345678910111213141516171819202122232425262728293031class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(head==nullptr)&#123; return nullptr; &#125; ListNode* mid = findMiddleNode(head); TreeNode* root = new TreeNode(mid-&gt;val); if(head != mid)&#123; // 当mid不指向链表中的第一个元素时，即左子树上还有节点时 root-&gt;left = sortedListToBST(head); &#125; root-&gt;right = sortedListToBST(mid-&gt;next); return root; &#125; ListNode* findMiddleNode(ListNode*&amp; head)&#123; ListNode* pre = nullptr; ListNode* cur = head; ListNode* fast = head == nullptr ? nullptr : head-&gt;next; ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; pre = slow; slow = slow-&gt;next; &#125; if(pre!=nullptr)&#123; pre-&gt;next = nullptr; &#125; // 当链表中只有两个元素时，slow指向头节点 return slow; &#125;&#125;; 两种AC代码的唯一一点小差别在与，寻找中间节点时，当链表中有两个节点时，第一种AC代码返回的是尾节点，而第二种代码返回的是头节点。 时间复杂度为O(nlongn)。假设链表中有n个元素。寻找中间元素需要线性遍历链表，slow指针需要从头节点移动到中间节点，时间复杂度为O(n)。接下来规模为n问题变成两个规模为n/2的子问题。因此，时间复杂度递推公式为:T(n) = O(n) + 2 * T(n/2)最后的时间复杂度为O(nlogn)。空间复杂度为O(logn)。 解法2：转成有序数组 先将有序链表转成有序数组，然后使用第一题的解法解决。 时间复杂度为O(n)。空间复杂度为O(n)。 解法3：中序模拟此解法基于这一事实：二叉搜索树的中序便利序列是有序的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int findSize(ListNode* head)&#123; ListNode* node = head; int c = 0; while(node!=nullptr)&#123; node = node-&gt;next; c += 1; &#125; return c; &#125; TreeNode* convertListToBST(ListNode*&amp; head, int l,int r)&#123; if(l &gt; r)&#123; return nullptr; &#125; int mid = (l + r) / 2; TreeNode* left = convertListToBST(head, l, mid - 1); TreeNode* node = new TreeNode(head-&gt;val); node-&gt;left = left; head = head-&gt;next; node-&gt;right = convertListToBST(head, mid + 1, r); return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; int size = findSize(head); return convertListToBST(head, 0, size - 1); &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(logn)。]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>binary Tree</tag>
        <tag>有序链表</tag>
        <tag>二叉搜索树</tag>
        <tag>有序数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork和vfork]]></title>
    <url>%2F2019%2F10%2F15%2Ffork%E5%92%8Cvfork%2F</url>
    <content type="text"><![CDATA[fork和vfork fork基本概念一个进程, 包括代码, 数据和分配给该进程的资源. fork()通过系统调用创建一个与原来进程几乎完全相同的进程.也就是两个进程做完全相同的事.但是如果初始参数或者传入的变量不同,两个进程也可以做不同的事情。 一个进程调用fork()函数后,系统先给新的进程分配资源.如存储数据和代码的存储空间.然后吧原来的进程的所有值都复制到新进程中,只有少数值与原来的进程的值不同.相当于克隆了一个自己.创建新进程成功后, 系统中出现两个几乎完全相同的进程,这两个进程执行没有固定的先后顺序, 哪个进程先执行要看系统的进程调度策略. 由fork函数创建的新进程被称为子进程。fork函数被调用一次，但是返回两次。父进程返回的值是新进程的进程ID，而子进程返回的值是0。 fork函数返回值的三种情况 返回子进程Id给父进程 因为一个进程的子进程可能有多个，并且没有一个函数可以获得一个进程的所有子进程ID。 返回给子进程值为0 一个进程只会有一个父进程，所以子进程总是可以调用getpid以获得当前进程Id以及调用getppid获得父进程Id. 出现错误，返回负值 当前进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN 系统内存不足，这时errno的值被设置为ENOMEM 子进程执行代码开始位置 fork可以创建一个子进程并完全复制父进程,但是子进程是从fork后面那条指令开始执行的.如果子进程也从main开始执行所有指令,那么它执行到fork指令时必然会创建一个新的子进程. 从而导致不停地创建子进程,程序永不结束。 示例1fork创建子进程1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); break; case 0: message = "this is the child"; n = 5; break; default: message = "this is the parent"; n = 3; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(3); &#125; return 0;&#125; 运行结果 123456789101112xixi@xixi:~/linux_cource/11.3$ ./a.out fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childxixi@xixi:~linux_cource/11.3$ this is the childxixi@xixi:~/linux_cource/11.3$ 程序在调用fork时被分为两个独立的进程.当用fork启动一个子进程时, 子进程就有了它自己的生命周期并将独立运行.父进程在子进程之前结束, 因此在输出内容中有一个shell提示符. 让父进程等待子进程结束如果希望父进程等待子进程结束,可以调用wait函数.函数原型: pid_t wait(int* stat_loc);wait系统调用返回子进程的pid, 通常是已经结束运行的子进程的pid.状态信息允许父进程了解子进程的退出状态, 即子进程的main函数返回的值或者子进程中exit函数的退出码.如果stat_loc不是空指针, 状态信息将被写入到它所指向的位置. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 3; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行结果 1234567891011fork program startingthis is the parentthis is the childthis is the parentthis is the childthis is the parentthis is the childthis is the childthis is the childchild has finished: PID: 15467child exited with code 37 查看僵尸进程子进程终止时,它与父进程之间的关联还会保持, 直到父进程也正常终止或父进程调用wait才会结束.因此,进程表中代表子进程的表项不会立即释放.虽然子进程已经不再运行,但它仍然存在于系统中,因为它的退出码还需要保存起来,以备父进程今后的wait调用使用.这时候它将成为一个死进程或者僵尸进程.所以,僵尸进程就是这样一种进程: 它自身运行已经结束,但是进程控制块还没有释放.因为还有其他进程需要它的运行状态等信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;using namespace std;int main() &#123; pid_t pid; string message; int n; int exit_code; cout &lt;&lt; "fork program starting" &lt;&lt; endl; pid = fork(); switch (pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "this is the child"; n = 5; exit_code = 37; break; default: message = "this is the parent"; n = 10; exit_code = 0; break; &#125; for (; n &gt; 0; --n) &#123; cout &lt;&lt; message &lt;&lt; endl; sleep(1); &#125; if (pid != 0) &#123; int stat_val; pid_t child_pid; child_pid = wait(&amp;stat_val); // stat_val中保存这子进程的状态信息 cout &lt;&lt; "child has finished: PID: " &lt;&lt; child_pid &lt;&lt; endl; if (WIFEXITED(stat_val)) cout &lt;&lt; "child exited with code " &lt;&lt; WEXITSTATUS(stat_val) &lt;&lt; endl; else &#123; cout &lt;&lt; "Child terminated abnormally" &lt;&lt; endl; &#125; &#125; return exit_code;&#125; 运行过程中在命令行中查看wait进程的信息(上面这个程序在编译时被命名为wait) 12345678xixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 ./waitxixi@xixi:~$ ps -f -C waitUID PID PPID C STIME TTY TIME CMDxixi 16389 13738 0 19:32 pts/3 00:00:00 ./waitxixi 16390 16389 0 19:32 pts/3 00:00:00 [wait] &lt;defunct&gt; 上面的运行结果可以看出,一开始子进程正常运行,后来子进程变成了僵尸进程.如果父进程异常终止, 子进程将自动把pid等于1的进程(即init进程)作为自己的父进程.子进程现在是一个不再运行的僵尸进程,但是由于父进程异常终止,所以它由init进程接管.僵尸进程将一直保留在进程表中知道被init进程发现并释放.进程表越大,这一过程越慢. 常用的两种应用场景 一个父进程希望复制自己,使父子进程同时执行不同的代码段.这在网络服务中是常见的. 父进程等待客户端的服务请求.当这种请求到达时,父进程调用fork,使子进程处理此请求.父进程则继续等待下一个服务请求的到达. 一个进程要执行一个不同的程序.这是shell常见的情况.子进程从fork返回后立即调用exec. 123456789101112131415161718192021pid_t pid;int ctr = 0;cout &lt;&lt; "当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;// 在这个位置,仅仅父进程会执行cout &lt;&lt; "unique" &lt;&lt; endl;pid = fork(); // 仅调用一次,返回两次if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1);&#125; else if (pid == 0) &#123; ++ctr; cout &lt;&lt; "进入子进程, 当前进程id=" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125; else &#123; ++ctr; cout &lt;&lt; "当前进程id=" &lt;&lt; getpid() &lt;&lt; " ctr=" &lt;&lt; ctr &lt;&lt; endl;&#125;// 在这个位置,则父子进程都会执行cout &lt;&lt; "reduant" &lt;&lt; endl; 执行结果 123456当前进程, id=7346unique当前进程id=7346 ctr=1reduant进入子进程, 当前进程id=7347 父进程id=7346 ctr=1reduant 执行fork前, ctr=0; 执行fork后,对于父进程而言会执行ctr自增和打印进程信息两个操作. 因此打印出的ctr=1.对于子进程而言,由于执行fork前ctr=0,因此在子进程中ctr=0, 同样子进程执行ctr自增和打印进程信息操作.因此打印出的ctr=1 12345678910111213141516pid_t pid;int loop;// cout &lt;&lt; "我是父进程, 当前进程, id=" &lt;&lt; getpid() &lt;&lt; endl;for (loop = 0; loop &lt; 2; ++loop) &#123; pid = fork(); //一个子进程第一次调用fork,返回0,表示该进程本身是子进程,第二次fork产生一个以当前子进程为父进程的子进程 if (pid &lt; 0) &#123; cout &lt;&lt; "异常退出" &lt;&lt; endl; exit(1); &#125; else if (pid == 0) &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid&lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "loop=" &lt;&lt; loop &lt;&lt; " 我是进程" &lt;&lt; getpid() &lt;&lt; " 父进程id=" &lt;&lt; getppid() &lt;&lt; " 我刚刚fork了子进程 pid=" &lt;&lt; pid &lt;&lt; endl; sleep(5); &#125;&#125; 执行结果 123456loop=0 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5948loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0loop=1 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=5949loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0loop=1 我是进程5947 父进程id=19893 我刚刚fork了子进程 pid=5952loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0 过程解释 进程5947使用fork产生一个子进程5948. fork执行时loop=0.因此子进程5948中loop=0. 子进程5948第一次调用fork的返回值pid是0,表明进程5948是子进程, 因此直接打印出”loop=0 我是进程5948 父进程id=5947 我刚刚fork了子进程 pid=0”; 当进程5948第二次调用fork时, 产生一个新的子进程5949. 在进程5948中,调用fork函数前, loop=1,因此在新的子进程5949中loop=1. 也因此子进程5949只会调用一次fork(就会因为loop&gt;=2而跳出循环). 在子进程5949的运行过程中只会打印出”loop=1 我是进程5949 父进程id=5948 我刚刚fork了子进程 pid=0” 而对于进程5947, 在第一次循环结束后继续执行第二次循环. 此时loop=1. 调用fork后, 产生一个新的子进程5952, 该子进程中loop=1. 因此类似的, 进程5952只会打印出”loop=1 我是进程5952 父进程id=5947 我刚刚fork了子进程 pid=0” 参考文献[1] https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html[2] https://www.jianshu.com/p/586300fdb1ce]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO复用]]></title>
    <url>%2F2019%2F10%2F15%2FIO%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[IO复用是在阻塞IO基础上，通过某种机制同时对多个文件描述符进行监视的一种方式。 select服务端接收到来自客户端的消息后，不立即返回，而是等待几秒钟才继续向客户端回复消息。在客户端等待服务器回复的消息时，客户端处于睡眠状态，说明write系统调用是阻塞的。 epollepoll_create函数原型 1int epoll_create(int size); 功能：创建保存epoll文件描述符的空间。这些文件描述符正是监视对象。调用epoll_create函数时创建的文件描述符保存空间称为“epoll例程”。通过参数size传递的值决定epoll例程的大小，但该值只是向操作系统的建议。也就是该值并非用来决定epoll例程的大小，而仅供操作系统参考。epoll_create创建的这块空间归操作系统管理。因此，epoll_create返回文件描述符，此文件描述法主要用于区分epoll例程。返回值：成功时返回文件描述符，失败时返回-1。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux权限]]></title>
    <url>%2F2019%2F10%2F15%2Flinux%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[linux权限是linux中很重要的一部分。 linux设置用户ID和组ID与一个进程相关的ID有6个或更多。实际用户ID，实际组ID；有效用户ID，有效组ID，附属组ID；保存的设置用户ID，保存的设置组ID。实际用户ID和实际组ID标识我们到底是谁。这两个字段在登录时取自口令文件的登录项。通常在一个登录会话期间这些值并不会改变。有效用户ID，有效组ID，附属组ID决定我们的文件访问权限。保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。 通常有效用户ID等于实际用户ID，有效组ID等于实际组ID。当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID就是实际组ID。但是在文件模式字(st_mode)中设置一个特殊标志，其含义是“当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID”，同样在文件模式字中可以设置另一位，它将执行此文件的进程的有效组ID设置为文件的组所有者ID。在文件模式字的这两位被称为设置用户ID位和设置组ID位。 测试程序思路尚不清晰，还没有说清楚这个问题。 get_uid_etc.cpp 12345678#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main() &#123; printf("uid = %d, gid = %d, euid = %d, egid = %d\n", getuid(), getgid(), geteuid(), getegid()); return 0;&#125; 查看get_uid_etc.cpp，可以看出get_uid_etc.cpp属于root用户。 1234567xixi2@xixi2:~/liunx_prac$ ls -l get_uid_etc-rwxr-xr-x 1 root root 8488 10月 13 11:11 get_uid_etc# 设置用户ID位xixi2@xixi2:~/liunx_prac$ sudo chmod u+s get_uid_etcxixi2@xixi2:~/liunx_prac$ ls -l get_uid_etc-rwsr-xr-x 1 root root 8488 10月 13 11:11 get_uid_etc 使用who可以查看当前登录用户为xixi2。 12345xixi2@xixi2:~/liunx_prac$ whoxixi2 :0 2019-10-09 16:12 (:0)xixi2@xixi2:~/liunx_prac$ cat /etc/passwd | grep xixi2xixi2:x:1000:1000:xixi2,,,:/home/xixi2:/bin/bash 以xixi2身份运行get_uid_etc.cpp文件。 12xixi2@xixi2:~/liunx_prac$ ./get_uid_etc uid = 1000, gid = 1000, euid = 1000, egid = 1000 以root身份运行get_uid_etc.cpp文件。 12xixi2@xixi2:~/liunx_prac$ sudo ./get_uid_etc uid = 0, gid = 0, euid = 0, egid = 0 参考文献[1]深入了解linux权限：https://mp.weixin.qq.com/s/nxJe3XDighMysLgbSYxX9A[2]linux查看当前登录用户：https://blog.csdn.net/y874961524/article/details/71102134]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>chown</tag>
        <tag>chmod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix 高级环境编程系列2]]></title>
    <url>%2F2019%2F10%2F14%2Funix-%E9%AB%98%E7%BA%A7%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[此文档主要整理并记录liunx中常用的api． IOlseek函数原型：lseek(int fd, off_t offset, int whence);当whence为SEEK_CUR, 将该文件的文件偏移量设置为其当前值加offset；当whence为SEEK_END，则该文件的文件偏移量设置为文件长度加offset。功能：显式地为一个打开文件设置偏移量。返回值：若函数成功执行，返回新的文件偏移量。 read函数原型 1ssize_t read(int fd, void* buf, size_t nbytes); 成功时返回接收的字节数(但遇到文件结尾则返回0)，失败时返回-1.fd: 显示数据接收对象的文件描述符．buf: 要保存接收数据的缓冲地址值．nbytes: 要接收数据的最大字节数． write1ssize_t write(int fd, const void* buf, size_t nbytes); 成功时返回写入的字节数，失败时返回-1.fd: 显示数据传输对象的文件描述符．buf: 要保存传输数据的缓冲地址值．nbytes: 要传输数据的最大字节数． read和write都是系统调用。read和write都在内核执行，所以称这些函数为不带缓冲的IO函数。 fgetcfgetc从文件指针stream指向的文件中读取一个字符，读取一个字节后，光标位置后移一个字节。 fputc功能：把一个字符写到一个输出文件流中．它返回写入的值，如果失败，则返回EOF．putc函数的作用相当于fputc，但它可能被实现为一个宏．putchar相当于putc(c, stdout)，但它把单个字符写到标准输出．注意：putchar和getchar都是把字符当做int类型而不是char类型来使用的．这就允许文件尾标识取值-1，这是一个超出字符数字编码范围的值． fopenhttps://blog.csdn.net/hairetz/article/details/4150193 freadsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 功能：从给定流 stream 读取数据到 ptr 所指向的数组中 ptr – 这是指向带有最小尺寸 size\nmemb* 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 fgets函数原型为：char *fgets(char *str, int n, FILE *stream) 功能：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。fgets会把读到字符写到s指向的字符串里，直到出现下面某种情况： 遇到换行符 已经传输了n-1个字节 到达文件尾 它会把遇到的换行符也保存到s中．最后在s末尾加上一个表示结尾的空字符\0．一次调用最多只能传输n-1个字符，因为它必须把空字符加到字符串表示结尾． gets函数类似于fgets，但是它从标准输入流中取数据并丢弃遇到的换行符．它在接收字符串的尾部加上一个空字节(一个字符占一个字节)． fflush函数原型 1int fflush(FILE *stream); 功能：把文件流里的所有未写数据立刻写出(将进程缓冲区中的数据送入内核缓冲区中还是将数据从内核缓冲区写入磁盘？)。可以用这个函数来确保试图读入一个用户响应之前，先向终端送出一个交互提示符。使用这个函数还可以确保在程序继续执行之前重要的数据都已经被写到磁盘上。有时在调试程序时，你还可以用它来确认程序是正在写数据而不是被挂起了。注意，调用fclose函数隐含执行了一次flush操作，所以不必在调用fclose之前调用fflush。 puts12# include &lt;stdio.h&gt;int puts(const char *s); 功能：将字符串输出到屏幕。输出时只有遇到 ‘\0’ 也就是字符串结束标志符才会停止。 目录opendir123#include &lt;sys/types.h&gt; #include &lt;dirent.h&gt;DIR * opendir(const char * name); 功能：opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流．接下来对目录的读取和搜索都要使用此返回值． 返回值：成功则返回DIR*型态的目录流，打开失败则返回nullptr. 错误代码： EACCESS 权限不足 EMFILE 已达到进程可同时打开的文件数上限 ENFILE 已达到系统可同时打开的文件数上限 ENOTDIR 参数name 非真正的目录 ENOENT 参数name 指定的目录不存在, 或是参数name 为一空字符串 ENOMEM 核心内存不足 进程fork12 vfork函数原型 12 功能：vfork函数用于创建一个新进程．新进程的目的是exec一个新程序． vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中．因为子进程会立即调用exec(exit)，于是也就不会引用该地址空间．但是在子进程调用exec或exit之前，它在父进程的空间中运行． vfork和fork之间的另一个区别是：vfork保证子进程先运行．在它调用exec或exit之后父进程才可能被调度运行．当子进程调用这两个函数中的任意一个时，父进程会恢复运行．如果在调用这两个函数之前子进程依赖于父进程的进一步动作，会导致死锁． wait在父进程中通过调用wait函数来让父进程等待子进程的结束．wait系统调用将阻塞父进程直到它的子进程结束．这个调用返回子进程的PID，它通常是已经结束运行的子进程的PID．状态信息允许父进程了解子进程的退出状态，即子进程的main函数返回的值或子进程中exit函数的退出码．如果stat_loc不是空指针，那么状态信息就会被写入它所指向的位置．如果调用wait的进程有多个子进程，那么在其某一子进程终止时，wait就立即返回． 12#include&lt;sys/wait.h&gt;pid_t wait(int *stat_loc) 头文件sys/wait.h中定义的宏来解释状态信息． 12WIFEXITED(stat_val); // 如果子进程正常结束，它就取一个非零值WEXITSTATUS(stat_val); // 如果WIFEXITED非零，它返回子进程的退出码 waitpid函数原型 123#include&lt;sys/type.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *stat_loc, int options) 功能：waitpid用来等待某个特定进程的结束． pid参数用于指定需要等待的子进程的PID．如果它的值为-1，waitpid将返回任一子进程的信息． 如果stat_loc不是空指针，waitpid将状态信息写入到stat_loc指定的位置． option参数可用来改变waitpid的行为，其中一个最有用的选项是WNOHANG，它的作用是防止waitpid调用将调用者的执行挂起．可以使用这个选项来查找是否有子进程已经结束，如果没有，程序将继续执行．其他的选项和wait调用的选项相同． 返回值：如果子进程没有结束或意外终止，返回0；否则返回child_pid．如果waitpid失败，它将返回-1并设置errno．失败的情况包括：没有子进程(errno设置为ECHILD)，调用被某个信号中断(EINTR)，或选项参数无效(EINVAL)． exec函数族1int execl(const char*path, const char *arg,...) exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行参数path：可执行文件的路径名字arg：可执行程序所带的参数，第一个参数为可执行文件的名字，没有带路径且arg必须以空指针结束 https://blog.csdn.net/u014530704/article/details/73848573 进程同步用于进程的信号量线程pthread_create函数原型 1int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void*), void* arg); 功能：创建一个新线程 第一个参数指向一个pthread_t 类型的指针，线程被创建时，这个指针指向的变量中将被写入一个标识符，我们用该标识符来引用新线程． 第二个参数用于设置线程的属性；一般不需要特殊的属性，因此令该参数为NULL 第三个参数一个函数指针，告诉线程将要启动执行的函数 第四个参数是传递给该函数的参数 成功时，返回0；失败时，返回错误代码 pthread_join函数原型 1int pthread_join(pthread_t th, void **thread_return); 功能：pthread_join等价于进程中用来收集子进程信息的wait函数．调用进程将一直阻塞，直到指定的线程调用thread_exit或者从启动例程(即被调用的函数)中返回，或被取消。 第一个参数指定将要等待的线程，线程通过pthread_create返回的标识符来指定。第二个参数是一个指向指针的指针，而后者指向线程的返回值。 返回值：成功时返回0，失败时返回错误代码。 pthread_exit函数原型 1int pthread_exit(void * rval_ptr); 线程同步线程同步有几种方式。信号量、互斥量、 用于线程的信号量有两组接口函数用于信号量．一组取自POSIX的实时扩展，用于线程．另一组被称为系统V信号量，常用于进程的同步。信号量是一个特殊类型的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。 在多线程程序中，如果一个程序中有两个(或多个)线程试图改变一个信号量的值，系统将保证所有的操作都依次进行。信号量有二进制信号量和计数信号量。信号量一般用来保护一段代码，使其每次只能被一个执行线程运行，使用二进制信号量来完成这个工作。允许有限数目的线程执行一段指定的代码，这时需要计数信号量。 sem_init函数原型 1int sem_init(sem_t *sem, int pshared, unsigned int value); 功能：创建信号量；信号量由一个sem_t类型指针指定，设置该信号量对象的共享选项，并给它一个初始的整数值． 第一个参数为指向sem_t类型的信号量对象的指针． pshared表示该信号量对象的共享选项，若为0表示该信号量是当前进程的局部信号量，否则，这个信号量就可以在多个进程之间共享． sem_wait函数原型 1int sem_wait(sem_t* sem); 功能：以原子操作的方式给信号量的值减1.但是它会等待直到信号量有个非零值才会开始减法操作． sem_post函数原型 1int sem_post(sem_t* sem); 功能：以原子操作的方式给信号量的值加1. 互斥量另一种用在多线程程序中的同步访问方法是使用互斥量。它允许程序锁住某个对象，使得每次只能有一个线程访问它。为了控制对关键代码的访问，必须在进入这段代码之前锁住一个互斥量，然后在完成操作之后解锁它。互斥量又称为互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。以下这些用于互斥量的基本函数成功时返回0，失败时返回错误代码，但是这些函数并不设置errno，必须对函数的返回代码进行检查。 pthread_mutex_init函数原型 1int pthread_mutex_init(pthread_mutext_t *mutex, const pthread_mutexattr_t *mutexattr); 功能：初始化互斥锁。 pthread_mutex_lock函数原型 1int pthread_mutex_lock(pthread_mutex_t *mutex) 功能：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。 pthread_mutex_unlock函数原型 1int pthread_mutex_unlock(pthread_mutex_t *mutex); pthread_mutex_destroy函数原型 1int pthread_mutex_destroy(pthread_mutex_t *mutex) 功能：以原子操作的方式给一个互斥锁解锁。 条件变量条件变量又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制；当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用signal/broadcast。此时操作共享变量需要加锁。其主要系统调用如下：pthread_cond_init：初始化条件变量pthread_cond_destory：销毁条件变量pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正常访问。]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器失效]]></title>
    <url>%2F2019%2F10%2F14%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[当从容器中删除元素或者向容器中添加元素时，会出现迭代器失效问题。 map在c++11以前，map提供了void erase(iterator pos)来从map中删除元素，此函数返回值为void。因此，在这种情况，需要提前保存下一个有效位置迭代器来防止迭代器失效。在c++11之后，添加了iterator erase(iterator pos)来从map中删除元素，并返回下一个有效位置迭代器。此时，可以用提前保存下一个有效迭代器的方法，也可以用使用erase函数的返回值为迭代器重新赋值的方法。 参考文献[1]map迭代器失效问题：https://en.cppreference.com/w/cpp/container/map/erase]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[448.Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2019%2F10%2F14%2FFind-All-Numbers-Disappeared-in-an-Array%2F</url>
    <content type="text"><![CDATA[Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 解法2：原地修改遍历数组，每次检查一个元素。对于每个输入元素nums[i]，标记nums[nums[i] - 1]为负数，表示nums[i]出现过。第二遍遍历数组，若nums[i] &lt; 0，说明i + 1出现过，否则说明i+1没有出现过。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Single Number系列]]></title>
    <url>%2F2019%2F10%2F14%2FSingle-Number%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Single Number系列 Single NumberGiven a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 可能的解法有：排序后判断元素出现次数。 解法1：排序排序后查找每个元素是否只出现了一次，直到找到那个只出现了一次的元素。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; quickSort(nums, 0, nums.size() - 1); for(int i=0;i&lt;nums.size();++i)&#123; if(i &lt; nums.size()-1 &amp;&amp; nums[i]!= nums[i+1])&#123; return nums[i]; &#125;else&#123; ++i; &#125; &#125; return nums[nums.size()-1]; &#125; void quickSort(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; if(lo &gt;= hi)&#123; return; &#125; int pos = partition(nums, lo, hi); quickSort(nums, lo, pos - 1); quickSort(nums, pos + 1, hi); &#125; int partition(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; int i = lo - 1; int tmp; for(int j=lo;j&lt;hi;++j)&#123; if(nums[j] &lt;= nums[hi])&#123; tmp = nums[j]; nums[j] = nums[++i]; nums[i] = tmp; &#125; &#125; tmp = nums[hi]; nums[hi] = nums[++i]; nums[i] = tmp; return i; &#125;&#125;; 时间复杂度：O(nlogn)空间复杂度：O(logn) 解法2：位运算12345678910111213141516// 这里定义了一个lambda表达式并调用该表达式static int x = []()&#123; ios::sync_with_stdio(false); cin.tie(0); return 0; &#125;();class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ret=0; for(int i=0;i&lt;nums.size();i++)&#123; ret=ret^nums[i]; &#125; return ret; &#125;&#125;; Single Number IIGiven a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,3,2]Output: 3 Example 2: 12Input: [0,1,0,1,0,1,99]Output: 99 解法1：k个相同的k进制数进行无进位相加，结果一定是每一位都为0的k进制数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; e0(32, 0); for(int i=0;i&lt;nums.size();++i)&#123; setExclusiveOr(e0, nums[i], 3); &#125; int res = getNumFromKSysNum(e0, 3); return res; &#125; vector&lt;int&gt; getKSysNumFromNum(int value, int k)&#123; vector&lt;int&gt; res(32, 0); int index = 0; // low bit on left, high bit on right while(value !=0)&#123; res[index++] = value % k; value /= k; &#125; return res; &#125; void setExclusiveOr(vector&lt;int&gt;&amp; e0, int value, int k)&#123; vector&lt;int&gt; curKSysNum = getKSysNumFromNum(value, k); for(int i=0;i &lt; e0.size();++i)&#123; e0[i] = (e0[i] + curKSysNum[i]) % k; &#125; &#125; int getNumFromKSysNum(vector&lt;int&gt;&amp; e0, int k)&#123; int res = 0; for(int i=e0.size()-1;i&gt;=0;--i)&#123; res = res * k + e0[i]; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于快速排序过程中一个的问题：为什么在qsort中递归时，需要将递归范围改为[lo, pos-1]而不是[lo, pos]? 以下看一个具体例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; int i = lo - 1; int key = arr[hi]; for (int j = lo; j &lt; hi; ++j) &#123; if (arr[j] &lt;= key) &#123; ++i; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; arr[hi] = arr[i + 1]; arr[i + 1] = key; return i + 1;&#125;void qsort(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int pos = partition(arr, lo, hi); // 这里返回了pos=5,所以出现了递归调用，而且这个递归调用和之前的调用一模一样 qsort(arr, lo, pos - 1); qsort(arr, pos + 1, hi);&#125;int main() &#123; vector&lt;int&gt; arr&#123;12, 34, 11, 46, 12, 89&#125;; qsort(arr, 0, arr.size() - 1); for (auto c:arr) &#123; cout &lt;&lt; c &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 在归并排序过程中，递归的两个子范围为[lo, mid]和[mid+1, hi]。那是因为[lo, mid]区间必然是[lo, hi]区间的子区间，而不会和区间[lo, hi]重叠。而这里的pos是通过partition函数返回的，表示在数组中小于等于key的元素范围，pos有可能等于hi,这时区间[lo, pos]和区间[lo, hi]重叠，便会造成无法终止的递归调用。 但实际上，在快速排序的过程中，每次我们至少可以确定一个元素的位置，即主元的位置，因此，问题的规模会慢慢变小。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
    <url>%2F2019%2F10%2F14%2F145.-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the postorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? 非递归解法在遍历一个节点之前，以该节点为根的子树应该已经遍历完了。也就是说，如果一棵树的左子树未被遍历，则应该先遍历左子树，然后遍历右子树。根据这样的遍历顺序可知，在遍历序列中，左孩子在右孩子前面，右孩子在根前面。如果遍历到一个节点时，上一个遍历到的节点不是它的左孩子(当该节点的右孩子为空)，就是它的左孩子(该节点的左子树不为空)，或者其他节点(当该节点是叶子节点)。如果上一个被遍历的节点既不是该节点的左孩子也不是该节点的右孩子，且该节点不是叶子节点，那么说明该节点的左子树尚未被遍历，因此，先将左孩子加入到栈中。 如果上一个被遍历的节点是该节点的左孩子，那么说明该节点的左子树已经遍历完了。如果该节点的左子树为空，那么上一个被遍历的节点为其他节点。所以，当一个节点存在右孩子，且上一个被遍历的节点不是右孩子时，说明该节点的右子树尚未被遍历。因此，将右孩子加入到栈中。 AC代码 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(root == nullptr)&#123; return &#123;&#125;; &#125; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; res; TreeNode* cur; TreeNode* last = root; st.push(root); while(!st.empty())&#123; cur = st.top(); /* 如果该节点有左孩子且上一个遍历的节点不是左孩子也不是右孩子时 * 如果该节点的左右子树都已经被遍历， * 如果右子树不为空，上一个被遍历的节点应该是右孩子 * 如果右子树为空，上一个被遍历的节点为左孩子 */ if(cur-&gt;left != nullptr &amp;&amp; cur-&gt;left != last &amp;&amp; cur-&gt;right != last)&#123; st.push(cur-&gt;left); &#125;else if(cur-&gt;right != nullptr &amp;&amp; cur-&gt;right != last)&#123; st.push(cur-&gt;right); &#125;else&#123; res.push_back(cur-&gt;val); last = cur; st.pop(); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F10%2F14%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux常用命令有:grep, awk, ps等待． lsls用于显示指定工作目录之下的内容。列出目前工作目录所含之文件及子目录。 ls -F在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符ls-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出) ls -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出ls -r 将文件以相反次序显示(原定依英文字母次序)ls -t 将文件依建立时间之先后次序列出ls -A 同 ls -a ，但不列出 “.” (目前目录) 及 “..” (父目录) touchtouch可以创建一个空文件。同时该命令可以用于改变文件的修改时间。如果指定的文件不存在就创建它，否则就修改该文件的修改时间。但是该文件并不会将有内容的文件变为空文件。 cp复制空文件/dev/null是空设备。所有写向这个文件的输出都将被丢弃，而读这个设备会立刻返回一个文件尾标志。所以在cp命令里可以把它用作复制空文件的源文件。 1234567# 复制空文件xixi2@xixi2:~/liunx_prac$ sudo cp /dev/null null.txtxixi2@xixi2:~/liunx_prac$ ls -lF null.txt -rw-r--r-- 1 root root 0 10月 9 17:57 null.txt xixi2@xixi2:~/liunx_prac$ psps 命令是最常用的监控进程的命令，通过此命令可以查看系统中所有运行进程的详细信息。ps 命令的基本格式如下： 12345#查看系统中所有的进程，使用 BS 操作系统格式[root@localhost ~]# ps aux#查看系统中所有的进程，使用 Linux 标准命令格式[root@localhost ~]# ps -le 选项： a：显示一个终端的所有进程，除会话引线外；u：显示进程的归属用户及内存的使用情况；x：显示没有控制终端的进程；-l：长格式显示更加详细的信息；-e：显示所有进程； 可以看到，ps 命令有些与众不同，它的部分选项不能加入”-“，比如命令”ps aux”，其中”aux”是选项，但是前面不能带“-”。大家如果执行 “man ps” 命令，则会发现 ps 命令的帮助为了适应不同的类 UNIX 系统，可用格式非常多，不方便记忆。所以，我建议大家记忆几个固定选项即可。比如：“ps aux” 可以查看系统中所有的进程； “ps -le” 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级； “ps -l” 只能看到当前 Shell 产生的进程； ps auxps aux命令列出的各字段名及其含义 123456# 执行ps aux并输出其结果的前4行xixi2@xixi2:~/liunx_prac$ ps aux |head -n 4USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 225552 9252 ? Ss 16:11 0:03 /sbin/init splashroot 2 0.0 0.0 0 0 ? S 16:11 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? I&lt; 16:11 0:00 [rcu_gp] 表头 含义 USER 该进程是由哪个用户产生的。 PID 进程的 ID。 %CPU 该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。 %MEM 该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。 VSZ 该进程占用虚拟内存的大小，单位为 KB。 RSS 该进程占用实际物理内存的大小，单位为 KB。 TTY 该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 STAT 进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-&lt;：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。 START 该进程的启动时间。 TIME 该进程占用 CPU 的运算时间，注意不是系统时间。 COMMAND 产生此进程的命令名。 ps -le123456# 执行ps -le并输出其结果的前4行xixi2@xixi2:~/liunx_prac$ ps -le | head -n 4F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 1 0 0 80 0 - 56388 - ? 00:00:03 systemd1 S 0 2 0 0 80 0 - 0 - ? 00:00:00 kthreadd1 I 0 3 2 0 60 -20 - 0 - ? 00:00:00 rcu_gp 各字段含义 表头 含义 F 进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限； S 进程状态。具体的状态和”psaux”命令中的 STAT 状态一致； UID 运行此进程的用户的 ID； PID 进程的 ID； PPID 父进程的 ID； C 该进程的 CPU 使用率，单位是百分比； PRI 进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行； NI 进程的优先级，数值越小，该进程越早被执行； ADDR 该进程在内存的哪个位置； SZ 该进程占用多大内存； WCHAN 该进程是否运行。”-“代表正在运行； TTY 该进程由哪个终端产生； TIME 该进程占用 CPU 的运算时间，注意不是系统时间； CMD 产生此进程的命令名； killkillpkillkillall通过端口9190找到两个进程，然后使用killall杀死这两个进程。 1234xixi2@xixi2:~$ ps -ef | grep 9190 | grep -v "grep"xixi2 29417 29000 0 14:54 pts/5 00:00:00 ./echo_client 127.0.0.1 9190xixi2 29419 29016 0 14:54 pts/6 00:00:00 ./echo_client 127.0.0.1 9190xixi2@xixi2:~$ killall "echo_client" echo单引号会把所有字符看作是普通字符，双引号会无视通配符，但是会解释”$”，”&quot;，”`”这三种特殊符号，不加引号则会解释所有特殊字符。 wc12345678$ wc testfile # testfile文件的统计信息 3 92 598 testfile # testfile文件的行数为3、单词数92、字节数598 $ wc testfile testfile_1 testfile_2 #统计三个文件的信息 3 92 598 testfile #第一个文件行数为3、单词数92、字节数598 9 18 78 testfile_1 #第二个文件的行数为9、单词数18、字节数78 3 6 32 testfile_2 #第三个文件的行数为3、单词数6、字节数32 15 116 708 总用量 #三个文件总共的行数为15、单词数116、字节数708 -c或–bytes或–chars 只显示Bytes数。 -l或–lines 只显示行数。 -w或–words 只显示字数。 grep grep --color选项，高亮要查找的字符串．如，在/etc/passwd文件中查找某个字符串出现的行 12root@root:~$ grep --color "la" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false # 在我的机器上的结果 grep -v选项，实现反查效果，显示出所有不包含被查询字符串的行． 12345grep -v "la" /etc/passwd# 在我的机器上的执行结果sshd:x:123:65534::/run/sshd:/usr/sbin/nologinnvidia-persistenced:x:124:129:NVIDIA Persistence Daemon,,,:/nonexistent:/sbin/nologin grep 展示行号和统计行数 使用-n选项，grep不仅能搜索到字符串，还能展示出它们位于文件的第几行． 使用-c选项，grep可以统计搜索结果中的总行数 12345678910root@root:~$ grep -n "la" /etc/passwd# 行首的40表示出现的行号40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot@root:~$ grep -c "la" /etc/passwd1root@root:~$ grep -c "var" /etc/passwd22 grep可以环顾四周 在输出时，同时输出搜索结果相邻的行也输出出来． -A number 表示输出搜索结果下面的行(number表示要输出的行数) A是after的缩写 -B number 表示输出搜索结果上面的行(number表示要输出的行数) B是before的缩写 12345678910111213root@root:~$ grep -A 1 "la" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot:x:1000:1000:root,,,:/home/root:/bin/bashroot@root:~$ grep -n -A 2 "la" /etc/passwd40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false41-root:x:1000:1000:root,,,:/home/root:/bin/bash42-redis:x:122:128::/var/lib/redis:/usr/sbin/nologinroot@root:~$ grep -n -A 1 -B 1 "la" /etc/passwd39-gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false40:gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false41-root:x:1000:1000:root,,,:/home/root:/bin/bash grep 不区分大小写 grep -i选项不区分大小写，提高搜索命中的概率 123root@root:~$ grep --color "LA" /etc/passwdroot@root:~$ grep --color -i "LA" /etc/passwdgdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false grep处理多文件 grep可以一次处理多个文件，最长使用的一个场景是:从大量文件中找出含有特定字符的文件． grep -l “query key word” *.txt从多个文件中查找含有被查询的关键词的文件有哪些，应该得到一个文件列表 grep -L “query key word” .txt反向选项，从多个文件中查找*不包含**被查询的关键词的文件有哪些，应该得到一个文件列表 123456789101112131415161718192021# 当前目录下有三个文件[roc@roclinux ~]$ lltotal 12-rw-rw-r-- 1 roc roc 58 Mar 15 17:47 1.txt-rw-rw-r-- 1 roc roc 59 Mar 15 17:51 2.txt-rw-rw-r-- 1 roc roc 58 Mar 15 17:52 3.txt # 1.txt文件的内容如下[roc@roclinux ~]$ cat 1.txtthis first filethis file contain some import infomation. # 2.txt文件的内容如下[roc@roclinux ~]$ cat 2.txtthis second filethis file contain some import infomation. # 3.txt文件的内容如下[roc@roclinux ~]$ cat 3.txtthis third filethis file contain some import infomation. 123# 使用-l选项[roc@roclinux ~]$ grep -l "first" *.txt1.txt 123[roc@roclinux ~]$ grep -L "first" *.txt2.txt3.txt grep支持正则表达式 ^sp表示以sp开头的行；se$表示以se结尾的行． 1234root@root:~$ grep '^sp' -c /etc/passwd1root@root:~$ grep 'sp' -c /etc/passwd5 1234root@root:~$ grep 'se' -c /etc/passwd7root@root:~$ grep 'se$' -c /etc/passwd5 grep查询一个词 如要搜索含有bin这个词的行 1234567891011root@root:~$ grep '\&lt;bin\&gt;' /etc/passwd --colorroot:x:0:0:root:/root:/bin/bashbin:x:2:2:bin:/bin:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncproxy:x:13:13:proxy:/bin:/usr/sbin/nologinspeech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/falsewhoopsie:x:112:117::/nonexistent:/bin/falsehplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/falsegnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/falsegdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/falseroot:x:1000:1000:root,,,:/home/root:/bin/bash 这样的词有一个问题，那就是连sbin这样的词也会被搜索出来．因此，我们需要理解词的定义，以及正则表达式中如何表示一个词．首先，正则表达式中的词(word)，一般是由字母，数字和下划线组成，且词和词之间通常使用空格，制表符或换行符分隔．举个’栗子’，“I love you.”中的“love”就是一个“词”，但“My gloves are red.”中的“love”就不能称作一个“词”。在正则表达式中，通常用尖括号表示一个词，比如能够匹配I love you.但不能匹配My gloves are red. 正则表达式awkawk命令是一个非常棒的数据处理工具．sed命令一次处理一整行，awk命令一次处理一整行，但将每行的内容分成多个字段来处理． uniqsortsort对文本进行排序。可以按照字典顺序进行排序，或者按照数字排序或者按照特定列排序。sort默认按照字典序进行排序。和sed命令类似，sort命令不会修改原文件。 sort -n：按数值来进行比较，只会傻傻地比较数字，他会认为98K大于2G。 sort -h：先比较单位，然后比较数值。 sort -u：去除重复行 sort -t：指定分隔符，未指定时，默认分隔符为空白 sort -k指定列排序 sort -o：如果需要将排序结果保存到文件中，需要使用-o选项 sort -c：用来检查文本内容是否已经是排好序的 sort -m：合并已经排好序的文本，但不会重新排序 例子xargsxargs是execute argument的缩写，它的作用是从标准输入中读取内容，并将此内容传递给它要协助的命令，并作为那个命令的参数来执行。 cat命令可以接收文件名作为参数，执行后会显示出文件的内容。但是cat命令不能直接从标准输入接收参数。 管道可以实现：将前面的标准输出作为后面的“标准输入”；管道无法实现：将前面的标准输出作为后面的“命令参数”。xargs可以实现：将标准输入(前一个命令的标准输出)作为其指定命令的参数。 xargs 的标准输入中出现的“换行符、空格、制表符”都将被空格取代。 一个例子 123456789101112131415161718192021222324#我们创建了3个日志文件, 且故意让文件名称中都含有空格[xixi2@xixi2 ~]$ for((i=0;i&lt;3;i++)); do touch "test $&#123;i&#125;.log";done[xixi2@xixi2 ~]$ ls -Ftest 0.log test 1.log test 2.log# 首先使用find命令找出这三个文件[xixi2@xixi2 ~]$ find -name '*.log' -print./test 0.log./test 2.log./test 1.log# 使用xargs命令删除这三个文件，出现错误[xixi2@xixi2 ~]$ find . -name '*.log' -print | xargs rmrm: 无法删除'./test': 没有那个文件或目录rm: 无法删除'0.log': 没有那个文件或目录rm: 无法删除'./test': 没有那个文件或目录rm: 无法删除'2.log': 没有那个文件或目录rm: 无法删除'./test': 没有那个文件或目录rm: 无法删除'1.log': 没有那个文件或目录# 使用xargs命令删除这三个文件，正确删除[xixi2@xixi2 ~]$ find . -name '*.log' -print0 | xargs -0 rm -f 当 find 命令获取到的文件名经过 xargs 传送给 rm 命令时，文件“./test 1.log”就变成了“./test”和“1.log”两个文件了。即原本 3 个文件名刹那间就变成了 6 个文件名，而这 6 个文件其实并不存在，从而引发了错误。xargs -0选项可以将分隔符从默认的空格变成NULL，还会将单引号、双引号、反斜线等统统看作是普通字符。所以说，-0选项特别适合处理命令参数中含有引号、空格、反斜线的情况。xargs -d选项可以用来指定任何一个符合作为分隔符。xargs -p选项可以让我们在命令执行过程中进行确认。如果在前一个命令的标准输出中，会有一些参数是你不希望或者不确定是否要传送给后面命令的，这个时候我们就希望 xargs 在传送参数前和我们确认一下。但是此时对所有的参数仅询问一次。如果再加上-n选项可以逐个确认。xargs -E当碰到某个特定的命令参数时，要求xargs立即终止并退出。 xargs可以处理参数列表过长的问题。借助xargs，并利用管道的特性。将前一个命令的标准输出分段传给后一个xargs，然后作为其指定命令的参数。例子：创建10万个日志文件，并且用rm命令一次性删除。 123456# 创建10万个日志文件[xixi2@xixi2 ~]$ for((i=0;i&lt;100000;i++)); do touch test$&#123;i&#125;.log; done# 用rm命令删除文件[xixi2@xixi2 ~]$ rm $(find . -type f -name '(.log')bash: /bin/rm: 参数列表过长 参数列表过长，说明rm可接受的参数长度达到了极限。系统限制了参数的长度。可以通过下面的命令查看系统的参数长度限制值。 12[xixi2@xixi2 ~]$ getconf ARG_MAX2097152 当遇到参数过长的问题，解决方法有多种。比如说手工分组以缩短参数的长度。但是这个方法并不优雅，而且费时费力。最优雅的方法当然是借助xargs。 1[xixi2@xixi2 ~]$ find . -type f -name '*.log' | xargs rm cutcut负责在文件中剪切数据。cut是以每一行作为一个处理对象。 cut的定位依据 cut有三类定位方法 按字节(bytes)定位(字节从1开始计算)，用-b选项 按字符(characters)定位，用-c选项 按域(field)定位，用-f选项 字节定位的技巧 -b选项支持3-5这样的写法，而且多个定位数字之间还可以用逗号隔开 -b选项定位时会将所有的定位数字按照从小到大的顺序排序，然后再依次提取。可以随意颠倒定位数字的顺序 定位数字的设置 只限定最大定位数或最小定位数 cut -d自定义分隔符，默认为制表符；cut只允许分隔符是一个字符．因此，我们知道cut不善于处理”多空格分隔”的情况． 例子1234567891011121314151617# 查看文件aa.txt的内容[xixi2@xixi2 ~]$ cat aa.txtgood day nice to meet you# 查看文件aa.txt的信息[xixi2@xixi2 ~]$ ls -l aa.txt -rw-r--r-- 1 xixi2 xixi2 26 9月 28 16:58 aa.txt[xixi2@xixi2 ~]$ echo "good day nice to meet you" | cut -b 1g[xixi2@xixi2 ~]$ echo "good day nice to meet you" | cut -b 1-4,6-8goodday# 范围1-4和6-8可以颠倒着写，但是1和4(6和8)不能颠倒[xixi2@xixi2 ~]$ echo "good day nice to meet you" | cut -b 6-8,1-4goodday 定位数字的设置，只限定最大定位数或最小定位数 1234567891011# -3表示从头到第3个字节，包括第3个字符[xixi2@xixi2 ~]$echo "good day nice to meet you" | cut -b -3goo# 3-表示从第三个字节到行尾，包括第3个字符[xixi2@xixi2 ~]$echo "good day nice to meet you" | cut -b 3-goo# 没有同时出现两个第3个字符o，只出现了一个[xixi2@xixi2 ~]$ echo "good day nice to meet you" | cut -b -3,3-good day nice to meet you cut -f按字段进行分割cut -d可以设置分隔符，但是只能设置一个字符。cut只允许分隔符是一个字符。 123456789101112131415[xixi2@xixi2 ~]$ cut -f 3 aa.txt good day nice to meet you# 以空格为分割符，取其中的第3个字段# -d选项设置分隔符，且只能设置为１个空格，cut只允许分隔符是一个字符[xixi2@xixi2 ~]$ cut -d ' ' -f 3 aa.txt nice# 取第3到第6个字段，包括第6个字段[xixi2@xixi2 ~]$ cut -d ' ' -f 3-6 aa.txt nice to meet you# 取前3个字段，包括第3个字段[xixi2@xixi2 ~]$ cut -d ' ' -f -3 aa.txt good day nice 设置其他分隔符 123456789# ac.txt是以:为分隔符的文件[xixi2@xixi2 ~]$cat ac.txt aa:bb:cc:dd:eeff:ee:hh:ee:jj# 以:为分隔符，取第4到第6个字段，包括第4个字段[xixi2@xixi2 ~]$cut -d ':' -f 4- ac.txt dd:eeee:jj 识别空格和制表符1234567891011# 查看文件内容[xixi2@xixi2 ~]$ cat tab_space.txthello worldgood daya hibad weather ok# 使用sed命令确认文件内容到底是制表符还是空格[xixi2@xixi2 ~]$sed -n l tab_space.txt hello\tworld$good\tdaya hi$bad weather\tok$ 如果是制表符，就会显示为\t符号；如果是空格，就会原样显示． ps和cut一起使用时出现的重复现象12345[xixi2@xixi2 ~]$ ps | cat PID TTY TIME CMD 3622 pts/2 00:00:00 bash 3630 pts/2 00:00:00 ps 3631 pts/2 00:00:00 cat ps | cut 组合命令会产生两个进程，即ps进程和cat进程．其中ps进程为写进程，cat为读进程．当ps进程执行时，也会列出cat命令对应的进程的信息． 同样的，ps | cut -b 3组合命令也会产生两个进程，即ps进程和cut进程，其中ps进程为写进程，cut进程为读进程．当ps进程执行时，也会列出cut进程的信息，并且将所有进程的信息都通过管道输出给cut进程． sedsed是stream editor的缩写，中文称之为“流编辑器”。sed命令是一个面向行处理的工具，它以行为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出(STDOUT)。sed命令不会对读取的文件作任何贸然的修改，而是将内容都输出到标准输出中。 sed的命令格式： 1sed [options] [command] file command部分：针对每行的内容所要进行的处理 file部分：要处理的文件，如果忽略file参数，则sed会把标准输入作为处理对象。 sed命令是面向行进行处理的，每一次处理一行内容。处理时，sed会把要处理的行存储在缓冲区中，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕(标准输出)。接着处理下一行，这样不断重复，直到文件末尾。这个缓冲区被称为”模式空间”。 sed -n：-n选项警告sed命令：除非是明确表明要输出的行，否则不要输出．-n选项经常和p配合使用，其含义就是，输出那些匹配的行． commandcommand分为两块：一块是范围设定，一块是动作处理． 范围设定 指定行数 3,5表示第3,4,5行 5,$表示第5行至文件最后一行 模式匹配 /^[^Dd]/表示匹配行首不是以d或D开头的行 /^[dD]/表示匹配所以以d或D开头的行 动作处理 d：表示删除行 p：打印该行 r：读取指定文件的内容 w：写入指定文件 a：在下面插入新行新内容 command部分采用/AA/s/BB/CC/g表示匹配到文件中带有AA的行，并且将这些行中所有的BB替换成CC。 options-a 在当前行下面插入文件-n读取下一个输入行，用下一个命令处理新的行而不是用第一个命令-e执行多个sed命令-f运行脚本-i编辑文件内容-i.bak编辑的同时创造.bak的备份-r使用扩展的正则表达式 命令i在当前行上面插入文件c把选定的行改为新的指定的文本p打印d删除r/R读取文件/一行w另存s替换y替换h拷贝模板块的内容到内存中的缓冲区H追加模板块的内容到内存中的缓冲区g获得内存缓冲区的内容，并替代当前模板块中的文本G获得内存缓冲区的内容，并追加到当前模板块文本的后面D删除\n之前的内容 替换标记数字：表明新文本将替换第几处模式匹配的地方g：表示新文本将会替换所有匹配的文本\1：子串匹配标记，前面搜索可以用元字符集&amp;：保留搜索的字符用来替换其他字符 示例全局文本替换s只能局部替换，g会全局替换 123456789101112131415161718192021222324252627282930313233343536373839404142# s表示替换，将apple替换为dogxixi2@xixi2:~/liunx_prac$ echo "this is an apple" | sed 's/apple/banana/'this is a banana# 从文件中读取数据# 查看apple.txt文件内容xixi2@xixi2:~/liunx_prac$ cat apple.txt this is an applewhat do you prefer? an apple or an orangean apple a day keeps the doctor awayyou need to eat more apples# 把apple替换为banana# 其中/是定界符，定界符可以更改xixi2@xixi2:~/liunx_prac$ sed 's/apple/banana/' apple.txt this is an bananawhat do you prefer? an banana or an orangean banana a day keeps the doctor awayyou need to eat more bananas# 查看banana.txt文件的内容xixi2@xixi2:~/liunx_prac$ cat banana.txt what do you prefer? an apple or an orangean apple a day keeps the doctor awayyou need to eat more appleswhat do you want? an apple or an orange?# 将banana.txt文件中的or替换为and# s只会部分替换xixi2@xixi2:~/liunx_prac$ sed 's/or/and/' banana.txt what do you prefer? an apple and an orangean apple a day keeps the doctand awayyou need to eat mande appleswhat do you want? an apple and an orange?# 将banana.txt文件中的or替换为and# g会全部替换xixi2@xixi2:~/liunx_prac$ sed 's/or/and/g' banana.txt what do you prefer? an apple and an andangean apple a day keeps the doctand awayyou need to eat mande appleswhat do you want? an apple and an andange? 更改定界符/12345678910111213# 查看apple2.txt的内容xixi2@xixi2:~/liunx_prac$ cat apple2.txt apples/bananas/fruits/good/bad/no/ho/orange/doctor/fever/apple/bad/no/hi/# 使用#作为定界符xixi2@xixi2:~/liunx_prac$ sed 's#no/# yes!#' apple2.txt apples/bananas/fruits/good/bad/ yes!ho/orange/doctor/fever/apple/bad/ yes!hi/ 按行查找替换用数字表示行范围，$表示行尾用文本模式配置过滤 12345678910111213141516171819xixi2@xixi2:~/liunx_prac$ cat apple.txt this is an applewhat do you prefer? an apple or an orangean apple a day keeps the doctor awayyou need to eat more apples# 把第二行的apple替换为bananaxixi2@xixi2:~/liunx_prac$ sed '2s/apple/banana/' apple.txt this is an applewhat do you prefer? an banana or an orangean apple a day keeps the doctor awayyou need to eat more apples# 将第二行到最后一行中的apple全部替换为bananaxixi2@xixi2:~/liunx_prac$ sed '2,$s/apple/banana/' apple.txt this is an applewhat do you prefer? an banana or an orangean banana a day keeps the doctor awayyou need to eat more bananas 删除d1234567891011121314151617181920212223242526xixi2@xixi2:~/liunx_prac$ cat apple.txt this is an applewhat do you prefer? an apple or an orangean apple a day keeps the doctor awayyou need to eat more applesI have to buy some apples.which color is the apple? blue or red# 删除第二行的内容xixi2@xixi2:~/liunx_prac$ sed '2d' apple.txt this is an applean apple a day keeps the doctor awayyou need to eat more applesI have to buy some apples.which color is the apple? blue or red# 删除第二行到第四行的内容xixi2@xixi2:~/liunx_prac$ sed '2,4d' apple.txt this is an appleI have to buy some apples.which color is the apple? blue or red# or表示查找，匹配了第2(or)，3(doctor),4(more),6(color)，所以这些行被删除xixi2@xixi2:~/liunx_prac$ sed '/or/d' apple.txt this is an appleI have to buy some apples. 添加行命令i(insert插入)，在当前行前面插入一行命令a(append追加)，在当前行后面添加一行 123456789101112131415161718# 在前面添加一行xixi2@xixi2:~/liunx_prac$ echo "hello world" | sed 'i\nice to meet you'nice to meet youhello world# 在后面添加一行xixi2@xixi2:~/liunx_prac$ echo "hello world" | sed 'a\nice to meet you'hello worldnice to meet you# 在最后一行后面添加内容xixi2@xixi2:~/liunx_prac$ sed '$a\what dose an apple look like?' apple.txt this is an apple# 在第二行后面添加内容xixi2@xixi2:~/liunx_prac$ sed '2a\what dose an orange look like?' apple.txt # 在第二行和第四行后添加内容xixi2@xixi2:~/liunx_prac$ sed '2,4a\what dose an orange look like?' apple.txt 修改命令c1234567891011121314151617181920# 查看fruits.txt的内容xixi2@xixi2:~/liunx_prac$ cat fruits.txt this is an applean apple a day keeps the doctor awayyou need to eat more appleswhich color is the apple? blue or red# 把fruits.txt第四行的内容替换为I want an apple# 注意这里是反斜杠\xixi2@xixi2:~/liunx_prac$ sed '4c\I want an apple' fruits.txt this is an applean apple a day keeps the doctor awayyou need to eat more applesI want an apple# 把第二行到第四行的内容修改为I want an apple# 注意替换和修改的区别，第二行到第四行的内容都没有了，并且本来有3行，修改后只有一行了。xixi2@xixi2:~/liunx_prac$ sed '2,$c\I want an apple' fruits.txt this is an appleI want an apple -i选项修改原文件1234567891011121314151617181920212223xixi2@xixi2:~/liunx_prac$ cat fruit.txt this is an applean apple a day keeps the doctor awayyou need to eat more appleswhich color is the apple? blue or red# 修改fruit.txt第三行的内容并将修改写入原文件xixi2@xixi2:~/liunx_prac$ sed -i '3c\do you hava a banana?' fruit.txt # 重新查看原文件内容，发现原文件发生了变化xixi2@xixi2:~/liunx_prac$ cat fruit.txt this is an applean apple a day keeps the doctor awaydo you hava a banana?which color is the apple? blue or red# sed -i s命令使用场景：修改服务器配置文件xixi2@xixi2:~/liunx_prac$ sed -i 's/or/test/' fruit.txt xixi2@xixi2:~/liunx_prac$ cat fruit.txt this is an applean apple a day keeps the docttest awaydo you hava a banana?which coltest is the apple? blue or red findlinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 1find path -option [-print] [-exec -ok command] &#123;&#125; \; 1find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; &lt;指定目录&gt;：所要搜索的目录及其所有子目录。默认为当前目录。&lt;指定条件&gt;：所要搜索的文件的特征。&lt;指定动作&gt;：对搜索结果进行特定的处理。如果什么参数都不加，find默认搜索当前目录及其子目录，并且不过滤任何结果(也就是返回所有文件)，将它们全部显示在屏幕上。 -amin n：在过去n分钟内被读取过-cmin n：在过去n分钟内被修改过-ctime n：在过去n天内被修改过-atime n：在过去n天内被读取过-name name, -iname name：文件名称符合name的文件。iname会忽略大小写。-size n：文件大小是n单位，b代表512位元祖的区块，c表示字元数，k表示kilo bytes，w是一个二个位元组。-type c：文件类型是c的文件。 d：目录 c：字型装置文件 b：区块装置文件 p：具名伫列 f：一般文件 l：符号链接 s：socket -pid n：process id是n的文件-perm：权限，查找具有指定权限的文件和目录，权限的表示如711，644。-user：查找属于user指定用户的所有的文件。-group：查找属于-print：将搜索结果输出到标准输出。-ok：查找后执行命令的时候询问是否要执行。-exec：对搜索的结果指令指定的shell命令，执行的时候不询问用户，直接执行。 格式：-exec 命令 {} ;在}和\一定要有空格才行；{}的作用：{}表示命令的参数，即找到的文件；命令的末尾必须以”;“结束； -ok选项和-exec选项的作用基本一致，区别在于：”-exec”的命令会直接处理，而不询问；”-ok”的命令 2 在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。 dudu(disk usage)，用来展示磁盘使用量的统计信息．du的默认单位是KB，即1024bytes。但是du的单位还与其他一些设置相关。 1.如果通过–block-size选项设置了块大小，那么，这会成为du输出信息的单位。2.如果上一条没满足，且设置了环境变量DU_BLOCK_SIZE，这会成为du输出信息的单位。3.如果前两条都不满足，且设置了环境变量BLOCK_SIZE，这会成为du输出信息的单位。3.如果前三条都不满足，且设置了环境变量BLOCKSIZE，这会成为du输出信息的单位。4.如果前四条的都不满足，且设置了环境变量POSIXLY_CORRECT，则du输出信息的单位是512bytes。5.如果前五条都不满足，且du的输出信息的单位是1024bytes，即KB。 du和ls在展示文件大小的时候，存在着本质的区别： du展示的是磁盘空间占用量。 ls展示的是文件内容的大小(文件内容的大小如何计算)。 一个例子(可以看出du和ls命令的不同) 123456789101112131415# 有一个文件, 里面只输入了a、b两个英文字母xixi2@xixi2:~/liunx_prac$ cat a.txt ab# 用这个方法, 我们可以把文件里的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符。xixi2@xixi2:~/liunx_prac$ sed -n l a.txtab$# 用ls来查看大小, 发现展示的是3字节xixi2@xixi2:~/liunx_prac$ ls -l a.txt-rw-r--r-- 1 root root 3 9月 28 11:16 a.txt# 用du来查看大小, 发现竟然展示的是4KBxixi2@xixi2:~/liunx_prac$ du -h a.txt4.0K a.txt 文件中有三个字符，两个可见字符ab和一个控制字符$，每个字符1个字节，因此这个文件的内容大小就是3bytes。但是由于一个数据块最多只能存一个文件的限制，所以需要一个数据块来存储这个文件，因此这个文件实际占用的磁盘空间就是4KB。 文件系统进驻磁盘之初，就会将磁盘按固定数据块(block)大小进行分隔切块，通常情况下每一个固定数据块大小会被设定为4096bytes，也就是4KB。同时，大部分文件系统规定：1.一个数据块中最多存放一个文件的内容，当没有存满时，剩余的空间不得被其他文件使用。2.当一个文件的内容较大时，则可以存储到多个数据块中。 当文件中存在空洞时，du命令的结果比ls命令的结果要小。 1234567891011121314151617181920212223242526272829303132333435# 有一个文件, 里面只输入了a、b两个英文字母xixi2@xixi2:~/liunx_prac$ cat b.txt ab# 用这个方法, 我们可以把文件里的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符。xixi2@xixi2:~/liunx_prac$ ls -l b.txt-rw-r--r-- 1 xixi2 xixi2 3 9月 28 11:32 b.txt# 在b.txt中，用dd命令创造一个大小为1G的空洞xixi2@xixi2:~/liunx_prac$ dd if=/dev/zero of =b.txt oflag=append bs=1M seek=1024 count=0dd: you probably want conv=notrunc with oflag=append记录了0+0 的读入记录了0+0 的写出0 bytes copied, 8.4029e-05 s, 0.0 kB/s # 看看b.txt文件内容，\000代表空洞xixi2@xixi2:~/liunx_prac$ sed -n l b.txt | head -n 10ab$\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\# 用ls查看，b.txt的文件内容大小为1.0Gxixi2@xixi2:~/liunx_prac$ ls -lh b.txt -rw-r--r-- 1 xixi2 xixi2 1.0G 9月 28 11:35 b.tx# 用du查看b.txt占用的磁盘空间，仍然只用了一个数据块4KBxixi2@xixi2:~/liunx_prac$ du -h b.txt 4.0K b.txt 一个文件中的空洞，并不占用磁盘空间，但是这个空洞本身会被认为是文件内容的一部分，所以ls的值很大，但是du的结果仍然保持。 dddd(device driver)，它用来读取设备、文件中的内容，并原封不动地复制到指定位置。 date日期换算：距离1970-01-01这个日期15775天的日期是哪一天？ 12date -d "1970-01-01 15775 days"2013年03月11日 星期一 00:00:00 CST statstat命令用于显示inode的内容。格式：stat [文件或目录] 12345678910111213141516171819202122232425# 文件1_1_bak.txt是一个符号链接，它指向文件1.txtxixi2@xixi2:~/liunx_prac$ ls -l 1_1_bak.txt lrwxrwxrwx 1 xixi2 xixi2 5 10月 8 23:17 1_1_bak.txt -&gt; 1.txt # 查看文件1.txt的i节点(inode)内容xixi2@xixi2:~/liunx_prac$ stat 1.txt 文件：1.txt 大小：58 块：8 IO 块：4096 普通文件设备：805h/2053d Inode：27265977 硬链接：2权限：(0664/-rw-rw-r--) Uid：( 1000/ xixi2) Gid：( 1000/ xixi2)最近访问：2019-10-09 17:58:09.590182076 +0800最近更改：2019-10-09 17:58:03.345970241 +0800最近改动：2019-10-09 17:58:03.345970241 +0800创建时间：- # 查看文件1_1_bak.txt的i节点(inode)内容xixi2@xixi2:~/liunx_prac$ stat 1_1_bak.txt 文件：1_1_bak.txt -&gt; 1.txt 大小：5 块：0 IO 块：4096 符号链接设备：805h/2053d Inode：27265972 硬链接：1权限：(0777/lrwxrwxrwx) Uid：( 1000/ xixi2) Gid：( 1000/ xixi2)最近访问：2019-10-10 20:54:22.155852935 +0800最近更改：2019-10-08 23:17:03.850733670 +0800最近改动：2019-10-09 17:08:13.776647219 +0800创建时间：- 可以得知，stat不会跟随符号链接。无论是对于普通文件还是符号链接文件，都显示的是文件本身的inode内容。 treetree用于以树状图列出目录的内容。执行tree名，它会列出指定目录下的所有文件，包括子目录里的文件。 真实案例 如何将父目录中的所有文件，不包括子文件夹拷贝到某个子目录中 参考文献[1]grep: http://c.biancheng.net/linux/grep.html[2]find: http://c.biancheng.net/view/779.html[3]find: https://www.runoob.com/linux/linux-comm-find.html[4]图解linux最常用命令: https://mp.weixin.qq.com/s/Sq6OZyr2LgseUdOZROzoZg[5]tree: https://www.runoob.com/linux/linux-comm-tree.html[6]awk：http://c.biancheng.net/view/4082.html[7]fdisk：https://www.runoob.com/linux/linux-comm-fdisk.html[8]sort：https://mp.weixin.qq.com/s/LcO0XF3pzBoX9G3Pa1WKEA]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>awk</tag>
        <tag>grep</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能指针]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[智能指针有三类: shared_ptr, unique_ptr, weak_ptr.其中shared_ptr可以和其他shared_ptr共享内存,指向同一块内存区域,引用计数用于记录指向该内存的shared_ptr个数. unique_ptr只能独占内存.任意时刻,都只有一个unique_ptr指向一个给定对象.当unique_ptr被销毁时, 它所指向的对象也会被销毁. weak_ptr是一种弱引用,指向shared_ptr所管理的对象. shared_ptr 初始化shared_ptr有三种初始化方式: 使用make_shared&lt;T&gt;(obj)初始化 使用同类型内置指针对shared_ptr进行初始化 使用另一个智能指针进行初始化 reset将一个新的内置指针赋予shared_ptr use_count引用计数 默认情况下,一个用来初始化智能指针的内置指针必须指向动态内存,因为智能指针默认使用delete释放它所关联的对象.我们也可以将智能指针绑定一个指向其他类型对象的指针上,但是此时必须提供自己的操作来代替delete.这个自己的操作就是删除器函数,即,我们必须定义一个自己的函数作为新的删除器函数. 1234567891011121314void f1()&#123; // 使用对象初始化智能指针 shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(12); cout &lt;&lt; *p &lt;&lt; " " &lt;&lt; p.use_count() &lt;&lt; endl; // 使用智能指针初始化智能指针 shared_ptr&lt;int&gt; p2(p); cout &lt;&lt; *p2 &lt;&lt; " " &lt;&lt; p2.use_count() &lt;&lt; endl; // 使用内置指针初始化智能指针 int *p3 = new int(193); shared_ptr&lt;int&gt; p4(p3); cout &lt;&lt; *p4 &lt;&lt; " " &lt;&lt; p4.use_count() &lt;&lt; endl;&#125; 运行结果 12312 112 2193 1 reset和use_count的使用 调用p.reset(q)时, 若是p是唯一一个指向其对象的shared_ptr,则reset会释放此对象.若传递了可选的参数内置指针q, 会令p指向q所指的内存空间, 否则将p置空.reset会更新p的引用计数. 123456789101112131415161718void f2()&#123; shared_ptr&lt;int&gt; p4(new int(28)); cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; shared_ptr&lt;int&gt; p5(new int(109)); cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl; // 调用智能指针类的赋值运算符函数 p4 = p5; cout &lt;&lt; "*p4: " &lt;&lt; *p4 &lt;&lt; " p4.use_count(): " &lt;&lt; p4.use_count() &lt;&lt; endl; // p5不是唯一一个指向其所指对象的shared_ptr,因此,重新制作一份该对象的副本并修改该对象的值 if (!p5.unique()) &#123; p5.reset(new int(*p5)); *p5 += 100; &#125; cout &lt;&lt; "*p5:" &lt;&lt; *p5 &lt;&lt; " p5.use_count: " &lt;&lt; p5.use_count() &lt;&lt; endl;&#125; 运行结果 1234*p4: 28 p4.use_count(): 1*p5:109 p5.use_count: 1*p4: 109 p4.use_count(): 2*p5:209 p5.use_count: 1 unique_ptrweak_ptrweak_ptr是一种不控制对象生命周期的智能指针，它指向一个share_ptr管理的对象，进行该对象的内存管理的是强引用的share_ptr，weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为配合share_ptr而引入的一种智能指针来协助shared_ptr工作，它只可以从一个shared_ptr或另一个weak_ptr对象构造，它的构造和析构不会引起对象引用计数的增加和减少。weak_ptr使用来解决shared_ptr相互引用时的死锁问题，如果两个shared_ptr相互引用，那么这两个指针的引用计数永远都不可能下降为0，资源永远不能释放。weak_ptr是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 假设现在有两个类A和B，在局部作用域中定义一个A类型的指针pa和一个B类型的指针pb。如图所示，A类型对象中有一个成员智能指针指向B类型对象，而B类型对象中有一个A类型成员智能指针指向A类型对象。A类型智能指针pa指向A类型对象，B类型智能指针pb指向B类型对象。则有两个智能指针指向A类型对象，所以A类型对象的引用计数为2，同理B类型对象的引用计数也为2。当离开局部作用域时，pa和pb析构时，二者所指向的资源即A类型对象和B类型对象的引用计数减1，但是两者的引用计数都为1，所以，A和B的析构函数没有被调用，因此，资源未被释放。因此造成了资源泄露。解决方法是将类型A中的成员指针改为weak_ptr&lt;B&gt;。 当_pb是weak_ptr&lt;B&gt;类型时，对于B类型对象现在引用计数为1，因为有一个weak_ptr&lt;B&gt;和一个shared_ptr&lt;\B&gt;指向它。对于A类型对象，引用计数仍为2。当离开局部作用域时，pb的引用计数为1，因此会调用B类型对象的析构函数，这会导致A类型对象的引用计数减1，同时pa析构时A类型对象的引用计数又减1，此时A类型对象的引用计数为0，于是调用析构函数，释放资源。]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>shared_ptr</tag>
        <tag>unique_ptr</tag>
        <tag>weak_ptr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列1]]></title>
    <url>%2F2019%2F10%2F13%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%97%EF%BC%91%2F</url>
    <content type="text"><![CDATA[类型转换 旧式转型有两种常见的形式： 12T(expression)(T)expression 四种新式转型：cast-name&lt;type&gt;(expression)，type是转换的目标类型，expression是要转换的值。若type是引用类型，则结果是左值。cast-name是static_cast，dynamic_cast，const_cast和reinterpret_cast中的一种。旧式转换表面上功能强大，但是转化时不够明确，不能进行错误检查，容易出错。 const_cast通常被用来将对象的常量性移除.即将const对象转为非const对象。 dynamic_cast 主要用来执行“安全向下转型”,也就是用来决定某对象是否归属继承体系中的某个类型. 用于动态类型转换，只能用于含有虚函数的类，用于类层次间的向上和向下转化．只能转指针或引用．向下转化时，如果是非法的，对于指针返回nullptr，对于引用抛出异常． 向上转换：子类向基类的转换 向下转换：基类向子类的转换 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换． 它是唯一无法由旧式语法执行的动作,也是唯一可能耗费重大运行成本的转型动作. reinterpret_cast意图执行低级转型,实际动作(及结果)可能取决于编译器,这也就表示它不可移植.例如将一个pointer to int转型为一个int. 这一类型在低级代码以外很少见。 static_cast用来强迫隐式转换 将non-const对象转为const对象 (不能隐式地将一个左值转换为一个右值引用，但是可以使用static_cast可以显式地将一个左值转换为一个右值引用 或将int转为double 用于多态向上转换，如果向下转型能成功但是不安全，结果未知 也可以用来执行上述多种转换的反向转换 将void*指针转换为typed指针 将point-to-base转为pointer-to-derived。 但它无法将const转为non-const,这个只有const_cast才办得到。 参考文献 [1]更深入理解reinterpret_cast：https://www.cnblogs.com/ider/archive/2011/07/30/cpp_cast_operator_part3.html]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>static_cast</tag>
        <tag>类型转换</tag>
        <tag>显示转换</tag>
        <tag>cast</tag>
        <tag>const_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[312. Burst Balloons(打气球的最大分数)]]></title>
    <url>%2F2019%2F10%2F12%2F312.Burst-Balloons%2F</url>
    <content type="text"><![CDATA[Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and rightthen becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: 1234Input: [3,1,5,8]Output: 167 Explanation: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 暴力搜索 第一步是最难的，需要确定暴力搜索的方法，保证能够搜索到所有可能的路径，通过比较所有可能的路径得到最优解。之后，对暴力搜索进行优化，变成自顶向下的记忆化搜索，再变成自底向上，最后压缩空间。 自顶向下123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return 0; &#125;else if(nums.size() == 1)&#123; return nums[0]; &#125; int n = nums.size(); vector&lt;int&gt; help(n + 2, 1); for(int i=0;i&lt;n;i++)&#123; help[i+1] = nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; ans(n+2, vector&lt;int&gt;(n+2, -1)); int max_score = process(help, 1, n, ans); return max_score; &#125; int process(vector&lt;int&gt;&amp; nums,int lo, int hi, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(ans[lo][hi]!=-1)&#123; return ans[lo][hi]; &#125; if(lo == hi)&#123; return nums[lo - 1] * nums[lo] * nums[hi + 1]; &#125; int max_score = max(nums[lo - 1] * nums[lo] * nums[hi + 1] + process(nums, lo + 1, hi, ans), nums[lo - 1] * nums[hi] * nums[hi + 1] + process(nums, lo, hi - 1, ans)); // 尝试每一个气球最后被打爆的方案 for(int i = lo + 1;i&lt; hi;i++)&#123; max_score = max(max_score, nums[lo - 1] * nums[i] * nums[hi + 1] + process(nums, lo, i - 1, ans) + process(nums, i + 1, hi, ans)); &#125; ans[lo][hi] = max_score; return max_score; &#125;&#125;; AC代码2 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return 0; &#125;else if(nums.size() == 1)&#123; return nums[0]; &#125; int n = nums.size(); vector&lt;int&gt; help(n + 2, 1); for(int i=0;i&lt;n;i++)&#123; help[i+1] = nums[i]; &#125; vector&lt;vector&lt;int&gt;&gt; ans(n+2, vector&lt;int&gt;(n+2, -1)); int max_score = process(help, 1, n, ans); return max_score; &#125; int process(vector&lt;int&gt;&amp; nums,int lo, int hi, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(ans[lo][hi]!=-1)&#123; return ans[lo][hi]; &#125; if(lo == hi)&#123; return nums[lo - 1] * nums[lo] * nums[hi + 1]; &#125; // max_score初值设置为0，隐含了当lo &gt; hi时，即没有气球可打时，返回0 int max_score = 0; // 尝试每一个气球最后被打爆的方案 for(int i = lo;i&lt;= hi;i++)&#123; max_score = max(max_score, nums[lo - 1] * nums[i] * nums[hi + 1] + process(nums, lo, i - 1, ans) + process(nums, i + 1, hi, ans)); &#125; ans[lo][hi] = max_score; return max_score; &#125;&#125;; 自底向上由解法2可得递推公式：$$f[i][j] = \max \limits_{i &lt;= k &lt;= j}{help[i-1]* help[k]*help[j+1] + f[i][k-1] + f[k+1][j]}$$另外，初值如下：$$f[i][i-1] = 0$$ $$1&lt;=i&lt;=n, 1&lt;=j&lt;=n$$ 其中，n为原数组nums的大小。但是这里的help是在原数组nums的最前面和最后面分别加上一个1形成的辅助数组。例如nums= [3,1,5,8]，则help = [1, 3,1,5,8, 1] ，n = 4。 分析填表顺序压缩空间12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[907. Sum of Subarray Minimums]]></title>
    <url>%2F2019%2F10%2F12%2F907.Sum-of-Subarray-Minimums%2F</url>
    <content type="text"><![CDATA[Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A. Since the answer may be large, return the answer modulo 10^9 + 7. Example 1: 1234Input: [3,1,2,4]Output: 17Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1. Sum is 17. 解法1统计以a[j]为right-most最小值的子数组的个数, 记作s[j].这样, 结果就是sum(s[j] * a[j]). 必须以right-most为条件,因为只有如此,才能把子数组分为不重合的集合以免重复计算.问题于是转化为, 求最小的i(i&lt;=j), a[i] , a[i+1] , …., a[j]都是大于等于a[j]的.以及最大的k(k&gt;=j) , a[j+1], a[j+2],….,a[k]都大于a[j].然后问题可以进一步转化为找出位置j左边距离j位置最近且值比arr[j]小的位置，同时找出位置j右边距离j位置最近且值小于等于arr[j]的位置． 那么，假设位置j左边距离位置j最近且值比arr[j]小的位置为i，且位置j右边距离位置j最近且值小于等于arr[j]的位置为k，那么位置j左边有(i-1)-(k+1) + 1=i-k-1个元素大于等于arr[j]，同时，位置j右边有(k-1)-(i+1)-1 = k - i + 1个元素比arr[j]大．那么，以arr[j]为right-most最小值的子数组个数有(i-k) * (k-j)个． 对于一个数组[5,3,4,6]来说,包含3的子数组有6个.这是因为3的左边有一个数, 右边有2个数.3可以在它的左边选择0个或者1个数, 在右边选择0或1个或2个构成子数组.因为包括3的子数组个数共有6个,分别是:即包括3的子数组的个数是(j - i - 1) * (k - j - 1), 设j=1表示3的索引, i=-1，k = 4. 1[[3],[5,3],[3,4],[3,4,6], [5,3,4],[5,3,4,6]] 过程设a = [3,2,2,4].则对于第一个2来说，以它为right-most最小值的子数组有：[[2],[3,2]]，以第二个2为right-most最小值的子数组有：[[2],[2,2],[2,4],[3,2,2],[2,2,4],[3,2,2,4]]，共6个，因为在第二个2之前有两个数[3,2]都大于等于它，而在它之后有一个数小于等于它，则以第二个2为right-most最小值的子数组共有(2+1) * (1+1) = 6个．然后使用单调栈来求数组a中a[j]左边第一个小于a[j]的元素a[i]和右边第一个小于等于a[j]的元素a[k]. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*** * 找出nums中元素nums[j]左边第一个小于nums[j]的元素nums[i], * 及nums[j]右边第一个小于等于nums[j]的元素nums[k] * @param nums */vector&lt;vector&lt;int&gt;&gt; singleStack(vector&lt;int&gt; &amp;nums) &#123; stack&lt;int&gt; st; if (nums.size() &lt; 1) &#123; return &#123;&#125;; &#125; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2, -1)); for (int i = 0; i &lt; nums.size(); ++i) &#123; while (!st.empty() &amp;&amp; nums[st.top()] &gt;= nums[i]) &#123; int index = st.top(); st.pop(); int l = st.empty() ? -1 : st.top(); int r = i; res[index][0] = l; res[index][1] = r; &#125; st.push(i); &#125; // 下面这些元素右边没有元素比它们小 while (!st.empty()) &#123; int index = st.top(); st.pop(); int l = st.empty() ? -1 : st.top(); int r = nums.size(); res[index][0] = l; res[index][1] = r; &#125; return res;&#125;void testsingleStack() &#123;// vector&lt;int&gt; nums&#123;2, 3, 2, 3, 5, 2, 3, 3&#125;; vector&lt;int&gt; nums&#123;3, 1, 2, 4&#125;; vector&lt;vector&lt;int&gt;&gt; res = singleStack(nums); int total = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "] " &lt;&lt; nums[i] &lt;&lt; ": " &lt;&lt; res[i][0] &lt;&lt; "," &lt;&lt; res[i][1] &lt;&lt; endl; // (i - res[i][0]) * (res[i][1] - i) 表示以nums[i]为最小值的子数组个数 total += (i - res[i][0]) * (res[i][1] - i) * nums[i]; &#125; cout &lt;&lt; total &lt;&lt; endl;&#125; AC代码1234567891011121314151617181920212223242526class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int cnt = 0; const int MOD = 1000000007; stack&lt;int&gt; s1; for(int i=0;i&lt;A.size();++i)&#123; int r = i; while(!s1.empty() &amp;&amp; A[s1.top()] &gt;= A[i])&#123; int idx = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); cnt = (cnt + (r - idx) * (idx - l) * A[idx]) % MOD; &#125; s1.push(i); &#125; int r = A.size(); while(!s1.empty())&#123; int idx = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); cnt = (cnt + (idx - l) * (r - idx) * A[idx]) % MOD; &#125; return cnt; &#125;&#125;; 类似题题目链接]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition Array into Disjoint Intervals]]></title>
    <url>%2F2019%2F10%2F12%2F915.Partition%20Array%20into%20Disjoint%20Intervals%2F</url>
    <content type="text"><![CDATA[Partition Array into Disjoint Intervals Given an array A, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning. It is guaranteed that such a partitioning exists. Example 1: 123Input: [5,0,3,8,6]Output: 3Explanation: left = [5,0,3], right = [8,6] Example 2: 123Input: [1,1,1,0,6,12]Output: 4Explanation: left = [1,1,1,0], right = [6,12] 解法1思路：从第一个位置开始遍历数组，maxVal记录属于前left的元素中的最大值，next记录从第一个位置到目前遍历到的位置中的最大值．当出现一个比当前记录的最大值更大的元素时，比较它与next，若它大于next，则更新next．当出现一个比maxVal小的元素时，更新left的右边界，即这个比maxVal也属于left，此时，更新maxVal = next．idx = i． 12345678910111213141516171819class Solution &#123;public: int partitionDisjoint(vector&lt;int&gt;&amp; A) &#123; if(A.empty())&#123; return 0; &#125; int maxVal = A[0]; int next = A[0]; int idx = 0; for(int i=1;i&lt;A.size();++i)&#123; next = max(A[i], next); if(A[i] &lt; maxVal)&#123; maxVal = next; idx = i; &#125; &#125; return idx + 1; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[389. Find the Difference]]></title>
    <url>%2F2019%2F10%2F12%2F389.Find-the-Difference%2F</url>
    <content type="text"><![CDATA[Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: 123456789Input:s = &quot;abcd&quot;t = &quot;abcde&quot;Output:eExplanation:&apos;e&apos; is the letter that was added. AC代码1 123456789101112131415161718class Solution &#123;public: char findTheDifference(string s, string t) &#123; map&lt;char, int&gt; mp; for(auto c:s)&#123; mp[c] = mp.find(c) == mp.end() ? 1 : mp[c] + 1; &#125; char res; for(auto c:t)&#123; if(mp.find(c) == mp.end() || mp[c] == 0)&#123; res = c; break; &#125; mp[c]--; &#125; return res; &#125;&#125;; 思路：首先统计源字符串s中的每一个字符及其出现次数，然后统计打乱了顺序并加入了新字符的字符串t中每个字符的出现次数。新加入的字符要么是源字符串中不存在的字符，要么比源字符串中的出现次数加1。时间复杂度为O(n)，空间复杂度为O(n)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sliding window 系列]]></title>
    <url>%2F2019%2F10%2F11%2Fsliding-window-%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[滑动窗口系列 Maximum Average Subarray Ileetcode 643Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1: 123Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note: 1 &lt;= k &lt;= n &lt;= 30,000. Elements of the given array will be in the range [-10,000, 10,000].]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux查看cpu内存流量磁盘IO的命令]]></title>
    <url>%2F2019%2F10%2F10%2Flinux%E6%9F%A5%E7%9C%8Bcpu%E5%86%85%E5%AD%98%E6%B5%81%E9%87%8F%E7%A3%81%E7%9B%98IO%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux中用于查看cpu、内存、磁盘IO的命令有vmstat，free等。 cpucpu性能lscpu、uptime、top、htop top123456789xixi2@xixi2:~/liunx_prac$ top | head -n 7top - 21:50:00 up 1 day, 5:38, 1 user, load average: 1.07, 0.72, 0.68任务: 309 total, 1 running, 253 sleeping, 0 stopped, 0 zombie%Cpu(s): 4.5 us, 2.3 sy, 0.0 ni, 92.2 id, 0.3 wa, 0.0 hi, 0.6 si, 0.0 stKiB Mem : 8071096 total, 1579136 free, 3149040 used, 3342920 buff/cacheKiB Swap: 2097148 total, 2042108 free, 55040 used. 4403552 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4975 xixi2 20 0 51356 4224 3560 R 11.1 0.1 0:00.05 top 各参数及其含义第一行参数 21:50:00 ：当前时间up 1 day， 5:38：开机运行时间1 user：当前登陆用户个数load average：代表近1分钟、5分钟、15分钟的系统负载的平均值注：load average代表CPU的压力情况，如果负载值超过了当前系统CPU的逻辑核数，则表示CPU已经处理不过来了，此时会出现线程等待的情况。 第二行参数: 系统进程数状态 307 total：进程总数1 running： 正在运行的进程数253 sleeping：睡眠的进程数0 stopped：停止的进程数0 zombie：僵尸进程数 第三行参数: CPU的使用状态： 4.6 us：用户空间占用CPU百分比2.3sy：内核空间占用CPU百分比0.0 ni：用户进程空间内改变过优先级的进程占用CPU百分比92.2 id：空闲CPU百分比0.3 wa：等待输入输出的CPU时间百分比，这个数值能直接反应磁盘 IO 是否过高0.0 hi：硬件CPU中断占用百分比0.6 si：软中断占用百分比0.0 st：虚拟机占用百分比 第四行参数: 物理内存的使用情况： 8071096 total：内存总量，单位kb1579136 free：空闲内存总量，单位kb3149040 used：使用的内存总量，单位kb3342920 buffer/cache：物理内存内核缓存使用量，单位kb 注：当前系统物理内存剩余总数为： free + buffer/cache 第五行参数: 交换分区内存的使用情况： 2097148 total：内存总量，单位kb2042108 free：空闲内存总量，单位kb55040 used：使用的内存总量，单位kb4403552 avail Mem：虚拟内存总量 第七行参数: 进程详情 PID：进程IDUSER：进程所有者PR：进程优先级NI：进程nice值VIRT：进程所占虚拟内存大小，单位kbRES：进程所占物理内存大小，单位kbSHR：进程所占共享内存大小，单位kbS：进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)%CPU：进程占用CPU百分比%MEM：进程占用物理内存百分比TIME+：上次更新到现在进程使用的CPU时间总计COMMAND：启动该进程的命令 cpu负载uptime 内存free 磁盘df、dd、vmstat、hdparm 网络netstat 参考文献[1]https://www.cnblogs.com/home123/p/7577479.html[2]top命令详解：https://www.cnblogs.com/mauricewei/p/10496633.html]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CS中一些易混淆和忘记的基本概念]]></title>
    <url>%2F2019%2F10%2F10%2FCS%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%98%93%E6%B7%B7%E6%B7%86%E5%92%8C%E5%BF%98%E8%AE%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此文档总结一些易忘记和易混淆的基础概念。 顶层const与底层const顶层const是指任意对象是const，而底层const指的是指针或引用的基本数据类型是const。简单来说 12345678const int a = 1; // 顶层constconst double b = 0.0; // 顶层constint *const ip = &amp;a; // 顶层const，ip本身是常量指针，不能指向其他变量了double *const dp =&amp;b; // 顶层const，dp本身是常量指针，不能指向其他变量了const int* ip1 = &amp;a; // 底层const，说明ip1指向的是常量，且ip1只能指向常量，但是ip1可以指向其他常量const double *dp1 = &amp;b; // 底层const，说明dp1指向的是常量，且dp1只能指向常量，但是dp1可以指向其他常量 大端和小端存储方式大端方式：高位字节放在低位地址。小端方式：低位字节放在高位方式。对于16进制数0x12345678，大端方式存储时内存分布如图1(左边)，小端方式存储如图2(右边)。对于大端方式来说，从地址0x000020到地址0x000023依次存放着0x12，0x34，0x56，0x78；而小端方式则相反，从地址0x000020到地址0x000023依次存放着0x78，0x56，0x34，0x12。 大端和小端方式的检测方法一先说一下思路，首先主机字节序有上面说的两种，大端和小端方式。而网络字节序是规定好的，只能是大端方式，因此可以通过比较一个按照主机字节序存储的变量和一个按照网络字节序存储的变量。函数htonl用于将数据从主机字节序转为网络字节序。其中h代表主机(host)字节序，n代表网络(network)字节序。另外，l指的是long(Linux中long类型占用4个字节，这很关键)。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;#include&lt;stdint.h&gt; // unit8_tusing namespace std;void test1() &#123; int a = 0x12345678; cout &lt;&lt; "sizoef(a):" &lt;&lt; sizeof(a) &lt;&lt; endl; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; // 把int型数据从主机字节序转化为网络字节序,网络字节序是大端方式 int b = htonl(a); cout &lt;&lt; "sizoef(b):" &lt;&lt; sizeof(b) &lt;&lt; endl; cout &lt;&lt; "b=" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; (a == b ? "大端方式" : "小端方式") &lt;&lt; endl;&#125;int main() &#123; test1(); return 0;&#125; 运行结果在我的64位机器上运行结果，可知，我的机器是以小端方式来存储数据的。以大端方式存储时，$$0x12345678 = {8} \times {16^0} + {7} \times {16^1} + {6} \times {16^2} + {5} \times {16^3} + {4} \times {16^4} + {3} \times {16^5} + {2} \times {16^6} + {1} \times {16^8}$$结果为305419896；而以小端方式存储，16进制数0x78563412转为10进制，结果为2018915346。 12345sizoef(a):4a=305419896sizoef(b):4b=2018915346小端方式 方法二上面是通过调用htonl函数来得到一个以大端方式存储的数据，我们也可以手动创建一个以大端方式存储的32位数据。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;arpa/inet.h&gt;#include&lt;stdint.h&gt; // unit8_tusing namespace std;bool F() &#123; // 如果在以大端方式存储的机器上运行返回true,否则返回false uint8_t a[] = &#123;0x12, 0x34, 0x56, 0x78&#125;; // 手动高位字节低位地址 uint32_t b = 0x12345678; // a是数组首地址,是一个uint8_t类型的指针 // (uint32_t *) a是使用旧式类型转换将a转换成一个uint32_t类型的指针 return *(uint32_t *) a == b;&#125;bool F1() &#123; // 如果在以大端方式存储的机器上运行返回true,否则返回false uint8_t a[] = &#123;0x12, 0x34, 0x56, 0x78&#125;; // 手动高位字节低位地址 uint32_t b = 0x12345678; // 声明一个uint32_t类型变量,按照主机字节序进行存储 // 使用新式类型转换中的reinterpret_cast进行强转型 uint32_t *p = reinterpret_cast&lt;uint32_t *&gt;(a); return (*p == b);&#125;void test2() &#123; // 这里只是为了测试,所以打印出来,可以看得更清楚 uint8_t a[] = &#123;0x12, 0x34, 0x56, 0x78&#125;; // 手动高位字节低位地址 uint32_t b = 0x12345678; cout &lt;&lt; "a=" &lt;&lt; *(int *) a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; (F() ? "大端方式" : "小端方式") &lt;&lt; endl; cout &lt;&lt; (F1() ? "大端方式" : "小端方式") &lt;&lt; endl;&#125;int main() &#123; test2(); return 0;&#125; 运行结果可以看出这里手动创建的32位数据(大端方式存储)和上面经过网络字节序转换之后的一样。F()和F1()两个函数是等价的，两个函数实现的同样的功能。唯一的不同是，在F()使用的是旧式类型转换，而在F1()中则使用了新式类型转换。另外，在使用新式类型转换时，无法使用static_cast，而能够使用reinterpret_cast，这是为什么，还没弄明白。 123a=2018915346 b=305419896小端方式小端方式 关于类型转换的更多知识，请自行查看类型转换系列1。 二叉树的高度和深度根节点到任一节点的路径长度，即该节点的深度。根节点的深度是0。某个节点即其最深叶子节点的路径长度即高节点的高度。叶子节点的高度为0。整棵树的高度即根节点的高度。 参考文献[1]TCP/IP网络编程(尹圣雨著)]]></content>
      <categories>
        <category>CS基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[聊聊IO多路复用之select、poll、epoll详解]]></title>
    <url>%2F2019%2F10%2F10%2F%E8%81%8A%E8%81%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文档非原创。主要总结io多路复用中的几个模型。IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。 IO多路复用适用如下场合。 当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。 与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。 目前支持IO多路复用的系统调用有select，pselect，poll，epoll，IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或写就绪)，能够通过程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O，因为它们都需要在读写事件就绪后自己负责进行读写，也就是这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 select、poll、epoll简介epoll和select都能提供多路I/O复用的解决方案。在现在的linux内核里都能支持，其中epoll是Linux所特有，而select则应该是POSIX所规定的，一般操作系统均有实现。 selectselect 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。 select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。 select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是： select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048. 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大. pollpoll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后它又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的(为什么基于链表实现就没有最大连接数的限制了？可能原因：数组需要连续内存空间，而连续内存空间最多是内存中的一页，链表则是离散分配内存)，但是同样有一个缺点： 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。 poll还有一个特点是”水平触发”，如果报告了fd后，没有被处理，那么下次poll时候会再次报告该fd。 注意：从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epollepoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核中的一个事件表中，这样在用户空间和内核空间的copy只需要一次。 epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用”事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。 epoll的优点： 没有最大并发连接的限制，能打开的fd的上限远大于1024(1G的内存上能监听约10万个端口)。 效率提升，不是轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；即epoll最大的优点在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率远高于select和poll。 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)。LT模式是默认模式，LT模式与ET模式的区别在于：LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 LT模式 LT模式是缺省的工作方式，并且同时支持block和non-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不做任何操作，内核还是会继续通知你。 ET是高速工作方式，只支持non-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK错误)。但是请注意，如果一直不对这个fd做IO操作(从而导致它再次变为未就绪)，内核不会发送更多的通知。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄(文件句柄和文件描述符类似，但是有一些区别)的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 在select/poll中，进程只有在调用一定的方法(什么方法？)后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()便得到通知(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在)。 注意：如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。 select、poll、epoll区别 支持一个进程所能打开的最大连接数 IO多路复用方式 支持一个进程所能打开的最大连接数 select 单个进程所能打开的最大连接数由FD_SETSIZE宏定义(即最大连接数受到这个宏定义限制)，其大小是32个整数的大小(在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64)，当然我们可以对其进行修改，然后重新编译内核，但是性能可能会受到影响，这需要更进一步的测试。 poll poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。 epoll 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G的机器可以打开20万左右的连接 FD剧增后带来的IO效率问题 IO多路复用方式 FD剧增后带来的IO效率问题 select 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成速度慢的“线性下降性能问题”。 poll 同上 epoll 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 消息传递方式 IO多路复用方式 消息传递方式 select 内核需要将消息传递到用户空间，都需要内核拷贝动作 poll 同上 epoll epoll通过内核和用户空间共享一块内存来实现的 表面上看epoll的性能最好，但是在连接少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。 参考文献[1]select、poll、epoll：https://mp.weixin.qq.com/s/zg7Ty_aF-IO0A4w4b5UVjA[2]mmap：linux程序设计第4版[3]mmap：]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[memmove与memcopy]]></title>
    <url>%2F2019%2F10%2F10%2Fmemmove%E4%B8%8Ememcopy%2F</url>
    <content type="text"><![CDATA[memcpy、memmove，memcpy和strcpy分别用 memcpy函数原型 1void* memcpy(void* dest, const void* src, size_t count); Copies count bytes from the object pointed to by src to the object pointed to by dest. Both objects are reinterpreted as arrays of unsigned char. If the objects overlap, the behavior is undefined. If either dest or src is a null pointer, the behavior is undefined, even if count is zero. If the objects are potentially-overlapping or not TriviallyCopyable, the behavior of memcpy is not specified and may be undefined. 如果两段内存重叠，则会导致未定义的行为；如果dest或者src是空指针(即便count=0)，则是未定义的行为。 实现123456789101112void *memcpy(void *dest, const void *src, size_t n) &#123; assert((nullptr != dest) &amp;&amp; (nullptr != src)); char *p1 = (char *) dest; char *p2 = (char *) src; if (n) &#123; // 假设dest和src之间不存在重叠区域,因此这里不再检查 while (n--) &#123; *p1++ = *p2++; &#125; &#125; return dest;&#125; 测试程序 1234567891011void test1() &#123; int arr[5] = &#123;1, 2, 3, 4, 5&#125;; int brr[5]; // 注意第三个参数是sizeof(arr) memcpy(brr, arr, sizeof(arr)); for (size_t i = 0; i &lt; 5; ++i) &#123; cout &lt;&lt; brr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 11 2 3 4 5 比较memcpy是最快的内存拷贝函数。它比strcpy和memmove都要快。strcpy需要扫描需要拷贝的数据，而memmove则需要检测是否存在内存重叠。如果存在内存重叠，则应该使用memmove，而不是memcpy。 memmove Move block of memoryCopies the values of num bytes from the location pointed by source to the memory block pointed by destination. Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap.The underlying type of the objects pointed by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.The function does not check for any terminating null character in source - it always copies exactly num bytes.To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num bytes. 以字节为单位，拷贝内存块。允许dest和src指向的内存块有重叠。 进行数组拷贝时，如果两段内存重叠，用memcpy函数可能会导致未定义。而memmove函数能够避免这种问题。下面是一种实现方式。题目链接ptr1表示目的地址，ptr2表示源地址。如图所示，绿色表示数组2的元素，杏色表示数组1的元素．蓝色表示数组1和数组2重合的位置的元素。当pstr1 &gt; pstr2时，需要逆序移动．否则，属于pstr2数组的后几个元素会被覆盖。a 当pstr1 &lt; pstr2时，正向移动。 实现12345678910111213141516171819void *memmove(void *str1, const void *str2, size_t n) &#123; assert((nullptr != str1) &amp;&amp; (nullptr != str2)); char *pStr1 = (char *) str1; char *pStr2 = (char *) str2; if (pStr1 &lt; pStr2) &#123; for (size_t i = 0; i &lt; n; ++i) &#123; *pStr1++ = *pStr2++; &#125; &#125; else &#123; // 如果目的在源之后,可能存在重叠区域,则逆向拷贝元素 pStr1 += n - 1; pStr2 += n - 1; for (size_t i = 0; i &lt; n; ++i) &#123; *pStr1-- = *pStr2--; &#125; &#125; return str1;&#125; 测试程序针对int 123456789101112131415161718192021void test1() &#123; int arr[9] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // 用arr[2],arr[3],...,arr[6]覆盖arr[0],arr[1],..,arr[4] memmove(arr, arr + 2, 5); for (int i = 0; i &lt; 9; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void test2() &#123; int arr[9] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // 用arr[0],arr[1],..,arr[4]覆盖arr[2],arr[3],...,arr[6] memmove(arr + 2, arr, 5); for (int i = 0; i &lt; 9; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果： 123 4 5 6 7 6 7 8 9 1 2 1 2 3 4 5 8 9 针对char 123456789101112131415161718192021void test3() &#123; char arr[9] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'&#125;; // 用arr[2],arr[3],...,arr[6]覆盖arr[0],arr[1],..,arr[4] memmove(arr, arr + 2, 5); for (int i = 0; i &lt; 9; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void test4() &#123; char arr[9] = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'&#125;; // 用arr[0],arr[1],..,arr[4]覆盖arr[2],arr[3],...,arr[6] memmove(arr + 2, arr, 5); for (int i = 0; i &lt; 9; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 12c d e f g f g h i a b a b c d e h i strcpy函数原型 1char *strcpy(char *dest, const char* src); Copy string Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point).To avoid overflows, the size of the array pointed by destination shall be long enough to contain the same C string as source (including the terminating null character), and should not overlap in memory with source. strcpy只能用于拷贝C字符串(以空字符结尾)。为了防止溢出，dest指向的内存空间应该足够大，能够容纳src指向的字符串和一个表示字符串结尾的空字符。另外，dest和src指向的内存空间应该不存在重叠。 实现1234567891011121314char *strcpy(char *dest, const char *src) &#123; if (dest == nullptr) &#123; return nullptr; &#125; char *ptr = dest; while (*src != '\0') &#123; *dest = *src; dest++; src++; &#125; *dest = '\0'; return ptr;&#125; 测试程序 123456void test1() &#123; char arr[6] = "hello"; char brr[10]; strcpy(brr, arr); cout &lt;&lt; brr &lt;&lt; endl; // hello&#125; 参考文献[1]memcpy: https://en.cppreference.com/w/cpp/string/byte/memcpy[2]strcpy：https://www.techiedelight.com/implement-strcpy-function-c/[3]memmove：http://www.cplusplus.com/reference/cstring/memmove/?kw=memmove[4]memcpy等比较：https://www.cnblogs.com/youxin/p/3271074.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux中的5种IO模型]]></title>
    <url>%2F2019%2F10%2F10%2Flinux%E4%B8%AD%E7%9A%845%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文档讲解linux中的5种io模型。并非原创。 概念说明在进行解释之前，首先要说明几个概念： 用户空间和内核空间进程切换进程的阻塞文件描述符缓冲 IO 用户空间与内核空间现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间(虚拟存储空间)为4G(2的32次方)。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核(kernel)，保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为内核空间，而将较低的3G字节(从虚拟地址0×00000000到0xBFFFFFFF)，供各个进程使用，称为用户空间。 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 注：总而言之就是很耗资源。 进程的阻塞正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 文件描述符fd文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 1.5 缓存 IO缓冲IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓冲 IO。在 Linux 的缓冲 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ，即内核缓冲区）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存 IO 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 Linux IO模型网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 第一阶段：等待数据准备 (Waiting for the data to be ready)。 第二阶段：将数据从内核缓冲区拷贝到进程中 (Copying the data from the kernel to the process)。 对于socket流而言， 第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。 第二步：把数据从内核缓冲区复制到应用进程缓冲区。 网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种： 同步模型（synchronous IO） 阻塞IO（bloking IO） 非阻塞IO（non-blocking IO） 多路复用IO（multiplexing IO） 信号驱动式IO（signal-driven IO） 异步IO（asynchronous IO） 注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。 在深入介绍Linux IO各种模型之前，让我们先来探索一下基本 Linux IO 模型的简单矩阵。如下图所示： 每个 IO 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。本节将简要对其一一进行介绍。常见的IO模型有阻塞、非阻塞、IO多路复用，异步。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案。 同步阻塞 IO(blocking IO)场景描述 我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。 网络模型同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息, CPU处理其它进程去了。 在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图： 流程描述当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 优点： 能够及时返回数据，无延迟； 对内核开发者来说这是省事了； 缺点： 对用户来说处于等待就要付出性能的代价了； 同步非阻塞 IO(nonblocking IO)场景描述 我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。 网络模型同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。 在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 在linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程如图所示： 流程描述当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。 同步非阻塞方式相比同步阻塞方式： 优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。 缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 IO 多路复用( IO multiplexing)场景描述 与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用。 网络模型由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的(epoll 比 poll、select 效率高，做的事情是一样的)。 IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为”非阻塞”吧。 I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这几个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。 对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。具体流程，如下图所示： 流程描述IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。 上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接）。 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。 了解了前面三种IO模式，在用户进程进行系统调用的时候，他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询，两个阶段过程： 第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。第二个阶段都是阻塞的。 从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(asynchronous)。都是进程主动等待且向内核检查状态。 高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。 注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下： 此处仍然不太清楚的，强烈建议大家在细究《聊聊同步、异步、阻塞与非阻塞》中讲同步与异步的根本性区别，同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。 信号驱动式IO(signal-driven IO)信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示： 异步非阻塞 IO(asynchronous IO)场景描述 女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。 网络模型相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。 Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示： 流程描述用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。 在 Linux 中，通知的方式是 “信号”： 如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。 如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。 如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。 异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。 很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。 从前面 IO 模型的分类中，我们可以看出 AIO 的动机： 同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。 IO多路复用除了需要阻塞之外，select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。 关于异步阻塞有时我们的 API 只提供异步通知方式，例如在 node.js 里，但业务逻辑需要的是做完一件事后做另一件事，例如数据库连接初始化后才能开始接受用户的 HTTP 请求。这样的业务逻辑就需要调用者是以阻塞方式来工作。 为了在异步环境里模拟 “顺序执行” 的效果，就需要把同步代码转换成异步形式，这称为 CPS（Continuation Passing Style）变换。BYVoid 大神的 continuation.js 库就是一个 CPS 变换的工具。用户只需用比较符合人类常理的同步方式书写代码，CPS 变换器会把它转换成层层嵌套的异步回调形式。 另外一种使用阻塞方式的理由是降低响应延迟。如果采用非阻塞方式，一个任务 A 被提交到后台，就开始做另一件事 B，但 B 还没做完，A 就完成了，这时要想让 A 的完成事件被尽快处理（比如 A 是个紧急事务），要么丢弃做到一半的 B，要么保存 B 的中间状态并切换回 A，任务的切换是需要时间的（不管是从磁盘载入到内存，还是从内存载入到高速缓存），这势必降低 A 的响应速度。因此，对实时系统或者延迟敏感的事务，有时采用阻塞方式比非阻塞方式更好。 五种IO模型 参考文献[1]原作者：https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666538919&amp;idx=1&amp;sn=6013c451b5f14bf809aec77dd5df6cff&amp;scene=21#wechat_redirect]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[带缓冲的IO与不带缓冲的IO]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84IO%E4%B8%8E%E4%B8%8D%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84IO%2F</url>
    <content type="text"><![CDATA[本文涉及到众多知识点。如内核态与用户态。 首先，什么是缓冲区？缓冲和缓存这是两个十分相似且容易混淆的概念。简单来看，缓冲区是为了解决通信的两个组件之间速度不匹配的问题。比如说，主存和磁盘。主存速度快，磁盘慢，那么进程要将主存中的数据写入到磁盘的时候，主存就不得不等待磁盘。如果不想等怎么办，所以就有缓冲区的概念。缓冲区就是在主存中专门开辟出一块空间，放置要写入磁盘的数据，当进程要把主存中的数据写入磁盘的时候，不真的等待操作系统把数据写入磁盘，而是直接把数据搬到缓冲区中(还在内存中)，然后操作系统告诉进程，我已经写好了，你可以继续了，进程就继续向前运行。之后，操作系统再默默把缓冲区中的数据写入到磁盘。 内核缓冲区和进程缓冲区除了在进程中设计缓冲区，内核也有自己的缓冲区。当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但是如果内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，调度其他进程运行。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程。可以认为，read系统调用是把数据从内核缓冲区复制到进程缓冲区，write系统调用把数据从进程缓冲区复制到内核缓冲区。 带缓冲和不带缓冲的IO所谓不带缓冲，不是指内核不提供缓冲，而是指系统调用(read和write)，不是函数库的调用。系统内核对磁盘的读写都会提供一个块缓冲(即内核缓冲区)。当调用write时，直接将数据写入到内核缓冲区，当内核缓冲区的数据到达一定量时，才会把数据写入到磁盘。因此，不带缓冲的IO是指进程不提供缓冲功能，内核缓冲区仍然存在。write是系统调用，每调用一次write都直接将数据写入到内核缓冲区中。write系统调用把数据从进程缓冲区复制到内核缓冲区，此时并不一定会发生内核缓冲区和磁盘之间的数据交换。只有当满足一定条件时，内核缓冲区中的数据才会写入磁盘。 123graph LR A[数据] --&gt; B[内核缓冲区] B --&gt; C[磁盘] 而带缓冲的IO是指进程对输入输出流进行了改进，提供了一个流缓冲，当用fwrite函数(不是系统调用，是标准库提供的IO函数)往磁盘写数据时，先把数据写入流磁盘缓冲区中。当满足一定条件时，如流缓冲区满了，或刷新流缓冲区，才把流缓冲区中的数据一次写入到内核缓冲区中(这个过程还是调用write系统调用)，再经内核缓冲区写入磁盘(双重缓冲)。 1234graph LR a[数据] --&gt; b[进程缓冲区] b --&gt; c[内核缓冲区] c --&gt; d[磁盘] 因此，带缓冲的IO在往磁盘写入相同的数据量时，会比不带缓冲的IO调用系统调用的次数要少。 总结一下，不带缓冲的IO对文件描述符进行操作，带缓冲的IO操作的则是流。标准IO就是带缓冲的IO。标准IO提供缓冲的目的是为了调用write和read的次数(这两个函数是系统调用，有开销)，它对每个IO流自动进行缓冲管理。 参考文献[1]带缓冲的IO与不带缓冲的IO：https://blog.csdn.net/u011402017/article/details/53747232[2]用户进程缓冲区和内核缓冲区：https://blog.csdn.net/huaiqu6460/article/details/89677420[3]内核缓冲区：https://blog.csdn.net/xiaofei0859/article/details/51145717[4]缓冲和缓存：https://www.cnblogs.com/tonycloud/articles/6568159.html]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tex live安装与使用]]></title>
    <url>%2F2019%2F10%2F10%2Flatex%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文档主要记录tex live的安装与使用。 latex各发行版本及编辑器比较：https://cn.soulmachine.me/2013-04-12-latex-distributions-and-editors/方法一：TeX Live 是 TUG (TeX User Group) 维护和发布的 TeX 系统，可说是「官方」的 TeX 系统。TeXworks是Windows版本的TeX Live默认提供的编辑器。TeXworks使用教程指南 ：http://blog.sina.com.cn/s/blog_5f234d470101igyd.html方法二：先安装texlive，然后安装textstudio。 安装安装texlive和textstudio[1]环境变量配置：https://blog.csdn.net/williamyi96/article/details/90732304 上述环境变量配置仅仅对一个会话有效，要永久生效，需要修改/etc/profile在/etc/profile文件中添加变量【对所有用户生效（永久的）】用vim在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。让修改马上生效，执行以下代码source /etc/profile [2]安装过程：https://www.linuxidc.com/Linux/2016-08/133913.htm[3]iso文件下载地址：https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/[4]tlmgr找不到命令错误的解决方法：https://tex.stackovernet.com/cn/q/8513[5]sudo equivs-build texlive-local执行出错：https://www.tug.org/texlive/files/debian-equivs-2019-ex.txt[6]dpkg-gencontrol: 错误: illegal package name ‘&lt;package name; defaults to equivs-dummy&gt;’: character ‘&lt;’ not allowed错误解决方案：正确的texlive-local文件内容：https://tex.stackexchange.com/questions/1092/how-to-install-vanilla-texlive-on-debian-or-ubuntu[7]sudo dpkg -i texlive-local_2019-1_all.deb执行出错：未安装软件包 freeglut3：https://tex.stackexchange.com/questions/412915/freeglut3-not-installed-trying-to-trick-ubuntu-to-thinking-texlive-is-isntalled[8]下载textstudio：https://www.bravotutorials.com/latex/recommended-programs/installing-texstudio[9]安装texlive：https://zhuanlan.zhihu.com/p/36240727[10]texlive和textstudio安装笔记：https://www.cnblogs.com/joyeecheung/p/3596255.html[11]textstudio支持中文环境：https://blog.csdn.net/qizaijie/article/details/79564079 安装字体安装思源字体： 1$ sudo apt install fonts-noto-cjk fonts-noto-cjk-extra 查看系统中文字体： 12345$ fc-list :lang=zh.../usr/share/fonts/opentype/noto/NotoSansCJK-Bold.ttc: Noto Sans CJK SC,Noto Sans CJK SC Bold:style=Bold,Regular/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc: Noto Sans CJK SC,Noto Sans CJK SC Regular:style=Regular... 使用[1]Latex数学公式-求导、分数的表示: https://blog.csdn.net/qq_31880107/article/details/86592791[2]LaTeX实战经验：数学公式环境注意事项: https://blog.csdn.net/simple_the_best/article/details/52710740[3]latex的各种帽子: https://www.cnblogs.com/huangshiyu13/p/6936884.html[4]在博客中使用LaTeX插入数学公式: https://www.cnblogs.com/Sinte-Beuve/p/6160905.html[5]latex希腊字母: https://blog.csdn.net/qq_40587575/article/details/83387333[6]latex之转置符号: https://www.cnblogs.com/huangshiyu13/p/6946395.html[7]参考文献排版: https://zhuanlan.zhihu.com/p/25013341?refer=jeldor-latex[8]向上(下)取整: https://www.zhihu.com/question/27399809[9]latex插入项目符号和编号：http://blog.sina.com.cn/s/blog_3fe961ae0101eoht.htmlli[12]latex中给字体添加颜色：https://en.wikibooks.org/wiki/LaTeX/Colors]]></content>
  </entry>
  <entry>
    <title><![CDATA[类型转换系列2]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[对于类类型的类型转换,通过定义类型转换运算符完成.转换构造函数和类型转换运算符共同定义了类类型转换.类型转换运算符没有显式的返回类型,也没有星灿,而且必须定义成类的成员函数.类型转换运算符一般不改变待转换对象的内容.因此,类型转换运算符一般是const的. 类型转换运算符函数123456789101112131415161718192021222324252627282930/** * SmallInt既定义了向类类型的转换,也定义了从类类型向其他类型的转换 * 构造函数将算类型的值转换成SmallInt类型对象,类型转换运算符将SmallInt对象转换成int */class SmallInt &#123;public: SmallInt(int i = 0) : val(i) &#123; if (i &lt; 0 || i &gt; 255) &#123; throw std::out_of_range("Bad SmallInt value"); &#125; &#125; // 类型转换运算符:把类类型SmallInt转成int类型 operator int() const &#123; return val; &#125;private: std::size_t val;&#125;;int main()&#123; SmallInt s = 4; // s是一个SmallInt类型对象,val=4 cout &lt;&lt; s + 4 &lt;&lt; endl; // 8 SmallInt si = 3.14; // si是一个SmallInt类型对象,val=3 cout &lt;&lt; si + 3.14 &lt;&lt; endl; // 6 return 0;&#125; SmallInt s = 4首先将4隐式地转换为SmallInt,然后调用SmallInt::operator=(拷贝赋值运算符). s + 4首先将s隐式地转换成int,然后执行整数的加法 si = 3.14, 首先内置类型转换将double实参转换成int,然后再调用SmallInt(int)构造函数 在表达式si + 3.14中, 首先SmallInt类型转换运算符将si转换成3,然后内置类型转换将所得int继续转换为double. 编译器一次只能执行一个用户定义的类型转换,但是隐式的用户定义类型转换可以置于一个标准类型转换之前或之后]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>类类型隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步、异步、阻塞与非阻塞]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[同步和异步主要是从消息通知机制角度来说的。 同步和异步概念描述同步是一个任务A的完成要依赖另一个任务B时，只有等待被依赖的任务B完成后，任务A才算完成，这是一种可靠的任务序列。异步是不需要等待被依赖的任务完成，只是通知被依赖的任务B要完成什么工作，任务A立即执行，只要完成了自己的工作，整个任务就算完成了。至于被依赖的任务B最终是否真正完成，任务A无法确定，所以它是不可靠的任务序列。 消息通知当一个同步调用发出后，调用者要一直等待返回消息(结果)通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立即得到返回消息(结果)。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 同步和异步的区别在于：由谁来负责通知调用者返回消息的到达。 这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。 如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）； 如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。 场景举个例子，比如我去银行办理业务，可能会有两种方式： 选择排队等候； 另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了； 第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况； 第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。 阻塞与非阻塞阻塞和非阻塞与程序(线程)等待消息通知(可能是同步，也可能是异步)时的状态有关。也就是说，阻塞与非阻塞是从程序(线程)等待消息通知时的状态来说的。 概念描述阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。 阻塞调用和同步调用很容易混淆，但是它们之间是有区别的。 对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已(什么意思？)，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下： 如果这个线程在等待函数返回时，仍在执行其他消息处理，这种情况叫做同步非阻塞。 如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况叫做同步阻塞。 所以同步的实现方式有两种：同步阻塞、同步非阻塞；同理，异步也有两种实现：异步阻塞、异步非阻塞。 对于阻塞调用来说，当前线程会被挂起等待当前函数返回。 场景继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。 相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。 但是需要注意了，同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。 同步/异步与阻塞/非阻塞 同步阻塞形式效率是最低的。拿上面的例子来说，就是你专心排队，什么别的事都不做。实际程序中：就是未对fd 设置O_NONBLOCK标志位的read/write 操作； 异步阻塞形式如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发(通知)，也就是领取了一张小纸条，假如在这段时间内他不能离开银行做其他的事情，那么显然，这个被阻塞在了这个等待的操作上。异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞(什么意思？)。比如select 函数，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select 调用处。 同步非阻塞形式实际上是效率低下的。想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。 很多人会写阻塞的read/write 操作，但是别忘了可以对fd设置O_NONBLOCK 标志位，这样就可以将同步操作变成非阻塞的了。 异步非阻塞形式效率更高。因为打电话是等待者的事情，而通知等待者则是柜台(消息触发机制)的事情，程序中没有两种不同的操作来回切换。 比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。 如果使用异步非阻塞的情况，比如aio_*组的操作，当发起一个aio_read操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。 很多人会把同步和阻塞混淆，我想是因为很多时候同步操作会以阻塞的形式表现出来，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。 同样地，很多人会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。 总结对上面所讲的概念再次进行一个场景梳理。同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序(线程)等待消息通知时的状态。以小明下载文件打个比方，从这两个关注点来再次说明这两组概念。 同步阻塞：小明一直盯着下载进度条，到 100% 的时候就完成。同步体现在：等待下载完成通知；阻塞体现在：等待下载完成通知过程中，不能做其他任务处理； 同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。同步体现在：等待下载完成通知；非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】 异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。异步体现在：下载完成“叮”一声通知；阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理； 异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。 也就是说，同步/异步是“下载完成消息”通知的方式（机制），而阻塞/非阻塞则是在等待“下载完成消息”通知过程中的状态（能不能干其他任务），在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。 所以，综上所述，同步和异步仅仅是关注的是消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。也就是说，同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁： 在银行的例子中，这个桥梁就是小纸条上面的号码。 在小明的例子中，这个桥梁就是软件“叮”的声音。 参考文献[1]同步、异步、阻塞和非阻塞：https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666538901&amp;idx=1&amp;sn=d1f7d5461491a9c240f16da6b7c0ced9&amp;scene=21#wechat_redirect]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql存储引擎]]></title>
    <url>%2F2019%2F10%2F09%2Fmysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[不同的存储引擎支持不同的锁机制，不同的索引，在内存使用和空间使用上有区别。在批量插入的速度上也有区别。只有InnoDB支持外键。MyISAM支持表锁，而InnoDB支持行锁。 MyISAM不支持事务、也不支持外键，访问的速度快，对事务完整性没有要求或者以select、insert为主的应用基本上都可以使用这个引擎来创建表。InnoDB支持事务，具有提交、回滚和崩溃恢复能力的事务安全。但是与MyISAM相比，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 表锁和行锁表锁是mysql中最基本的锁策略，也是开销最小的锁。表锁会锁定整张表。表锁由mysql服务器层实现，而行锁由存储引擎实现。 参考文献[1]mysql怎么学：https://mp.weixin.qq.com/s/8rAqj56ZHTwJDhQ4UqBr3A]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是线段树，如何实现线段树，线段树用在哪些场景？ 线段树结构 线段树每个节点存储了一个区间上的元素之和． 线段树可以做什么？ 线段树可以在线维护以及查询区间上的最值，求和． 可以扩展到二维线段树（矩阵树）和三维线段树（空间树） 对于一维线段树来说，每次更新以及查询的时间复杂度为O(logn) 线段树中存储树结构所需要的空间大小 无优化的线段树需要2*2k（2k-1&lt;n&lt;2k）空间,一般会开到4*n的空间防止RE Count of Smaller Numbers After Self建立一个线段树，每个节点表示在某个范围内的元素的个数． 参考文献[1] https://www.cnblogs.com/xenny/p/9801703.html[2] 线段树详解: https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[字典树又称为单词查找树．主要应用于字符串的统计和排序，经常被搜索引擎用于文本词频统计． 参考文献[1] 字典树的C++实现 Implement of trie tree: https://blog.csdn.net/pyang1989/article/details/22834653]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql日志]]></title>
    <url>%2F2019%2F10%2F09%2Fmysql%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[mysql日志记录了mysql的日常操作和错误信息，通过日志，我们可以知道mysql内部发生的事情，可以为mysql的管理和优化提供必要的信息。mysql日志主要有：二进制日志、通用查询日志、慢查询日志、错误日志、事务日志。 二进制日志二进制日志用来记录操作mysql数据库中的写入性操作(包括增删改，不包括查询)，操作语句以事件的形式进行保存，描述数据更改。二进制日志的主要作用有两个：1.复制，配置了主从复制的时候，主服务器会将其产生的二进制日志发送给slave，slave会利用这个二进制日志的信息在本地重做，实现主从同步。2.恢复，因为二进制日志包含了备份以后的所有更新，因此可以用于最大限度地恢复数据库。因此，建议二进制日志单独保存到一个磁盘上，以便磁盘损坏后进行数据恢复。 查看二进制日志是否打开使用show variables like ‘log_bin’;可以查看二进制日志是否打开(二进制日志是否启用)。下面的返回表明二进制日志未打开。 1234567mysql&gt; show variables like 'log_bin';+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin | OFF |+---------------+-------+1 row in set (0.00 sec) 下面是在尚未打开二进制日志的情况下，查看当前日志和所生成的二进制文件的结果。 1234567# 查看当前日志mysql&gt; show master status;Empty set (0.00 sec)# 查看日志（所生成的全部日志文件）mysql&gt; show binary logs;ERROR 1381 (HY000): You are not using binary logging 配置二进制日志ubuntu下mysql安装布局 /usr/bin 客户端程序和mysql_install_db/var/lib/mysql 数据库和日志文件/var/run/mysqld 服务器/etc/mysql 配置文件my.cnf/usr/share/mysql 字符集，基准程序和错误消息/etc/init.d/mysql 启动mysql服务器 修改/etc/mysql/conf.d/mysql.cnf，添加以下内容，将二进制日志打开： 1234[mysqld]server_id = 1log-binexpire-logs-days=7 server_id而不是server-id：https://stackoverflow.com/questions/33328652/setting-server-id-variable-in-mysql-doesnt-work 二进制日志内容二进制日志打开后：查看生成的日志 1234567mysql&gt; show binary logs;+-----------------+-----------+| Log_name | File_size |+-----------------+-----------+| ivic-bin.000001 | 658 |+-----------------+-----------+1 row in set (0.00 sec) 通过mysqlbinlog语句查看二进制日志的内容，二进制日志文件名：/var/lib/mysql/ivic-bin.00001 123456789101112 sudo mysqlbinlog -vv /var/lib/mysql/ivic-bin.000001 /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;DELIMITER /*!*/;# at 4#191002 10:00:40 server id 1 end_log_pos 123 CRC32 0x7e402a57 Start: binlog v 4, server v 5.7.27-0ubuntu0.18.04.1-log created 191002 10:00:40 at startup# Warning: this binlog is either in use or was not closed properly.ROLLBACK/*!*/;此处省略多行# End of log file/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/; 通过show binlog events命令查看binlog内记录的事件： 1234567891011121314mysql&gt; show binlog events;+-----------------+-----+----------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------+| Log_name | Pos | Event_type | Server_id | End_log_pos | Info |+-----------------+-----+----------------+-----------+-------------+---------------------------------------------------------------------------------------------------------------+| ivic-bin.000001 | 4 | Format_desc | 1 | 123 | Server ver: 5.7.27-0ubuntu0.18.04.1-log, Binlog ver: 4 || ivic-bin.000001 | 123 | Previous_gtids | 1 | 154 | || ivic-bin.000001 | 154 | Anonymous_Gtid | 1 | 219 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' || ivic-bin.000001 | 219 | Query | 1 | 390 | use `mydb`; create table test_tbl(id INT NOT NULL AUTO_INCREMENT, name varchar(10) not null, primary key(id)) || ivic-bin.000001 | 390 | Anonymous_Gtid | 1 | 455 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' || ivic-bin.000001 | 455 | Query | 1 | 527 | BEGIN || ivic-bin.000001 | 527 | Table_map | 1 | 581 | table_id: 112 (mydb.test_tbl) || ivic-bin.000001 | 581 | Write_rows | 1 | 627 | table_id: 112 flags: STMT_END_F || ivic-bin.000001 | 627 | Xid | 1 | 658 | COMMIT /* xid=29 */ |+-----------------+-----+----------------+-----------+-------------+---------------------------------------------------------------------------------- 各字段含义： 字段名 含义 Log_name 此条log存在的那个文件，这些log存在于文件ivic-bin.000001中 Pos log在bin-log中的开始位置 Event_type log的类型信息 Server_id 可以查看配置中的server_id，表示产生此log的mysql服务器，server_id可以在mysql.cnf中配置 End_log_pos log在bin-log中的结束位置 Info log的一些备注信息，可以直观地看出进行了什么操作 查询日志查询日志能够存放到一个文本文件或表中，全部连接或者表中，全部连接和语句都被记录到该日志文件或表，默认不开启该日志。 错误日志mysql的错误日志记录了mysqld启动和停止时，以及服务器在运行过程中出现的错误。 慢查询日志记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。慢查询日志记录的是查询比较的sql语句的日志，可用于对执行时间较长、执行效率较低的sql语句的性能优化。 事务日志事务日志是InnoDB引擎特有的日志，可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在磁盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久化以后，内存中被修改的数据可以在后台慢慢地刷回到磁盘。目前大多数的存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据需要写两次磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。查看日志参数： 12345678mysql&gt; show global variables like '%log%';+--------------------------------------------+-------------------------------------+| Variable_name | Value |+--------------------------------------------+-------------------------------------+| back_log | 80 || binlog_cache_size | 32768 |此处省略很多行......... 查看事务日志参数： 123456789101112mysql&gt; show global variables like 'innodb_log%';+-----------------------------+----------+| Variable_name | Value |+-----------------------------+----------+| innodb_log_buffer_size | 16777216 || innodb_log_checksums | ON || innodb_log_compressed_pages | ON || innodb_log_file_size | 50331648 || innodb_log_files_in_group | 2 || innodb_log_group_home_dir | ./ || innodb_log_write_ahead_size | 8192 |+-----------------------------+----------+ 总结mysql日志主要有：错误日志、通用查询日志、慢查询日志、事务日志、二进制日志mysql日志的输出位置一般有三种方式：file(文件)、table(表)、none(不保存)mysql日志主要是用于：异常监控、性能优化、数据恢复、主从同步 参考文献[1] mysql日志类型：https://mp.weixin.qq.com/s/zX9rs0SxY68Pmm5hEj1zdw[2]ubuntu下mysql的安装布局：https://www.cnblogs.com/jiangfeilong/p/10527562.html[3]log-bin的配置：https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#option_mysqld_log-bin[4]linux mysql的二进制日志：https://blog.csdn.net/sunny1660/article/details/77505985[6]高性能mysql]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[空间配置器]]></title>
    <url>%2F2019%2F10%2F08%2F%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[STL存在两级空间配置器。其中第一级空间配置器是默认空间配置器。第一级空间配置器用于配置大于128byte的内存，而当申请内存小于等于128bytes时，则求助于第二级空间配置器。 二级空间配置器如果仅使用第一级空间配置器，那么内存分配过程中存在两个问题： 内存碎片(外碎片) 频繁分配小内存，不断调用malloc，进而调用底层的系统调用，产生性能问题 注：内碎片：因为内存对齐/访问效率而产生的，用户需要3字节，实际得到4字节或8字节的问题，其中多出来的字节就是碎片，被浪费了。外碎片：系统中内存总量足够，但是由于离散分配导致不连续，所以无法分配给用户使用而产生的浪费。比如，系统依次分配了16、8、16、4、8byte,还剩一个8byte未分配，这时要分配一个24byte的空间，系统回收两个16 byte，总的空间剩余40byte, 但是却分配不出来一个24byte。 二级空间配置器是为解决“频繁分配小内存”而产生的一种算法，其实就是为了消除一级空间配置器的外碎片问题。 allocate，refill，chunk_alloc调用关系：allocate调用refill，refill调用chunk_alloc。 123graph LRallocate --&gt; refill refill --&gt; chunk_alloc allocateallocate函数详细过程：函数原型：void *__default_alloc_template&lt;threads, inst&gt;::allocate(size_t n);功能：分配指定的n个字节的内存空间。调用refill时，会将n调整到第一个大于等于n的8的倍数。 流程图12345678graph TB start(调用allocate分配n个字节的内存空间) start --&gt; biggerthan128&#123;分配的内存大于128字节&#125; biggerthan128 --&gt; firstlevel[调用第一级空间配置器] biggerthan128 --&gt; secondlevel[从16个free list中对应的那个自由链表中取出一块返回给客户端] secondlevel --&gt; getsucc&#123;成功取回&#125; getsucc --&gt;|是| yessucc[将这一块内存返回给客户端] getsucc --&gt;|否| nosucc[调用refill填充free list,并重新分配一块内存返回给客户端] 源码123456789101112131415161718192021222324252627// n must be &gt; 0, 要分配的内存块大小template&lt;bool threads, int inst&gt;void *__default_alloc_template&lt;threads, inst&gt;::allocate(size_t n) &#123; obj *volatile *my_free_list; // 二级指针，my_free_list是一个指针，它保存着另一个指针的地址，后者则指向一个obj类型对象 obj *result; // 大于128就调用第一级配置器 if (n &gt; (size_t) __MAX_BYTES) &#123; return (malloc_alloc::allocate(n)); &#125; // 寻找16个free list中适当的一个 // my_free_list和free_list+FREELIST_INDEX(n)指向第一个长度为(FREELIST_INDEX(n)+1)*8的可用区块 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; // *my_free_list是一个指向obj类型对象的指针 if (result == 0) &#123; // 没找到可用的free list，准备重新填充free list //ROUND_UP(n): 向上调整n为8的倍数 void *r = refill(ROUND_UP(n)); return r; &#125; // 令free_list+FREELIST_INDEX(n)指向后续一个长度为(FREELIST_INDEX(n)+1)*8的可用区块 // my_free_list和free_list+FREELIST_INDEX(n)这两个指针指向同一个obj*类型的元素 *my_free_list = result-&gt;free_list_link; return result;&#125; FREELIST_INDEX 1234567enum &#123; __ALIGN = 8&#125;; // 小型区块的边界static size_t FREELIST_INDEX(size_t bytes) &#123; return (((bytes) + __ALIGN - 1) / __ALIGN - 1);&#125; 测试程序 123456789101112131415161718void test1() &#123; cout &lt;&lt; FREELIST_INDEX(1) &lt;&lt; endl; // 0(号自由链表):即对应着大小为8字节的区块 cout &lt;&lt; FREELIST_INDEX(12) &lt;&lt; endl; // 1:即对应着大小为16字节的区块 cout &lt;&lt; FREELIST_INDEX(21) &lt;&lt; endl; // 2:即对应着大小为24字节的区块 cout &lt;&lt; FREELIST_INDEX(30) &lt;&lt; endl; // 3:即对应着大小为32字节的区块 cout &lt;&lt; FREELIST_INDEX(33) &lt;&lt; endl; // 4:即对应着大小为40字节的区块 cout &lt;&lt; FREELIST_INDEX(41) &lt;&lt; endl; // 5:即对应着大小为48字节的区块 cout &lt;&lt; FREELIST_INDEX(51) &lt;&lt; endl; // 6:即对应着大小为56字节的区块 cout &lt;&lt; FREELIST_INDEX(60) &lt;&lt; endl; // 7:即对应着大小为64字节的区块 cout &lt;&lt; FREELIST_INDEX(65) &lt;&lt; endl; // 8:即对应着大小为72字节的区块 cout &lt;&lt; FREELIST_INDEX(74) &lt;&lt; endl; // 9:即对应着大小为80字节的区块 cout &lt;&lt; FREELIST_INDEX(85) &lt;&lt; endl; // 10:即对应着大小为88字节的区块 cout &lt;&lt; FREELIST_INDEX(92) &lt;&lt; endl; // 11:即对应着大小为96字节的区块 cout &lt;&lt; FREELIST_INDEX(97) &lt;&lt; endl; // 12:即对应着大小为104字节的区块 cout &lt;&lt; FREELIST_INDEX(105) &lt;&lt; endl; // 13:即对应着大小为112字节的区块 cout &lt;&lt; FREELIST_INDEX(116) &lt;&lt; endl; // 14:即对应着大小为120字节的区块 cout &lt;&lt; FREELIST_INDEX(121) &lt;&lt; endl; // 15:即对应着大小为128字节的区块&#125; refill函数原型：void *__default_alloc_template&lt;threads, inst&gt;::refill(size_t n)功能：当allocate为客户端分配指定的n(n&lt;=128)个字节的内存，却发现free list空间不足时，就会调用refill()，为free list重新填充空间。新的空间分配并不由本函数完成，而是调用chunk_alloc来完成。本函数需要完成的是，为chunk_alloc指定需要分配的区块大小(即n个字节)以及区块个数(默认为20)。当chunk_alloc返回分配的内存的首地址时，本函数再根据返回的内存的大小决定是否需要向自由链表中添加内存区块。 流程图1234567graph TB start(调用refill) --&gt; setparams[指定chunk_alloc的参数: 需要分配的区块大小,及区块个数] setparams --&gt; callchunk[调用chunk_alloc从内存池分配内存] callchunk --&gt; getmemory[获取chunk_alloc返回的内存空间首地址] getmemory --&gt; hasmorethanone&#123;chunk_alloc返回的内存是否大于一个区块&#125; hasmorethanone --&gt;|是| returntoclient[将这一个区块返回给调用者--即allocate] hasmorethanone --&gt;|否| savetofreelist[多出的部分添加到free list中, 返回一个区块给allocate] chunk_alloc函数原型：char *__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int &amp;nobjs)参数：size为区块大小(8的倍数，从8-128共16种可能的大小)；参数：nobjs为期望分配的区块个数，默认为20。功能：从内存池中取出空间给free list使用。 流程图1234567graph TB start(调用chunk_alloc) --&gt; hasenoughmem&#123;内存池剩余空间满足需求&#125; hasenoughmem --&gt;|是| yesmem[从内存池中取出n*nobjs个字节的内存,返回给调用者] hasenoughmem --&gt;|否| hasoneblock&#123;内存池剩余空间至少有一个区块大小,n个字节&#125; hasoneblock --&gt;|是| yesoneblock[从内存池中取出尽量多个区块,返回给调用者] hasoneblock --&gt;|否| handleleftmem[将内存池中剩余的内存分配给适当的自由链表] handleleftmem --&gt; nooneblock[使用malloc从系统堆中分配内存] 12345678910graph TD nooneblock[使用malloc从系统堆中分配内存] nooneblock --&gt; getsucc&#123;分配成功&#125; getsucc --&gt;|是| yesget[将新内存放入内存池中] yesget --&gt; callagain[再次调用chunk_alloc尝试分配n*nobjs个字节的内存,并返回首地址给调用者] getsucc --&gt;|否| noget[遍历free list,希望找到比n个字节的区块大的区块] noget --&gt; hasbiggerblock&#123;是否存在比n个字节更大的区块&#125; hasbiggerblock --&gt;|是| yesbigger[找到第一个比n个字节大的区块放入内存池] yesbigger --&gt; callagain hasbiggerblock --&gt;|否| nobigger[调用第一级配置器,补充内存池空间] 几个疑问为什么自由链表中分配的内存都需要上调到8字节的倍数？ 参考文献[1]二级空间配置器的必要性：http://www.dongcoder.com/detail-67805.html]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从ubuntu中卸载Adobe Acrobat reader]]></title>
    <url>%2F2019%2F10%2F07%2F%E4%BB%8Eubuntu%E4%B8%AD%E5%8D%B8%E8%BD%BDAdobe-Acrobat-reader%2F</url>
    <content type="text"><![CDATA[在ubuntu 18.0.4中安装了Adobe Acrobat Reader，之后pdf文件就和Adobe reader关联起来了。但是该软件似乎没有安装成功，每次试图用它打开pdf文件都会失败。 于是乎，只能又安装了一个其他的pdf阅读器，但是，问题来了，pdf文件还是优先和Adobe reader关联。所以，我就想卸载掉这个占着茅坑不拉屎的家伙。然后呢，我就找到了这个：在Ubuntu中，如何卸载/删除 Adobe Flash Player？ 其中，给出了解决方案。 如果你使用Apt安装的它，请在terminal中运行下面的命令查找软件包名称 123456&gt; # 这篇文章中针对的是flash&gt; dpkg --get-selections | grep -v deinstall | grep flash | awk '&#123; print $1 &#125;'&gt; &gt; # 本文针对的是reader&gt; dpkg --get-selections | grep -v deinstall | grep reader | awk '&#123;print $1&#125;'&gt; 然后，通过下面的命令来卸载软件。 12&gt; sudo apt-get purge package-name&gt; 下面我重点来讲解一下上面的查找软件包名称的那条命令。首先关于dpkg 来自百度百科的介绍 “dpkg ”是“Debian Packager ”的简写。为 “Debian” 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自“Debian”的“Linux ”发行版都使用 “dpkg”，例如 “Ubuntu”、“Knoppix ”等。dpkg是Debian软件包管理器的基础，它被伊恩·默多克创建于1993年。dpkg与RPM十分相似，同样被用于安装、卸载和供给.deb软件包相关的信息。dpkg本身是一个底层的工具。上层的工具，如APT，被用于从远程获取软件包以及处理复杂的软件包关系。 “dpkg”是“Debian Package”的简写。 通过dpkg –help可以查看–get-selections选项的作用 –get-selections [&lt;表达式&gt; …] 把已选中的软件包列表打印到标准输出。 dpkg –get-selections显示包含标记install或者deinstall之一的包。grep -v 进行反向选择dpkg –get-selections | grep -v deinstall 即显示出所有标记为install的包。dpkg –get-selections | grep -v deinstall | grep reader即从上述结果中找出包含reader的包。dpkg –get-selections | grep -v deinstall | grep reader | awk ‘{print $1}’ 即输出找到的包的名称($1表示取第一个字段)。 参考文献[1]在Ubuntu中，如何卸载/删除 Adobe Flash Player：https://www.helplib.com/ubuntu/article_168889[2]ubuntu常用的dpkg：https://www.tecmint.com/dpkg-command-examples/[3]ubuntu常用的apt命令：https://www.tecmint.com/useful-basic-commands-of-apt-get-and-apt-cache-for-package-management/[4]ubuntu manuals：]]></content>
      <categories>
        <category>计算机日常使用</category>
      </categories>
      <tags>
        <tag>linux系统</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包管理工具aptitude]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7aptitude%2F</url>
    <content type="text"><![CDATA[来自百度百科的介绍 aptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。举例来说，aptitude在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 之所以要来说一说这个包管理工具，是因为在ubuntu中安装软件的时候经常遇到依赖未安装的问题．每次遇到这种情况，就需要包管理工具来帮忙了．]]></content>
      <categories>
        <category>计算机日常使用</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>liunx系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[523. Continuous Subarray Sum]]></title>
    <url>%2F2019%2F10%2F07%2F523.Continuous-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to nk where n is also an *integer**. Example 1: 123Input: [23, 2, 4, 6, 7], k=6Output: TrueExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6. Example 2: 123Input: [23, 2, 6, 4, 7], k=6Output: TrueExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42. 解法1: 二重循环枚举所有可能的子数组组合时间复杂度分析 时间复杂度为O(n2) 解法2相关题目leetcode 974 leetcode 560]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2019%2F10%2F07%2F560.-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 最朴素且有问题的思路1234567891011121314151617class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; mp; mp[0] = -1; // 记录第一个满足子数组和为0的位置 int cnt = 0; int sum = 0; for(int i=0;i&lt;nums.size();++i)&#123; sum += nums[i]; if(mp.find(sum - k)!=mp.end())&#123; ++cnt; &#125; mp[sum] = i; &#125; return cnt; &#125;&#125;; 代码提交结果：62 / 80 test cases passed. Input:[0,0,0,0,0,0,0,0,0,0] 0Output:10Expected:55 这个解法的问题在于未考虑到当子数组以nums[i]结尾时，存在多个子数组满足子数组和为sum - k。在这个思路的基础上进行修改，可以得到解法3。 解法1: 遍历子数组当给定i时, sum 表示以arr[i]开始,到arr[j]结束的各个元素的累加和(j&gt;=i). 注意: 这里不需要知道是哪些子数组的和等于k,只需要统计和等于k的子数组的个数,因此这里不必记录子数组的开始和结束索引,只需要依次找出所有子数组,并统计其中和等于k的子数组的个数. 那么如何找出所有可能的子数组呢? 方法一:内存循环找出所有以数组中第i个元素开始的所有子数组,并统计其中和等于k的子数组的个数.而外层循环则依次枚举所有可能的i. 方法二: 下面给出的代码是内层循环统计以数组中第j个元素结尾的子数组的和等于k的子数组的个数, 外层循环列举所有可能的j.具体而言, 内层循环依次计算 arr[j]arr[j-1] + arr[j]arr[j-2] + arr[j-1] + arr[j]…….arr[2] + … + arr[j]arr[1] + arr[2] + … + arr[j] 也就是子数组arr[i,..,j]的和. i = j, j-1,…1若令s[i] 表示arr[1] + arr[2] + … + arr[i]那么子数组arr[i,…j]的和可以表示为s[j] - s[i-1] AC代码１ 123456789101112131415class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum = 0; for(int j=i;j&lt;nums.size();j++)&#123; sum += nums[j]; if(sum == k) ++counter; &#125; &#125; return counter; &#125;&#125;; AC代码2: 12345678910111213141516class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum = 0; for(int i=j;i&gt;=0;i--)&#123; sum += nums[i]; if(sum == k)&#123; ++counter; &#125; &#125; &#125; return counter; &#125;&#125;; 时间复杂度分析 时间复杂度: O(n2). 只用到两重循环, 容易得出时间复杂度空间复杂度:O(1) 解法2如方法二所述, 子数组arr[i, … , j]的和可以表示为s[j] - s[i-1]s[0] = arr[0]这里为了表示空数组的和为0, 不妨令s的下标从1开始.即 s[0] = 0, 表示空数组的和为0s[1] = arr[0]s[2] = arr[0] + arr[1]s[3] = arr[0] + arr[1] + arr[2] 依次类推. 那么各子数组的和可以表示为 arr[0] = s[1] - s[0]arr[0,1] = arr[0] + arr[1] = s[2] - s[0]arr[1] = s[2] - s[1]arr[1,3] = arr[1] + arr[2] + arr[3] = s[4] - s[1] 以此类推,可知 arr[i,….,j] = s[j+1] - s[i] 若要子数组arr[i,…,j]的和等于k,即s[j+1] - s[i] = k, 即s[i] = s[j+1] - k, 即当已知arr[1,…j]时只需要统计其前面的子数组中和等于s[j+1] - k的子数组的个数就可以统计以第j个元素结尾的子数组中满足和等于k的子数组的个数. AC代码 1234567891011121314151617181920class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; vector&lt;int&gt; temp; temp.push_back(0); for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; // 统计s[0], s[1], s[2],..,s[j]中和等于s[j+1] - k for(int i=0;i&lt;temp.size();i++)&#123; if(sum - temp[i] == k)&#123; ++counter; &#125; &#125; temp.push_back(sum); &#125; return counter; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(n) 可以看到这里的内层使用遍历的方法来统计数组中满足条件的子数组个数.但实际上,我们并不关心哪些子数组满足条件,而只需要知道满足条件的子数组个数,也就是说,我们不必记录s[j+1]之前的每个s[i](i&lt;=j)具体由哪些元素组成, 我们只需要记住,s[i]有哪些可能的值及这些可能值出现的次数.因此,我们可以使用map来记录每个值出现的次数.而从map中取出一个key对应的值只需要常量时间,通过这种方式可以大大降低所需时间.具体代码见下面代码. 解法3: 使用map在最朴素的思路基础上，使用mp[i]表示子数组和为i的子数组个数。然后统计，当子数组以nums[i]结尾，且子数组nums[0]-nums[i]的和为sum时，以nums[j](j&lt;i)结尾且和为sum - k的子数组个数，这就是以nums[i]结尾且何为k的子数组个数。 1234567891011121314151617class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0; map&lt;int, int&gt; mp; mp[0] = 1; int cnt = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; if(mp.find(sum - k)!=mp.end())&#123; cnt += mp[sum -k]; &#125; ++mp[sum]; &#125; return cnt; &#125;&#125;; mp[sum -k]统计的是arr[i]之前的s[j]是否等于 sum - k.则s[i] - s[j] = arr[j+1] + arr[j+2] + .. + arr[i] = k.这样同样需要注意需要额外设置mp[0] = 1; 表示存在空子数组的和为0.复杂度分析 时间复杂度为O(n).空间复杂度为O(n). 要统计多少个子数组的和为k,则可以分别统计以数组中每个元素结尾的子数组中有多少个子数组的和等于k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和系列</tag>
        <tag>累积和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F10%2F07%2F%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[以下对进程相关的几个概念进行解释． 什么是孤儿进程，僵尸进程 子进程是在父进程调用fork函数后生成的．子进程将其终止状态返回给父进程．但是如果父进程在子进程之前终止，那么会发生什么呢？对于父进程已经终止的所有进程，他们的父进程都会变成init进程，称这些进程被init进程收养。 操作过程大致为：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，将该进程的父进程ID改为1(init进程的ID)。 子进程终止时，它与父进程之间的关联还会保持，直到父进程也正常终止或父进程调用wait才告结束．尽管它已经不再运行了，但是它仍然存在于系统中．内核为每个终止子进程保存了一些信息，当终止进程的父进程调用wait或waitpid时，可以得到这些信息．这些信息包括进程ID，该进程的终止状态以及进程使用的CPU时间总量。 这样一个已经终止，但其父进程尚未对其进程善后处理(获取终止子进程的有关信息，释放它仍占用的资源)的进程被称为僵尸进程。 如果子进程先于父进程终止，那么子进程会成为一个僵尸进程。若此时，父进程异常终止，则子进程会被init进程接管，即init进程成为该(已结束)子进程的父进程，并负责对其进行善后处理。 进程同步与进程互斥的区别与联系https://zhuanlan.zhihu.com/p/69581607 互斥量，信号量，锁等概念]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[974. Subarray Sums Divisible by K]]></title>
    <url>%2F2019%2F10%2F06%2F974.Subarray-Sums-Divisible-by-K%2F</url>
    <content type="text"><![CDATA[Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. Example 1: 1234Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 解法一: hashmap和leetcode 560、523相似的思路。使用hashmap来记录当前满足条件的子数组个数。当以数组中第i个元素nums[i]结尾的子数组的和为sum，那么在hashmap中记录了以nums[0], nums[1],…,nums[i-1]结尾的子数组的和。但是这里记录的和是对K取余后的。若nums[0] = sum1，nums[0] +…+ nums[j] = sum1 + n * K，则(nums[0] +….+ nums[j]) % K = sum1，即这两个子数组和取余后都等于同一个数，即子数组nums[1] + … + nums[j] = K。但是需要注意的是：当子数组和为负数时，需要不断加上K直到子数组和为正数。 例如: [7, 4, -10] 5i = 0, sum = 7, mp[0] = 1(空数组的和为0) sum = 7 % 5 = 2 mp[2] = 0， 因此，尚不存在以nums[0]结尾的子数组和为5的倍数 i = 1, sum = (2 + 4 ) % 5 = 1 mp[0] = 1, mp[2] = 1 又mp[1] = 0 ，因此，尚不存在以nums[1]结尾的子数组和为5的倍数 mp[1] = 1 i = 2, sum = (1+-10) % 5 = -9 % 5 = -4, sum = (-4+5)%5 = 1 又mp[1] = 1，因此，存在一个以nums[2]结尾的子数组和为5的倍数 AC代码 123456789101112131415161718class Solution &#123;public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123; map&lt;int, int&gt; mp; mp[0] = 1; int sum = 0; int cnt = 0; for(int i=0;i&lt;A.size();++i)&#123; sum += A[i]; sum = ((sum % K) + K ) % K; if(mp.find(sum)!=mp.end())&#123; cnt += mp[sum]; &#125; ++mp[sum]; &#125; return cnt; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(min(n, K)) 时间复杂度为O(n)出现在K&gt;n时。如K很大，而A中每个元素都很小，且都是正数。例如 A=[1,1,1,1,1,1,1], K = A.size() + 1。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2019%2F10%2F06%2F560.Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 12Input:nums = [1,1,1], k = 2Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. 最朴素且有问题的思路1234567891011121314151617class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; mp; mp[0] = -1; // 记录第一个满足子数组和为0的位置 int cnt = 0; int sum = 0; for(int i=0;i&lt;nums.size();++i)&#123; sum += nums[i]; if(mp.find(sum - k)!=mp.end())&#123; ++cnt; &#125; mp[sum] = i; &#125; return cnt; &#125;&#125;; 代码提交结果：62 / 80 test cases passed. Input:[0,0,0,0,0,0,0,0,0,0] 0Output:10Expected:55 这个解法的问题在于未考虑到当子数组以nums[i]结尾时，存在多个子数组满足子数组和为sum - k。在这个思路的基础上进行修改，可以得到解法3。 解法1: 遍历子数组当给定i时, sum 表示以arr[i]开始,到arr[j]结束的各个元素的累加和(j&gt;=i). 注意: 这里不需要知道是哪些子数组的和等于k,只需要统计和等于k的子数组的个数,因此这里不必记录子数组的开始和结束索引,只需要依次找出所有子数组,并统计其中和等于k的子数组的个数. 那么如何找出所有可能的子数组呢? 方法一:内存循环找出所有以数组中第i个元素开始的所有子数组,并统计其中和等于k的子数组的个数.而外层循环则依次枚举所有可能的i. 方法二: 下面给出的代码是内层循环统计以数组中第j个元素结尾的子数组的和等于k的子数组的个数, 外层循环列举所有可能的j.具体而言, 内层循环依次计算 arr[j]arr[j-1] + arr[j]arr[j-2] + arr[j-1] + arr[j]…….arr[2] + … + arr[j]arr[1] + arr[2] + … + arr[j] 也就是子数组arr[i,..,j]的和. i = j, j-1,…1若令s[i] 表示arr[1] + arr[2] + … + arr[i]那么子数组arr[i,…j]的和可以表示为s[j] - s[i-1] AC代码１ 123456789101112131415class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum = 0; for(int j=i;j&lt;nums.size();j++)&#123; sum += nums[j]; if(sum == k) ++counter; &#125; &#125; return counter; &#125;&#125;; AC代码2: 12345678910111213141516class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum = 0; for(int i=j;i&gt;=0;i--)&#123; sum += nums[i]; if(sum == k)&#123; ++counter; &#125; &#125; &#125; return counter; &#125;&#125;; 时间复杂度分析 时间复杂度: O(n2). 只用到两重循环, 容易得出时间复杂度空间复杂度:O(1) 解法2如方法二所述, 子数组arr[i, … , j]的和可以表示为s[j] - s[i-1]s[0] = arr[0]这里为了表示空数组的和为0, 不妨令s的下标从1开始.即 s[0] = 0, 表示空数组的和为0s[1] = arr[0]s[2] = arr[0] + arr[1]s[3] = arr[0] + arr[1] + arr[2] 依次类推. 那么各子数组的和可以表示为 arr[0] = s[1] - s[0]arr[0,1] = arr[0] + arr[1] = s[2] - s[0]arr[1] = s[2] - s[1]arr[1,3] = arr[1] + arr[2] + arr[3] = s[4] - s[1] 以此类推,可知 arr[i,….,j] = s[j+1] - s[i] 若要子数组arr[i,…,j]的和等于k,即s[j+1] - s[i] = k, 即s[i] = s[j+1] - k, 即当已知arr[1,…j]时只需要统计其前面的子数组中和等于s[j+1] - k的子数组的个数就可以统计以第j个元素结尾的子数组中满足和等于k的子数组的个数. AC代码 1234567891011121314151617181920class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0, counter = 0; vector&lt;int&gt; temp; temp.push_back(0); for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; // 统计s[0], s[1], s[2],..,s[j]中和等于s[j+1] - k for(int i=0;i&lt;temp.size();i++)&#123; if(sum - temp[i] == k)&#123; ++counter; &#125; &#125; temp.push_back(sum); &#125; return counter; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(n) 可以看到这里的内层使用遍历的方法来统计数组中满足条件的子数组个数.但实际上,我们并不关心哪些子数组满足条件,而只需要知道满足条件的子数组个数,也就是说,我们不必记录s[j+1]之前的每个s[i](i&lt;=j)具体由哪些元素组成, 我们只需要记住,s[i]有哪些可能的值及这些可能值出现的次数.因此,我们可以使用map来记录每个值出现的次数.而从map中取出一个key对应的值只需要常量时间,通过这种方式可以大大降低所需时间.具体代码见下面代码. 解法3: 使用map在最朴素的思路基础上，使用mp[i]表示子数组和为i的子数组个数。然后统计，当子数组以nums[i]结尾，且子数组nums[0]-nums[i]的和为sum时，以nums[j](j&lt;i)结尾且和为sum - k的子数组个数，这就是以nums[i]结尾且何为k的子数组个数。 1234567891011121314151617class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int sum = 0; map&lt;int, int&gt; mp; mp[0] = 1; int cnt = 0; for(int j=0;j&lt;nums.size();j++)&#123; sum += nums[j]; if(mp.find(sum - k)!=mp.end())&#123; cnt += mp[sum -k]; &#125; ++mp[sum]; &#125; return cnt; &#125;&#125;; mp[sum -k]统计的是arr[i]之前的s[j]是否等于 sum - k.则s[i] - s[j] = arr[j+1] + arr[j+2] + .. + arr[i] = k.这样同样需要注意需要额外设置mp[0] = 1; 表示存在空子数组的和为0.复杂度分析 时间复杂度为O(n).空间复杂度为O(n). 要统计多少个子数组的和为k,则可以分别统计以数组中每个元素结尾的子数组中有多少个子数组的和等于k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>子数组和系列</tag>
        <tag>累积和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[958. Check Completeness of a Binary Tree]]></title>
    <url>%2F2019%2F10%2F06%2F%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Check Completeness of a Binary Tree Given a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example 1: 123Input: [1,2,3,4,5,6]Output: trueExplanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible. Example 2: 123Input: [1,2,3,4,5,null,7]Output: falseExplanation: The node with value 7 isn&apos;t as far left as possible. 解法一 思路：层次遍历每一个节点，当遇到第一个叶子节点或最后一个非叶子节点时，判断此后的每一个节点都是叶子节点。对于每一个节点，如果它是非叶子节点，那么它要么有两个孩子节点，否则，只有左孩子节点，如果一个节点有右孩子而没有左孩子，则该节点不是完全二叉树上的节点。当一个节点只有左孩子，没有右孩子，则该节点是最后一个非叶子节点；如果一个节点既没有左孩子节点也没有右孩子节点，则该节点是第一个叶子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool isCompleteTree(TreeNode* root) &#123; if(root == nullptr)&#123; return true; &#125; queue&lt;TreeNode*&gt; q; TreeNode* node = nullptr; int cur = 1; int next = 0; q.push(root); while(!q.empty())&#123; node = q.front(); q.pop(); if(node-&gt;left !=nullptr)&#123; q.push(node-&gt;left); ++next; &#125; if(node-&gt;right !=nullptr)&#123; if(node-&gt;left == nullptr)&#123; return false; &#125; q.push(node-&gt;right); ++next; &#125; // first leaf or last not leaf else&#123; while(!q.empty()) &#123; node = q.front(); q.pop(); if(node-&gt;left != nullptr || node-&gt;right != nullptr)&#123; return false; &#125; &#125; break; &#125; if(--cur==0)&#123; cur = next; next = 0; &#125; &#125; // only one node return true; &#125;&#125;; 相关题目958. Check Completeness of a Binary Tree222. Count Complete Tree Nodes919. Complete Binary Tree Inserter]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[222. Count Complete Tree Nodes]]></title>
    <url>%2F2019%2F10%2F06%2F222.-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: 12345678Input: 1 / \ 2 3 / \ /4 5 6Output: 6 完全二叉树的定义：它是一棵空树或者它的叶子节点只出现在最后两层。若最后一层不满，则叶子节点只出现在最左侧。 对于满二叉树，如果层数为h，则总节点个数为：2h-1。因此，对根节点的左右子树的高度进行统计，假设左子树的高度记做lh，右子树的高度记做rh。1.如果lh == rh，说明左子树和右子树一样高，那么左子树一定是满二叉树，所以左子树的总结点个数为2lh-1-1。加上根节点，共有2lh-1个节点。然后再对右子树进行递归统计。2.如果lh&gt;rh，说明最后一层不满，但是倒数第二层必然是满的，因此右子树节点总数为2rh-1，再加上根节点，共有2rh-1个节点。再对左子树进行递归统计。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F05%2F%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[未排序正数数组中累加和为给定值的最长子数组长度]]></content>
  </entry>
  <entry>
    <title><![CDATA[Two Sum 系列, 和为s的两个数字系列(2sum)]]></title>
    <url>%2F2019%2F10%2F05%2FTwo%20Sum%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[和为S两个数字 题目来源：剑指offer题目链接 题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 1对应每个测试案例，输出两个数，小的先输出。 解法1: 使用set12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; set&lt;int&gt; iset; vector&lt;int&gt; res(2); int mul = INT_MAX; for(int i=0;i&lt;array.size();i++)&#123; if(iset.find(sum - array[i])!=iset.end())&#123; int temp = array[i] * (sum - array[i]); if(temp &lt; mul)&#123; mul = temp; res[0] = sum - array[i]; res[1] = array[i]; &#125; &#125; iset.insert(array[i]); &#125; // 当找不到两个数的和为sum时，如何处理：返回空数组 if(mul == INT_MAX)&#123; return &#123;&#125;; &#125; return res; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(n) 解法2:双指针 思路：数组是有序的，可以用双指针。 AC代码： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; int i = 0, j = array.size() - 1; int lo = -1, hi = array.size(); int mul = INT_MAX; while(i &lt; j)&#123; int tmp = array[i] + array[j]; if(tmp == sum)&#123; if(tmp &lt; mul)&#123; mul = tmp; lo = i, hi = j; &#125; ++i, --j; &#125;else if(tmp &lt; sum)&#123; ++i; &#125;else&#123; --j; &#125; &#125; if(mul == INT_MAX)&#123; return &#123;&#125;; &#125; return &#123;array[lo], array[hi]&#125;; &#125;&#125;; 时间复杂度分析 时间复杂度为O(n)空间复杂度为O(1) 和为S的连续正数序列题目链接 题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述 1输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解法112345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; if(sum == 1)&#123; return &#123;&#125;; &#125; int thisSum = 0; vector&lt;vector&lt;int&gt;&gt; res; int n = (sum + 1) / 2; vector&lt;int&gt; ans(n+1, 0); for(int i=1;i&lt;=n;i++)&#123; thisSum += i; ans[i] = thisSum; &#125; for(int i=0;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(ans[j] - ans[i] == sum)&#123; vector&lt;int&gt; tmp; for(int k=i+1;k&lt;=j;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; &#125; &#125; return res; &#125;&#125;; 使用累计和的概念.ans[i]统计0-i的和. 解法2AC代码1 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; int l = 1, r = 2; int thisSum = l + r; vector&lt;vector&lt;int&gt;&gt; res; while(l&lt;= (1+sum)/2)&#123; if(thisSum == sum)&#123; vector&lt;int&gt; tmp; for(int k=l;k&lt;=r;k++)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; if(thisSum &lt; sum)&#123; thisSum += ++r; &#125;else&#123; thisSum -= l++; &#125; &#125; return res; &#125;&#125;; AC代码2 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; int n = (sum + 1) / 2; int i = 1, j = 2; int thisSum = 1 + 2; vector&lt;vector&lt;int&gt;&gt; res; while(j &lt;= n)&#123; if(sum &gt;= thisSum)&#123; if(sum == thisSum)&#123; vector&lt;int&gt; tmp; for(int k = i;k&lt;=j;++k)&#123; tmp.push_back(k); &#125; res.push_back(tmp); &#125; thisSum += ++j; &#125;else&#123; thisSum -= i++; &#125; &#125; return res; &#125;&#125;; thisSum表示子数组arr[l,…,r]的累加和. 最初, l=1, r =2, 最小的两个连续正数序列的和为1+2=3.所以,将thisSum初始化为3.循环结束条件为两个数的和大于等于sum时,因此可知,满足这个条件的最大的子数组为[n, n+1], n = (1+sum)/2.因此,需要循环结束条件为l = (1+sum)/2 Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 此题和上题的区别有两点： 返回下标，而不是值 数组不是有序的 若是返回的是值，可以对数组进行排序然后按双指针解。时间复杂度为O(nlogn)。排序的时间复杂度为O(n)。 解法1：暴力破解1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size()-1; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[i] + nums[j] == target)&#123; return &#123;i, j&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n2)，空间复杂度为O(1)。 解法2：两趟哈希表12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; mp[nums[i]] = i; &#125; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!= mp.end() &amp;&amp; mp[complement]!=i)&#123; return &#123;i, mp[complement]&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法3：一趟哈希表1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; int complement = target - nums[i]; if(mp.find(complement)!=mp.end())&#123; return &#123;mp[complement], i&#125;; &#125; mp[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 3SumMedium Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路：首先对数组进行排序。然后锁定第一个数，如第一个数的索引是i，则此后在front-back范围内（front &gt; i）寻找两个数，使他们的和为0 - nums[i]。随着i后移，front和back指定的范围在缩小。因为nums[i]增大，则0 - nums[i]减小。且移动过程中需要去重。 如将上例数据改为： 1Given array nums = [-1, 0, 1, 0, 1, 2, -1, -4, 2, 3] 则排序后： 1array nums = [-4, -1, -1, 0, 0, 1, 1, 2, 2, 3] 过程如下：注意去重 i = 0, front = 1, back = 9, 在front-back中找两个数的和为4 front = 5, back= 9, nums[5]=1, nums[9]=3(front = 6, nums[front]=1，需要去重) front = 7, back=8, nums[7]=2, nums[8]=2i = 1, front = 1, back = 9, 在front-back中找两个数的和为1 front = 2, back = 8, nums[2] = -1, nums[8] = 2 front = 3, back = 6, nums[3] = 0, nums[6] = 1(后面back=5, nums[5]=0, 需要去重)i = 2(nums[2] = -1需要去重) 此题的难点主要在于如何消除重复元素的影响。 有点问题的代码：此代码的问题在于，没有考虑到重复元素的问题。例如 nums = [0,0,0,0]solution set is [[0,0,0], [0, 0, 0]]对于考虑到了外重循环遇到重复元素的问题，即对于索引0处的元素和索引1,2,3处的元素都相同，因此，不再统计由索引1,2,3处元素开始的子集合。但是对于内重循环未考虑到当第一个元素确定时，第二个元素和第三个元素重复的问题。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return &#123;&#125;; &#125; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int pre; map&lt;int, int&gt; count; for(int i=0;i&lt;nums.size();++i)&#123; if(nums[i] &gt; 0)&#123; break; &#125; if(i &amp;&amp; nums[i] == pre)&#123; continue; &#125; pre = nums[i]; int complement = 0 - nums[i]; count.clear(); for(int j=i+1;j&lt;nums.size();++j)&#123; int target = complement - nums[j]; if(count.find(target) !=count.end())&#123; int pos = count[target]; res.push_back(&#123;nums[i], nums[pos], nums[j]&#125;); &#125; count[nums[j]] = j; &#125; &#125; return res; &#125;&#125;; AC代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return &#123;&#125;; &#125; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int pre; map&lt;int, int&gt; count; for(int i=0;i&lt;nums.size();++i)&#123; if(nums[i] &gt; 0)&#123; break; &#125; if(i &amp;&amp; nums[i] == pre)&#123; continue; &#125; pre = nums[i]; int complement = 0 - nums[i]; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; if(nums[j] + nums[k] == complement)&#123; res.push_back(&#123;nums[i], nums[j], nums[k]&#125;); while(j &lt; k &amp;&amp; nums[j] == nums[j+1])&#123; ++j; &#125; while(j &lt; k &amp;&amp; nums[k] == nums[k-1])&#123; --k; &#125; ++j, --k; &#125;else if(nums[j] + nums[k] &gt; complement)&#123; --k; &#125;else&#123; ++j; &#125; &#125; &#125; return res; &#125;&#125;; 相关题目在未排序正数数组中累加和为给定值的最长子数组长度]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inserter]]></title>
    <url>%2F2019%2F10%2F03%2Finserter(%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8)%2F</url>
    <content type="text"><![CDATA[insert iterators，可以将一般迭代器的赋值操作转变为插入操作。这样的迭代器包括包括专门负责尾端插入操作的back_insert_iterator，专门负责头端插入操作的front_insert_iterator，以及可从任意位置执行插入操作的insert_iterator。由于这三个iterator adapters的使用接口不是十分直观，给一般用户带来困扰，因此，STL提供三个相应函数: back_inserter()，front_insert()，inserter()。 STL提供的三个函数inserter()使用insert()的两个例子 12 12template &lt;class Container&gt; insert_iterator&lt;Container&gt; inserter (Container&amp; x, typename Container::iterator it); 参考文献[1]http://www.cplusplus.com/reference/iterator/inserter/?kw=inserter]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[784. Letter Case Permutation]]></title>
    <url>%2F2019%2F10%2F03%2F784.-Letter-Case-Permutation%2F</url>
    <content type="text"><![CDATA[Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. 123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] Note: S will be a string with length between 1 and 12. S will consist only of letters or digits. 解法一：回溯12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; letterCasePermutation(string S) &#123; string tmp; vector&lt;string&gt; res; dfs(S, tmp, res, 0); return res; &#125; void dfs(string &amp;s, string &amp;tmp,vector&lt;string&gt; &amp;res, int pos)&#123; if(pos == s.size())&#123; res.push_back(tmp); return ; &#125; // 如果是数字，直接加入 if(s[pos] &gt;= '0' &amp;&amp; s[pos] &lt;= '9')&#123; tmp.push_back(s[pos]); dfs(s, tmp, res, pos + 1); tmp.pop_back(); &#125;else&#123; // 如果是英文字母，分别加入小写形式和大写形式 tmp.push_back(tolower(s[pos])); dfs(s, tmp, res, pos + 1); tmp.pop_back(); tmp.push_back(toupper(s[pos])); dfs(s, tmp, res, pos + 1); tmp.pop_back(); &#125; &#125;&#125;; 解法二：bit manipulation123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; letterCasePermutation(string S) &#123; int sum = 1; for(int i=0;i&lt;S.size();++i)&#123; if(isalpha(S[i]))&#123; // check if a char is a alphabetic sum *= 2; &#125; &#125; vector&lt;string&gt; res; string tmp; int tmpSum = 0; for(int i=0;i&lt;sum;++i)&#123; tmpSum = i; tmp = S; for(int j=0;j&lt;S.size();++j)&#123; if(isalpha(S[j]))&#123; if(tmpSum &amp; 1) // tmpSum[j] == 1 tmp[j] = toupper(S[j]); else tmp[j] = tolower(S[j]); tmpSum /= 2; // tmpSum right move &#125; &#125; res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文本查询小例子]]></title>
    <url>%2F2019%2F10%2F03%2F%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[本文档是为了简述文本查询的小例子。 下面的UML图不完全遵循UML图的规定。红色和黄色代表属性。浅蓝色表示private方法，绿色表示public方法。紫色表示继承自父类的virtual方法。]]></content>
      <categories>
        <category>实战</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类之间的关系]]></title>
    <url>%2F2019%2F10%2F03%2F%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[类之间的关系有composition(has-a)，delegation(委托)等． Composition 构造由内而外，如Container中包含Component，那么Container的构造函数首先调用Conponent的default构造函数，然后才执行自己．析构由外而内，Container的析构函数首先执行自己，然后调用Component的析构函数．Adapter设计模式，queue中内含一个deque，就是一种adapter．queue实现的所有功能都是通过转调用deque的相应功能实现的，但是deque还有很多功能未被使用． Delegation 两个类之间用指针相连，称之为delegation． 1234567891011121314151617181920212223242526272829303132// handle/Body: file1为handle，file2为Body// file1 String.hpp：对外接口class StringRep;class String &#123;public: String(); String(const char *s); String(const String &amp;s); String &amp;operator=(const String &amp;s); ~String();private: StringRep *rep; // pimpl：pointer to implementation&#125;;// file2 String.cpp：字符串真正的实现在这里class StringRep &#123; friend class String; StringRep(const char *s); ~StringRep(); int count; char *rep;&#125;; 无论字符串的实现如何变化，都不影响客户端代码．String中的StringRep也可以指向不同的StringRep的实现，如可以指向StringRep的子类． 三个string共享一个字符串hello，所以共享计数n=3表示有三个String对象共享hello． 继承 继承有三种方式：public，private，protected．其中public表示is-a关系．构造由内而外．Derived的构造函数首先调用Base的default构造函数，然后才执行自己．析构由外而内．Derived的析构函数首先执行自己，然后才调用Base的析构函数． 函数的继承继承的是调用权．当一个类B以public方式继承另一个类A，那么在类A中所有的public方法在类B中也会变成public，但是当B以private方式继承类A，那么类A中所有的public方法在类B方法中变成private方法． 参考文献[1]基本聚合和组合聚合：https://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/index.html]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类的5大控制成员]]></title>
    <url>%2F2019%2F10%2F03%2F%E7%B1%BB%E7%9A%845%E5%A4%A7%E6%8E%A7%E5%88%B6%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[类的5大控制成员包括： 概念构造函数是类用来控制其对象初始化过程的函数，构造函数的任务是初始化类对象的数据成员．无聊何时只要创建类的对象，就会调用构造函数．与其他成员函数不同，构造函数没有返回类型；构造函数不能被声明为const．当我们创建一个类的const对象时，直到构造函数完成初始化过程，对象才能真正取得其常量属性． 默认构造函数当对象被默认初始化或值初始化时自动执行默认构造函数．默认初始化在以下情况下发生：值初始化在以下情况下发生： 拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数． 拷贝初始化通常由拷贝构造函数来完成．但是如果一个类有一个移动构造函数，则拷贝初始化会使用移动构造函数而非拷贝构造函数来完成．总之，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的． 合成的拷贝构造函数与默认构造函数不同, 即使类中存在其他构造函数, 编译也会自动合成一个拷贝构造函数.合成的拷贝构造函数将其参数的成员逐个拷贝到正在创建的对象中,编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中. 每个成员的类型决定了它如何拷贝:对于类类型成员,会使用其拷贝构造函数来拷贝;内置类型的成员直接拷贝. 虽然数组不能直接拷贝,但是合成拷贝构造函数会逐元素地拷贝一个数组类型的成员.如果数组元素是类类型,则使用元素的拷贝构造函数来进行拷贝. 直接初始化和拷贝初始化直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数.使用拷贝初始化则要求编译器将右侧运算对象拷贝到我们正在创建的对象中.如果必要的话还需要进行类型转换.拷贝初始化要么通过拷贝构造函数,要么通过移动构造函数完成.拷贝初始化在以下情况下发生： 当我们用=定义变量时将一个对象作为实参传递给一个引用类型的形参从一个返回类型为非引用类型的函数返回一个对象用花括号列表初始化一个数组中的元素或一个聚合类中的成员 拷贝赋值运算符赋值运算符返回一个指向其左侧运算对象的引用． 析构函数构造函数初始化对象的非static数据成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员．在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁． 移动构造函数移动赋值运算符关联如果类的设计者没有声明，那么编译器会为它声明一个拷贝构造函数，一个拷贝赋值运算符函数和一个析构函数．如果类的设计者没有声明任何构造函数，那么编译器会为类声明一个默认构造函数．所有这些版本都是public且inline．默认的拷贝构造函数的功能： 以上五个函数统称为拷贝控制操作．各个拷贝控制操作之间的关系是： 一个类如果包含指针数据成员，那么需要一个析构函数来释放动态分配的内存． 通常如果一个类需要一个析构函数，那么它也需要一个拷贝构造函数和一个拷贝赋值运算符．但需要拷贝或赋值操作时，不一定需要析构函数．如果一个类需要一个拷贝构造函数，那么它也需要一个拷贝构造函数． 实例下面实现一个string类，命名为String．首先类的声明如下： 1234567891011121314151617class String &#123;public: explicit String(const char *cstr = 0); String(const String &amp;str); String &amp;operator=(const String &amp;str); ~String(); char *get_c_str() const &#123; return m_data; &#125;private: char *m_data;&#125;; 单参数构造函数接下来我们来看构造的函数的实现．单参数构造函数有一个默认实参，所以，这个构造函数是默认构造函数．explicit关键字的存在是为了防止从char*到String的隐式转换． 123456789inline String::String(const char *cstr) &#123; if (cstr) &#123; m_data = new char[std::strlen(cstr) + 1]; strcpy(m_data, cstr); &#125; else &#123; m_data = new char[1]; // 这里分配一个长度为1的数组是为了与上面搭配 *m_data = '\0'; &#125;&#125; 在实现中，首先检查cstr是否是空指针，若是空指针，说明当前字符串是个空字符串．那么仅分配一个字节，存在字符串结束标志’\0’．否则，分配足够的空间，并将字符串指针cstr所指向的字符串拷贝到新分配的空间中． strcpy函数会拷贝整个源字符串到目的字符串中，包括结尾处的空字符’\0’ 析构函数然后我们来看析构函数．因为String类是一个class with pointer，因此需要在析构函数中销毁指向指向的对象并销毁其占用的内存． 123inline String::~String() &#123; delete[] m_data; // 销毁底层字符串并释放字符串占用的空间&#125; delete运算符调用m_data指向的对象的析构函数销毁对象，并调用operator delete([])标准库函数释放内存空间． 拷贝构造函数拷贝构造函数采用的是深拷贝．当目的String对象从源String对象中拷贝的不仅仅是指针，还需要为目的String对象分配内存空间，并拷贝源String对象字符串的内容． 1234String::String(const String &amp;str) &#123; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); &#125; 拷贝赋值运算符函数首先，拷贝赋值运算符函数的功能是将source str的内容拷贝给dest str，dest str是一个已经存在的对象，因此，它不是拷贝赋值运算符函数的local object，所以可以返回dest str的一个引用．接下来，我们需要实现最难实现的拷贝赋值运算符函数．在实现拷贝赋值运算符函数过程中，需要考虑的第一个问题是自我赋值． 第一版：检测并避免了自我赋值 123456789101112String &amp;String::operator=(const String &amp;str) &#123; // 检测自我赋值 if (this == &amp;str) &#123; return *this; &#125; //清除旧的数据，为新的数据分配空间，令m_data指向新分配的数据 delete m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this;&#125; 上面的代码尽管避免了自我赋值，却不具备异常安全性．具体而言，*m_data = new char[strlen(str.m_data) + 1]; *可能会因为内存不足等原因而出错．一旦出错，就会导致，m_data指向一块已经被释放的内存空间． 因此我们仍然需要考虑如何实现异常安全性． 第二版：防止在内存分配成功之前释放旧的内存空间 1234567String &amp;String::operator=(const String &amp;str) &#123; char *m_old = m_data; m_data = new char[strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); delete m_old; return *this;&#125; 在这一版本的代码中，我们实现了先保证新的内存空间能够分配成功，分配成功之后，再将旧的字符串拷贝到新内存中，然后再销毁旧的字符串并释放内存空间． 第三本版：copy and swap计数实现异常安全性copy和swap在于＂修改对象的副本，然后在一个不抛异常的函数中将修改后的数据和原件置换＂．首先需要定义个public member swap，负责实现两个String类型的置换，这个函数不允许抛异常． 12345// member swap:不允许抛异常void String::swap(String &amp;other) &#123; using std::swap; swap(m_data, other.m_data); // 直接交换两个指针&#125; 此后在std命名空间中全特化swap的String． 123456namespace std &#123; template&lt;&gt; void swap&lt;String&gt;(String &amp;a, String &amp;b) &#123; a.swap(b); // 调用String的public swap成员函数 &#125;&#125; 或者是定义一个non-member swap． 12345// non-member swap,调用了public member swap// 且non-member swap会先于std::swap被匹配void swap(String &amp;a, String &amp;b) &#123; a.swap(b);&#125; 在std命名空间中的全特化swap和non-member swap中都调用了public member swap来实现真正的置换过程．最后，我们可以实现拷贝赋值运算符函数的实现如下． 1234567String &amp;String::operator=(const String &amp;str) &#123; String tmp(str); using std::swap; // 令std::swap在此函数内可用 swap(*this, tmp); return *this;&#125; 测试最后为了测试，准备一个输出运算符重载的non-member函数． 12345678std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const String &amp;rhs) &#123; // 为了测试，当字符串为空时，输出empty String if (*rhs.get_c_str() == '\0') &#123; out &lt;&lt; "empty String"; &#125; out &lt;&lt; rhs.get_c_str(); return out;&#125; 测试程序如下： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include "String.h"using namespace std;int main() &#123; String s1; char p[] = "hello"; String s2(p); cout &lt;&lt; "s1:" &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; "s2:" &lt;&lt; s2 &lt;&lt; endl; char p1[] = "good"; String s3(p1); cout &lt;&lt; "s3:" &lt;&lt; s3 &lt;&lt; endl; s1 = s3; cout &lt;&lt; "s1:" &lt;&lt; s1 &lt;&lt; endl; String s4(s2); cout &lt;&lt; "s4:" &lt;&lt; s4 &lt;&lt; endl; return 0;&#125; 运行结果： 12345s1:empty Strings2:hellos3:goods1:goods4:hello]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>析构函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2F2019%2F10%2F02%2F494.Target-Sum%2F</url>
    <content type="text"><![CDATA[You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 1234567891011Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 暴力破解123456789101112131415class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; return dfs(nums, S, 0, 0); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; return dfs(nums, S, index + 1, sum + nums[index]) + dfs(nums, S, index + 1, sum - nums[index]); &#125;&#125;; 自顶向下的记忆化搜索这里会涉及到负值,如何处理呢?加上可能的最小值的负数,进行偏移. 1234567891011121314151617181920212223class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; if(nums.empty())&#123; return S == 0 ? 1 : 0; &#125; int sum = 0; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2010, -1)); return dfs(nums, S, 0, 0, res); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(index == nums.size())&#123; return sum == S ? 1 : 0; &#125; if(res[index][sum + 1000]!=-1)&#123; return res[index][sum + 1000]; &#125; int add = dfs(nums, S, index + 1, sum + nums[index], res); int sub = dfs(nums, S, index + 1, sum - nums[index], res); res[index][sum + 1000] = add + sub; return add + sub; &#125;&#125;; 自底向上 dp[i][j]表示到第i个元素,组成的和为j的方法数.dp[i][sum + nums[i]] = dp[i][sum + nums[i]] + dp[i-1][sum]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[703. Kth Largest Element in a Stream]]></title>
    <url>%2F2019%2F09%2F29%2F703.-Kth-Largest-Element-in-a-Stream%2F</url>
    <content type="text"><![CDATA[Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: 12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 Note:You may assume that nums‘ length ≥ k-1 and k ≥ 1. 解法11234567891011121314151617181920212223242526272829class KthLargest &#123;public: KthLargest(int k, vector&lt;int&gt;&amp; nums): vec(nums),kth(k) &#123; sort(vec.begin(), vec.end()); &#125; int add(int val) &#123; int i = vec.size()-1; vec.push_back(0); while(i&gt;=0 &amp;&amp; vec[i]&gt; val)&#123; vec[i+1] = vec[i]; --i; &#125; vec[i+1] = val; if(vec.size() &lt; kth)&#123; throw "no solution"; &#125; return vec[vec.size()-kth]; &#125;private: vector&lt;int&gt; vec; int kth;&#125;;/** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-&gt;add(val); */ 解法2能不能简化呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class KthLargest &#123;public: KthLargest(int k, vector&lt;int&gt;&amp; nums):kth(k) &#123; if(kth == 0)&#123; return; &#125; int size = kth &gt; nums.size() ? nums.size() : kth; for(int i=0;i&lt;size;++i)&#123; heap.push_back(nums[i]); &#125; if(heap.empty())&#123; return; &#125; bulid_tree(heap); for(int i=size;i&lt;nums.size();++i)&#123; if(nums[i] &gt; heap[0])&#123; heap[0] = nums[i]; min_heapify(0, heap); &#125; &#125; &#125; int add(int val) &#123; if(heap.size() &lt; kth)&#123; heap.push_back(val); min_heapify(0, heap); &#125; else if(val &gt; heap[0])&#123; heap[0] = val; min_heapify(0, heap); &#125; return heap[0]; &#125; static void min_heapify(int k, vector&lt;int&gt;&amp; nums)&#123; int key = nums[k]; bool heap = false; while(!heap &amp;&amp; 2 * k + 1 &lt; nums.size())&#123; int j = 2 * k + 1; if(j + 1 &lt; nums.size())&#123; if(nums[j + 1] &lt; nums[j])&#123; j = j + 1; &#125; &#125; if(nums[j] &gt;= key)&#123; heap = true; &#125;else&#123; nums[k] = nums[j]; k = j; &#125; &#125; nums[k] = key; &#125; static void bulid_tree(vector&lt;int&gt;&amp; nums)&#123; for(int i=nums.size()/2;i&gt;=0;--i)&#123; min_heapify(i, nums); &#125; &#125; private: vector&lt;int&gt; heap; int kth;&#125;;/** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj-&gt;add(val); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%A0%86%2F</url>
    <content type="text"><![CDATA[什么是堆我们面临的第一个问题是：什么是堆？ 堆可以定义为一颗二叉树，树的节点中包含键，并且满足两个条件：１．该二叉树是完全二叉树．除了最后一层，树的每一层都是满的．２．父母优势：(以最大堆为例)父节点的键大于或等于孩子节点的键 可以用数组来实现堆． 建堆，插入新元素，删除堆顶元素自底向上构造堆 从最后一个非叶节点开始，检查该节点是否满足父母优势．如果不满足，就将该节点与最大孩子节点的键交换，然后再检查新的位置．这个过程持续到被检查节点满足父母优势为止(叶子节点自动满足父母优势)．此过程从最后一个非叶节点一直持续到根节点．最后一个非叶节点：假设堆中有n个节点，则最后一个非叶节点为(n/2)向下取整．例如，n=7,最后一个非叶节点为３. 将一个堆调整为最大堆将以k为根的子树调整为一个堆的过程可以简单描述如下：查看k的孩子节点中是否存在比k大的，如果不存在说明以k为根的子树已经是一个最大堆了（这里存在一个假设：在调整以k为根的子树时，以k的左右孩子节点为根的子树都已经是堆了）．否则，交换k和孩子节点中较大的那个（无论两个孩子节点是否都满足大于k），假设此新节点为n，接下来就是调整以n为根节点的子树了．显然，这就是重复上面的过程，那么这个过程应该持续到什么时候结束呢？答案是到k已经是叶子节点或者没有孩子节点都比它小了． 非递归方式 12345678910111213141516max_heapify_iter(H[1,...,n], k) // 输入：H[1,..,n]是一个数组，表示一个完全二叉树 // k：当前要调整的节点K // 输出：以节点i为根的二叉树调整为一个堆 k = i, v = H[k] // K是当前需要检查的节点 heap = false // 状态变量，表示当前要检查的节点是否满足父母优势 while not heap and 2 * k &lt;= n // 当要检查的节点不满足父母优势且不是叶子节点 j = 2 * k if j &lt; n // 被检查节点有两个孩子节点 if H[j + 1] &gt; H[j] j = j + 1 if v &gt;= H[j] heap = true else H[k] = H[j] // 交换被检查的节点和它最大孩子节点的键 k = j // 继续检查被交换后的最大孩子节点的键 递归方式 123456789101112131415max_heapify_recur(A, i) // 输入：A[1,..,n]是一个数组，表示一个完全二叉树 // i：当前要调整的节点i // 输出：以节点i为根的二叉树调整为一个堆 l = 2 * i // 节点i的左孩子2 * i r = 2 * i + 1 // 节点i的左孩子2 * i + 1 if l &lt;= n and A[l] &gt;= A[i] largest = l else largest = i if r &lt;= n and A[r] &gt;= A[largest] largest = r if largest != i exchange(A[i], A[largest]) max_heapify(A, largest) 时间复杂度：O(lgn) 建堆非递归方式 123456HeapBottomUp(H[1,...,n]) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组H[1,...,n] // 输出：一个堆H[1,...,n] for i = [n/2] to 1 do max_heapify_iter(H, i) 递归方式 123456build_max_heap(A) // 用自底向上算法，从给定数组的元素中构造一个堆 // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个堆A[1,...,n] for i = n/2 to 1 do // n/2向下取整 max_heapify_recur(A, i) 自底向上建堆时间复杂度分析自底向上方式建堆，需要调用n/2次max_headify(将一个堆调整为最大堆)，每次调用max_heapify的时间复杂度为O(logk)，这里的k是被调整的子树中节点的总数。接下来，计算总的时间复杂度。包含n个元素的堆的高度为$$\lfloor{lgn}\rfloor$$高度为h的堆最多包含$$\lceil{\frac{n}{2^{h+1}}}\rceil$$个结点。在一个高度为h的结点上运行max_heapify的代价为O(h)，因此建堆的总的时间复杂度为：$$\sum_{h=0}^{\lfloor{lgn}\rfloor}{\lceil{\frac{n}{2^{h+1}}}\rceil} O(h)= O(n \sum_{h=0}^{\lfloor{lgn}\rfloor}\frac{h}{2^h})$$级数求和公式：$$\sum_{k=0}^{\infty}{k}{x^k} = \frac{x}{(1-x)^2}$$将x=1/2带入级数求和公式，可知：$$\sum_{k=0}^{\infty}\frac{h}{2^h} = \frac{1/2}{(1 - {1/2})^2} = 2$$因此，建堆的时间复杂度为：$$O(n \sum_{h=0}^{\lfloor{lgn}\rfloor}\frac{h}{2^h}) = O(n \sum_{h=0}^{\infty}\frac{h}{2^h}) = O(n)$$因此，可以在线性时间内，将一个无序数组构造成一个最大堆。 向已经建好的堆中插入元素向一个已经建好的堆中插入新元素，首先将新元素k插入到堆中最后一个叶子节点的后面。然后按照下面的方法把这个新元素k放到适当的位置上。首先拿k和它的父节点进行比较，如果k的键小于等于父节点的值，则算法停止（当前堆已经是个最大堆了）。否则交换这个元素的位置，并比较元素k和它的新父节点。这个过程一直持续到父节点的键值大于等于元素k的键值或者元素k没有了父节点(即元素k是根节点）。显然，插入操作需要的比较次数不会多于树的高度，即向堆中插入新元素的时间复杂度为O(lgn)。 删除堆顶元素第一步，交换根节点的元素和堆中最后一个节点的元素。第二步，堆的规模减去1。第三步，调用max_heapify，将以根节点为根的子树调整为最大堆。删除需要一次交换和一次自顶向下调整堆的过程，因此，时间复杂度取决于调整堆的时间复杂度，即为O(lgn)。 堆排序第一步，堆排序首先构造堆，为一个给定的数组构造一个堆．时间复杂度为O(n) 第二步，从堆中删除最大键，持续此动作n-1次．时间复杂度为O(nlogn) 删除最大键并调整堆的时间复杂度：O(lgn) 堆排序的时间效率是O(nlogn)，但是堆排序是原址排序，不需要任何额外的存储空间． 堆排序比快速排序运行得慢，但是比归并排序快． 12345678heap_sort(A) // 输入：一个可排序元素的数组A[1,...,n] // 输出：一个排好序的数组A heap_size = n for i = n to 2 exchange(A[i], A[1]) --heap_size; max_heapify_iter(A, 1) // 调整以节点１为根，大小为heap_size的数组为最大堆]]></content>
      <tags>
        <tag>堆数据结构</tag>
        <tag>优先队列</tag>
        <tag>最小堆，最大堆</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[subSets]]></title>
    <url>%2F2019%2F09%2F29%2FsubSets%2F</url>
    <content type="text"><![CDATA[Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 题目链接 方法一:枚举一次处理一位，循环处理每一位即可．注意，在枚举各位之前必须将数组排序，保证相等元素相邻。 比如对于题目中给的例子 [1,2,3] 来说，最开始是空集，接下来首先处理第一位1，于是就在空集上加1，为 [1]，现在我们有两个子集 [] 和 [1]．然后来处理2，我们在之前的子集基础上，每个都加个2，可以分别得到 [2]，[1, 2]，那么现在所有的子集合为 [], [1], [2], [1, 2]，用同样的方法处理3可得 [3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合． 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; res.push_back(&#123;&#125;); for(int i=0;i&lt;nums.size();++i)&#123; int size = res.size(); for(int j=0;j&lt;size;++j)&#123; res.push_back(res[j]); res.back().push_back(nums[i]); &#125; &#125; return res; &#125;&#125; 方法二: 回溯123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; subsetsCore(0, nums, tmp, res); return res; &#125; void subsetsCore(int pos, vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;tmp, vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; res.push_back(tmp); for(int i=pos;i&lt;nums.size();++i)&#123; tmp.push_back(nums[i]); subsetsCore(i+1, nums, tmp, res); tmp.pop_back(); &#125; &#125;&#125;; 依次形成以索引0处开头的所有子集、以索引1处的元素开头的所有子集，直到以最后一个元素开头的子集。 方法三: 位操作思路：为数组中所有的数分配一个状态，状态0表示这个数不在子集中出现，状态1则表示这个数在子集中出现．对于一个长度为n的数组，每个数组都有出现和不出现两种情况，所以共有2n种情况．因此，把1 - 2n-1-1转换为对应的二进制形式，再将这个二进制字符串转换成子数组即可． 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int maxVal = 1 &lt;&lt; nums.size(); for(int k=0;k&lt;maxVal;++k)&#123; vector&lt;int&gt; tmp = convertIntToSet(nums, k); res.push_back(tmp); &#125; return res; &#125; vector&lt;int&gt; convertIntToSet(vector&lt;int&gt;&amp; nums, int k)&#123; vector&lt;int&gt; sub; int index = 0; for(int i=k;i&gt;0;i&gt;&gt;=1)&#123; if((i&amp;1)==1)&#123; sub.push_back(nums[index]); &#125; ++index; &#125; return sub; &#125;&#125;; Subsets II题目链接 方法一:枚举 思路，对于数组nums: [1,2,2,3]最初，结果集res中只有空集，即res = [[]]第1轮，将元素1加入到结果集中：res = [[], [1]]第2轮，将元素2加入到结果集中：res= [[],[1], [2], [1,2]]第3轮，接下来又是元素2，如果将复制之前的每个子集，再在复制的子集中加入元素2就会出现重复。即res = [[], [1], [2], [1,2], [2], [1,2], [2, 2], [1,2,2]]，其中红色的两个集合是重复的。即我们只能在已经出现元素2的集合中加入第二个2，形成不重复的子集。也就是说，只需要在加入了索引1处的元素2的两个子集中加入索引2处的元素2。可以在第2轮确定索引1处的元素加入到了几个子集（假设为n）中。第3轮只往这n个子集（位于结果集res的末尾处）中加入重复的元素2。 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; res.push_back(&#123;&#125;); int pre = 1; for(int i=0;i&lt;nums.size();++i)&#123; int size = res.size(); // 如果上一个元素与当前元素不同，则说明可以将当前元素加入到所有子集中 if(i &amp;&amp; nums[i] != nums[i-1])&#123; pre = size; &#125; for(int j=size-pre;j&lt;size;++j)&#123; res.push_back(res[j]); res.back().push_back(nums[i]); &#125; &#125; return res; &#125;&#125;; 方法二: 回溯如何在回溯过程中消除重复元素的影响？ 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; subsetsWithDupCore(nums, res, tmp, 0); return res; &#125; void subsetsWithDupCore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int pos)&#123; res.push_back(tmp); for(int i=pos;i&lt;nums.size();++i)&#123; tmp.push_back(nums[i]); subsetsWithDupCore(nums, res, tmp, i + 1); tmp.pop_back(); while(i &lt; nums.size() -1 &amp;&amp; nums[i] == nums[i+1])&#123; ++i; &#125; &#125; &#125;&#125;; 参考文献[1] Subsets 子集合: https://www.cnblogs.com/grandyang/p/4309345.html[2] 含有重复元素的subsets子集: https://www.cnblogs.com/grandyang/p/4310964.html]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux常见文件格式]]></title>
    <url>%2F2019%2F09%2F29%2Flinux%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文档整理并记录一些ubuntu系统常用文件的格式。 /etc/passwd通常在Linux系统中，用户的关键信息被存放在系统的/etc/passwd文件中，系统的每一个合法用户账号对应于该文件中的一行记录。这行记录定义了每个用户账号的属性。 字段 含义 1 表示用户名 2 表示密码，在 /etc/passwd 文件中，如果该用户有密码，则使用x来替代，为空则表示不需要密码。为了防止密码泄露，真正的密码保存在 /etc/shadow中，但是这个文件中的密码也是经过加密后的密码。 3 表示用户的ID 4 表示用户所属组的ID 5 一些备注信息 6 用户的home目录位置 7 表示用户登录时所使用的解释器的位置，有些是nologin，表示该用户无法登录系统 /etc/shadow/etc/shadow 文件，用于存储 Linux系统中用户的密码信息，又称为“影子文件”。 /etc/passwd 文件中用x表示用户面膜，这是因为该文件允许所有用户读取，易导致用户密码泄露，因此 Linux 系统将用户的密码信息从 /etc/passwd 文件中分离出来，并单独放到了/etc/shadow文件中。/etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。同 /etc/passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下： 字段 含义 1 用户名 2 加密密码 3 最后一次修改时间 4 最小修改时间间隔 5 密码有效期 6 密码需要变更前的警告天数 7 密码过期后的宽限时间 8 账号失效时间 9 保留字段 /etc/group/ect/group 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。此文件是记录组 ID（GID）和组名相对应的文件。etc/passwd 文件中每行用户信息的第四个字段记录的是用户的初始组 ID，那么，此 GID 的组名到底是什么呢？就要从 /etc/group 文件中查找。各用户组中，还是以 “：” 作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为： 字段 含义 1 组名 2 密码 3 GID 4 该用户组中的用户列表 参考文献[1] /etc/shadow文件：http://c.biancheng.net/view/840.html]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串基础知识总结]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[有几种不同类型的字符串： c风格字符串(包括字符串字面常量和指向以空字符结尾的字符数组的指针)，string类型(类类型) c风格字符串 c风格字符串必须符合某种编码(如ASCII),并且除了字符串的末尾之外,字符串里面不能包含空字符(空字符是字符结束的标志).这些限制使得c风格字符串只能保存文本数据,而不能保存二进制数据(如图片,音频等) c风格字符串不保存自身长度,要获取一个c字符串的长度,需要遍历整个字符串,直到遇到代表字符串结尾的空字符为止,这个操作的时间复杂度为O(n)(n是字符串长度). c字符串容易造成缓冲区溢出 如使用strcat函数将src字符串中的内容拼接到字符串的末尾时, 1char *strcat(char* dest, const char* src) 由于c字符串不记录自身的长度,所以strcat假定用户在执行这个函数时,已经为dest分配了足够多的内存,可以容纳src字符串中的所有内容,但是万一这个假设不成立就会造成缓冲区溢出. c字符串修改字符串长度时需要进行内存重分配;内存重分配涉及复杂的算法,而且可能需要执行系统调用,通常来说比较耗时. 字符串,字符数组相关API c标准库string函数, 共有4个函数 strlen(p), strcmp(p1, p2), strcat(p1, p2), strcpy(p1, p2) 传入此类函数的指针必须指向以空字符结尾的数组不能使用strlen函数求”使用列表初始化的字符数组的长度，因此列表初始化的字符数组不以空字符结尾 strlen计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 strcpy(char* dest, const char*src) 把src所指向的字符串复制到dest，包括结尾处的空字符 如果目标数组dest的内存空间比src的内存空间小，会出现缓冲区溢出 strcmp(const char* str1, const char* str2) 依次比较str1和str2中的一对字符，直到str1或者str2到达字符串结尾或者被比较的一对字符不等． 当两个字符串相等时返回0. http://www.cplusplus.com/reference/cstring/strcmp/ 123456789101112void testCharArray3() &#123; cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // 允许使用以空字符结尾的字符数组类初始化string对象或为string对象赋值 string s("danam"); cout &lt;&lt; "s:" &lt;&lt; s &lt;&lt; " s.size():" &lt;&lt; s.size() &lt;&lt; endl; char c[] = "nice"; cout &lt;&lt; "strlen(c): " &lt;&lt; strlen(c) &lt;&lt; " c:" &lt;&lt; c &lt;&lt; endl; string s1(c); cout &lt;&lt; "s1.size():" &lt;&lt; s1.size() &lt;&lt; " s1:" &lt;&lt; s1 &lt;&lt; endl;&#125; 运行结果 1234strlen("danam"): 5s:danam s.size():5strlen(c): 4 c:nices1.size():4 s1:nice memset和memstcpy fill memset 头文件string.h（c++头文件cstring） memset可以对数组中每个元素赋以相同的值．但是因为memset按字节赋值，即对每个字节赋相同的值，一般只用来填充char型数组（char类型占一个字节），如果填充int数组最好只在要对数组赋值０或-1时使用memset． memset函数的格式为：memset(数组名，值，sizeof(数组名)) 与fill相比，memset执行速度较快． fill 头文件algorithm fill()函数可以将数组或者容器中的某一段区间赋为某个相同的值．和memset不同，这里的赋值可以是数组类型对应范围的任意值． fill函数格式： fill(arr, arr+n, 0) (其中arr为指向数组首元素的指针，arr+n为指向数组尾元素的指针, 0为要赋的值) fill(vec.begin(), vec.end(), 0) (vec.begin()和vec.end()为迭代器表示的范围)]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组和字符指针]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是数组?数组是一组类型相同元素的容器.数组中存放的对象没有名字,必须通过位置来访问.数组的大小确定不变, 一旦数组定义完成,不能再向数组中添加元素. 数组基本概念数组是一种复合类型.数组的声明形如a[d], 其中a是数组的名字,d是数组的维度.维度说明了数组中元素的个数,因此必须大于0. 数组中元素的个数也属于数组类型的一部分,编译时数组的维度必须是已知的. 适用所有数组类型 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。当对数组名称使用decltype关键字时得到的是数组对象类型。 对数组执行下标运算其实是对指向数组元素的指针执行下标运算 内置的下标运算符不是无符号数,标准库类型如vector和string限定使用的下标必须是无符号数 因为数组本身是对象,可以定义数组的指针和数组的引用 适用于字符数组 当使用字符串常量对字符数组进行初始化时, 字符串数组最后一位会被加上一个’\0’空字符但是使用strlen()计算该数组的长度时,该字符串末尾的空字符不计算在内 对字符数组进行列表初始化时,字符数组末尾没有空字符; 但是由于strlen()函数时是使用空字符来判断字符串结束的, 无法对这样的字符数组使用strlen()求长度 代码示例字符数组初始化和求长度 字符数组初始化有两种方式,列表初始化和字符串常量初始化 字符串常量初始化时,字符串常量末尾的空字符也会拷贝到字符数组中去 1234567891011121314151617void testCharArray() &#123; char a1[] = "danam"; // 计算c风格字符串的长度时,c风格字符串末尾的空字符不计算在内 cout &lt;&lt; "strlen(\"danam\"): " &lt;&lt; strlen("danam") &lt;&lt; endl; // a1的长度为6字节,字符串字面值的末尾是一个空字符,这个空字符也会像其他字符一样拷贝到字符数组中去 cout &lt;&lt; "a1:" &lt;&lt; a1 &lt;&lt; " sizeof(a1): " &lt;&lt; sizeof(a1) &lt;&lt; " strlen(a1): " &lt;&lt; strlen(a1) &lt;&lt; endl; //a1:danam sizeof(a1): 6 strlen(a1): 5 // 对字符数组进行列表初始化,没有空字符 char a2[] = &#123;'a', 'b', 'c'&#125;; cout &lt;&lt; "a2: " &lt;&lt; a2 &lt;&lt; " sizeof(a2): " &lt;&lt; sizeof(a2) &lt;&lt; endl; // a2的长度为3字节;无法对a2使用strlen函数 // a2: abcdanam sizeof(a2): 3 // 因为a2末尾没有空字符作为结束标记，所以，输出时一直输出到遇到a1末尾的空字符才结束&#125; 运行结果 123strlen("danam"): 5a1:danam sizeof(a1): 6 strlen(a1): 5a2: abcdanam sizeof(a2): 3 数组名和指针,迭代器 数组名通常会自动转换为指向数组首元素的指针 在表达式decltype(arr)时,不会发生自动转换,decltype(arr)的返回类型是一个数组类型,其元素类型和维度都与数组arr相同 1234567891011void testCharArray1() &#123; //===============数组名和指针================= int iarr[] = &#123;1, 2, 3, 4, 5&#125;; // ia是一个指针,在这里使用数组类型对象iarr时,编译器将其替换为一个指向数组首元素的指针 auto ia(iarr); ia = &amp;iarr[1]; // decltype(ia)是一个含有5个整形元素的数组对象,因此iarr2也是一个含有5个元素的数组 decltype(iarr) iarr2 = &#123;22, 33, 444, 55, 99&#125;; iarr2[2] = 1882;&#125; 运行结果 1nice to meet you alice 指针运算 对数组执行下标运算其实是对指向数组元素的指针执行下标运算.标准库类型使用的下标类型必须是无符号类型,内置的下标运算可以是带符号类型 可以从一个指针加上或减去一个整数值,结果仍是指针 指向同一个数组中元素(包括尾元素)的指针可以相减,两个指针相减的结果是一种名为ptrdiff_t的标准库类型.ptrdiff_t类型是一种带符号类型 123456789101112131415161718192021void testCharArray3() &#123; //=======================指针运算===================== string sarr[5] = &#123;"good", "day", "you", "know", "me"&#125;; // sarr[2]是一个使用了数组名字的表达式,对数组执行下标运算其实是对指向数组元素的指针执行下标运算 string s1 = sarr[2]; //sarr转换为指向数组首元素的指针,sarr[2]得到(sarr+2)所指向的元素 string *p = sarr; //sarr转换为指向数组首元素的指针 string s2 = *(p + 2); //等价于sarr[2] cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; s2 = p[3]; cout &lt;&lt; "s2: " &lt;&lt; s2 &lt;&lt; endl; //=======只要指针指向的是数组中的元素(或者数组中尾元素的下一位置),都可以执行下标运算 //内置的下标运算符使用的不是无符号数,而标准库类型如vector和string限定使用的下标必须是无符号类型 string *p1 = &amp;sarr[2]; string s3 = p1[2]; string s4 = p1[-2]; cout &lt;&lt; "s3: " &lt;&lt; s3 &lt;&lt; endl; cout &lt;&lt; "s4: " &lt;&lt; s4 &lt;&lt; endl;&#125; 运行结果 12345s1: yous2: yous2: knows3: mes4: good 指针和迭代器1234567891011121314151617181920void testCharArray2() &#123; //================指针也是迭代器======================== string sarr[5] = &#123;"nice", "to", "meet", "you", "alice"&#125;; //指针e指向sarr尾元素的下一位置的指针,该位置并不存在,因此不能对该指针进行解引用和递增操作 string *e = &amp;sarr[5]; for (string *b = sarr; b != e; b++) &#123; cout &lt;&lt; *b &lt;&lt; " "; &#125; cout &lt;&lt; endl; //=====================标准库begin和end函数====================== int ia1[] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int *beg = begin(ia1); // 指向ia1首元素的指针 int *last = end(ia1); // 指向ia1尾元素的下一位置的指针 while (beg != last) &#123; cout &lt;&lt; *beg &lt;&lt; " "; ++beg; &#125; cout &lt;&lt; endl;&#125; 运行结果: 10 1 2 3 4 5 6 7 8 9]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[普通的二叉查找树(二叉搜索树)依赖于输入数据的随机性。如果输出的是预先排序的数据，就会导致单支树的出现，这时效率会急剧下降。 AVL树是一种平衡二叉查找树，正是为了应对这种不平衡状态的出现。AVL树要求任意节点的左右两棵子树的高度相差最多是1。因此，AVL树能够保证整棵树的深度为O(logN)，其中N是树中节点总数。 红黑树是一种二叉查找树，但在每个节点都颜色，要么是红色要么是黑色(非红即黑)。通过任何一条从根到叶子节点的路径上黑色节点的个数必须相同这一限制条件，红黑树确保没有一条路径会比其他路径长出两倍。 与AVL树相比，红黑树是一种弱平衡二叉查找树，可能会产生不平衡状态，但是它的旋转次数少，所以，对于搜索、插入、删除操作较多的情况，通常使用红黑树。AVL树是高度平衡的，频繁的插入和删除会引起频繁的rebalance，导致效率下降；红黑树是弱平衡的，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找、插入、删除等方面的性能都是O(logN)，且性能稳定。 RB-tree必须满足1.每个节点不是红色就是黑色2.根节点为黑色3.如果节点为红色，其子节点必须为黑色4.任一节点到NULL(树尾端)的任何路径，所含之黑节点数必须相同根据规则4，新增节点必须为红色，根据规则3，新增节点的父节点必须为黑色。当新节点根据二叉搜索树的规则到达其插入点，却未能符合上述条件时，就必须调整颜色并旋转树形。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[unix 高级环境编程系列1]]></title>
    <url>%2F2019%2F09%2F27%2Funix-%E9%AB%98%E7%BA%A7%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[此文档主要记录学习过程中出现的一些问题． 环境配置学习unix高级环境编程这本书时，发现#include”apue.h”报错，在网上查找后发现这是作者自己写的一个包，需要自己手动添加到/usr/include目录下，所以从网上找了一个教程配置了下，成功配好了环境．具体过程不赘述了，直接参考的参考文献中的第二条链接． 运行程序过程中出现的错误报错信息： 12345gcc main.cpp -o th2 -lpthread/tmp/ccdz0db3.o：在函数‘__static_initialization_and_destruction_0(int, int)’中：main.cpp:(.text+0x186)：对‘std::ios_base::Init::Init()’未定义的引用main.cpp:(.text+0x19b)：对‘std::ios_base::Init::~Init()’未定义的引用collect2: error: ld returned 1 exit status 报错原因：使用了c编译器来编译c++文件解法办法：使用命令[g++ main.cpp -o th2 -lpthread]来编译https://blog.csdn.net/u010758410/article/details/78704003 报错信息 1234g++ thread_exit_test.cpp -o exit -lpthreadthread_exit_test.cpp: In function ‘int main()’:thread_exit_test.cpp:47:43: error: lvalue required as unary ‘&amp;’ operand err = pthread_join(tid1, &amp;((void *) fp)); 报错原因：C语言编译器允许隐含性的将一个通用指针转换为任意类型的指针，而C++不允许的。解法方法：https://blog.csdn.net/alpelious/article/details/53486547 参考文献[1] http://www.apuebook.com/[2] https://www.jianshu.com/p/c51a4127e9e6]]></content>
      <categories>
        <category>unix 高级环境编程</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内置指针]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%86%85%E7%BD%AE%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[什么是指针?指针是一种特殊的变量.它的值是一个对象的地址,也称指针指向该对象.对指针进行解引用可以获取该对象.指针本身是一个对象,可以赋值和拷贝. 指针中保存着它指向的对象的地址.直接输出指针的内容即指针指向的对象的地址.对指针进行解引用得到指针指向的对象 二级指针中保存一个指针的地址, 这个被指向的指针中才真正保存着对象的地址.直接输出指针得到指针指向的一级指针的地址.对二级指针进行解引用得到一级指针指向的最终对象的地址(即一级指针的值).对一级指针进行解引用,得到最终对象 关于指针有一些很容易混淆的地方,下面举几个例子辨析一下. 示例1 1234567int a = 10;int *p = &amp;a;int **pp = &amp;p; // pp是指向指针的指针，它指向指针p。解引用后是指针p。cout&lt;&lt;"pp:"&lt;&lt;(pp)&lt;&lt;" &amp;p"&lt;&lt;(&amp;p)&lt;&lt;endl; // pp是指向指针变量p的指针，所以，pp中存放着整形指针变量p的地址cout&lt;&lt;"*pp:"&lt;&lt;(*pp)&lt;&lt;" p"&lt;&lt;(p)&lt;&lt;endl; // pp是指向指针变量p的指针，*pp解引用pp会得到整形指针变量p，而p的值是一个整形变量a的地址cout&lt;&lt;"p:"&lt;&lt;p&lt;&lt;" &amp;a:"&lt;&lt;(&amp;a)&lt;&lt;endl; // p是指向整形变量a的指针，所以，p中存放着整形变量a的地址cout&lt;&lt;"*p:"&lt;&lt;p&lt;&lt;" a:"&lt;&lt;(a)&lt;&lt;endl; // p是指向整形变量a的指针。*p解引用整形指针p会得到一个整形数 运行结果 1234pp:0x7fff5ce9bf48 &amp;p0x7fff5ce9bf48*pp:0x7fff5ce9bf44 p0x7fff5ce9bf44p:0x7fff5ce9bf44 &amp;a:0x7fff5ce9bf44*p:0x7fff5ce9bf44 a:10 示例2 123456789101112131415161718192021int a[5] = &#123;1, 2, 3, 4, 5&#125;; int *p, **k; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *p:" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(p++):" &lt;&lt; *(p++) &lt;&lt; " "; cout &lt;&lt; "after p++" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; cout &lt;&lt; "=============================" &lt;&lt; endl; p = a; k = &amp;p; cout &lt;&lt; "a:" &lt;&lt; a &lt;&lt; " *a:" &lt;&lt; *a &lt;&lt; endl; cout &lt;&lt; "p:" &lt;&lt; p &lt;&lt; " *(++p):" &lt;&lt; *(++p) &lt;&lt; " "; cout &lt;&lt; "after ++p" &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; "k:" &lt;&lt; k &lt;&lt; " *k:" &lt;&lt; *k &lt;&lt; " **k:" &lt;&lt; **k &lt;&lt; endl; 运行结果 1234567891011a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *p:1k:0x7ffcd38cc920 *k:0x7ffcd38cc930 **k:1=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(p++):1 after p++0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2=============================a:0x7ffcd38cc930 *a:1p:0x7ffcd38cc930 *(++p):2 after ++p0x7ffcd38cc934k:0x7ffcd38cc920 *k:0x7ffcd38cc934 **k:2 可知, a是数组的名字,也是指向数组首元素的指针.p=a将指针p指向数组首元素.因此p的值是数组首元素的地址. p是数组首元素的值.\*k表明k是指向指向指针的指针, k指向指针p,因此,k中保存这指针p的地址,*k是指针p的值,也就是指针指向的对象地址,这里就是数组a首元素的地址.**k就是*(p)就是指针p指向的对象的值.]]></content>
      <categories>
        <category>指针</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令]]></title>
    <url>%2F2019%2F09%2F27%2Fmysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文档整理并记录常用的mysql命令． 查看数据表的结构：show columns from tutor_tbl; 主键：每张数据表只存在一个主键；主键保证记录的唯一性；主键自动为NOT NULL． 约束约束是为了保证数据的完整性和一致性．约束分为表级约束和列级约束．只与单个字段相关的约束称为列级约束，与多个字段相关的约束称为表级约束．约束类型包括：非空约束(NOT NULL)主键约束(PRIMARY KEY)唯一约束(UNIQUE KEY)默认约束(DEFAULT KEY)外键约束(FOREIGN KEY) 外键约束的要求foreign key１．子表和父表必须使用相同的存储引擎，而且禁止使用临时表．子表指的是具有外键列的表，子表所参照的表为父表．２．数据表的存储引擎只能为InnoDB．３．外键列和参照列必须具有相似的数据类型．一个表的外键可以为控制，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值． 创建表时添加外键约束： 1create table users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid SMALLINT, FOREIGN KEY(pid) REFERENCES provinces(id));]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[move对效率的影响]]></title>
    <url>%2F2019%2F09%2F27%2Fmove%E5%AF%B9%E6%95%88%E7%8E%87%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[下面自己实现了字符串类，命名为String．然后分为类实现移动构造函数(mctor)和移动赋值运算符函数(masgn)．并且对比在该类有mctor和masgn与没有这两个函数时的效率差异． 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222//// Created by xixi2 on 19-9-15.//#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/** * string的实现可以有两种方法： * 第一种是以特定字符为结束符 * 第二种是包含长度 *//** * class with pointer members */class String &#123;// friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const String &amp;rhs);public: static size_t dctor; // 累计默认构造函数调用次数 static size_t ctor; // 累计ctor调用次数 static size_t cctor; // 累计copy-ctor调用次数 static size_t casgn; // 累计copy-asgn调用次数 static size_t mctor; // 累计move-cotr调用次数 static size_t masgn; // 累计move-asgn调用次数 static size_t dtor; // 累计析构函数调用次数 String() : _data(nullptr), _len(0) &#123; ++dctor; &#125; explicit String(const char *p); String(const String &amp;str); String(String &amp;&amp;str) noexcept; String &amp;operator=(const String &amp;str); String &amp;operator=(String &amp;&amp;str) noexcept; // 移动构造函数 ~String(); char *get_c_str() const &#123; return _data; &#125; // 为了实现异常安全 // member swap:不允许抛异常 void swap(String &amp;other); // 为了能够放到特殊容器，如map中 bool operator&lt;(const String &amp;rhs) const; bool operator==(const String &amp;rhs) const;private: char *_data; size_t _len; void _init_data(const char *s) &#123; _data = new char[_len + 1]; if (s) &#123; memcpy(_data, s, _len); &#125; _data[_len] = '\0'; &#125;&#125;;// 静态数据成员需要在类外初始化size_t String::dctor = 0; // 累计默认构造函数调用次数size_t String::ctor = 0; // 累计ctor调用次数size_t String::cctor = 0; // 累计copy-ctor调用次数size_t String::casgn = 0; // 累计copy-asgn调用次数size_t String::mctor = 0; // 累计move-cotr调用次数size_t String::masgn = 0; // 累计move-asgn调用次数size_t String::dtor = 0;String::String(const char *p) : _len(strlen(p)) &#123; // 这里p没有默认值nullptr，不需要判断p是否为空 ++ctor; _init_data(_data);&#125;// 这里为什么不直接在初始化列表中调用_init_data()函数:是因为形式不对吗String::String(const String &amp;str) : _len(str._len) &#123; ++cctor; _init_data(str._data);&#125;// copy assignmentString &amp;String::operator=(const String &amp;str) &#123; ++casgn; if (this == &amp;str) &#123; // 检测自我赋值 if (_data) &#123; delete _data; &#125; _len = str._len; _init_data(str._data); &#125; return *this;&#125;// 移动构造函数String::String(String &amp;&amp;str) noexcept : _len(str._len), _data(str._data) &#123; ++mctor; // 让移动源对象处于可析构且有效的状态 str._len = 0; str._data = nullptr;&#125;String &amp;String::operator=(String &amp;&amp;str) noexcept &#123; ++masgn; // 如果对右值引用取地址，那么这里是否需要考虑自我赋值问题? // str是个变量，是左值，但是它的类型是右值引用类型，即它表示的是一个临时对象 if (this == &amp;str) &#123; if (_data) &#123; delete _data; &#125; _len = str._len; _data = str._data; str._len = 0; str._data = nullptr; &#125; return *this;&#125;String::~String() &#123; ++ctor; if (_data) &#123; delete _data; &#125;&#125;bool String::operator&lt;(const String &amp;rhs) const &#123; return string(this-&gt;_data) &lt; string(rhs._data);&#125;bool String::operator==(const String &amp;rhs) const &#123; return string(_data) == string(rhs._data);&#125;std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const String &amp;rhs) &#123; // 为了测试，当字符串为空时，输出empty String if (*rhs.get_c_str() == '\0') &#123; out &lt;&lt; "empty String"; &#125; out &lt;&lt; rhs.get_c_str(); return out;&#125;namespace std &#123; // 特例化模板 template&lt;&gt; struct hash&lt;String&gt; &#123; size_t operator()(const String &amp;s) const noexcept &#123; return hash&lt;string&gt;()(string(s.get_c_str())); &#125; &#125;;&#125;template&lt;typename T&gt;void output_static_data(const T &amp;myStr) &#123; cout &lt;&lt; "typeid(myStr).name(): " &lt;&lt; typeid(myStr).name() &lt;&lt; "--" &lt;&lt; endl; cout &lt;&lt; "cctor=" &lt;&lt; T::cctor &lt;&lt; " mctor=" &lt;&lt; T::mctor &lt;&lt; " casgn=" &lt;&lt; T::casgn &lt;&lt; " masgn=" &lt;&lt; T::masgn &lt;&lt; " dtor=" &lt;&lt; T::dtor &lt;&lt; " ctor=" &lt;&lt; T::ctor &lt;&lt; " dctor=" &lt;&lt; T::dctor &lt;&lt; endl;&#125;template&lt;typename M&gt;void test_moveable(M c1, long &amp;value) &#123; char buf[10]; typedef typename iterator_traits&lt;typename M::iterator&gt;::value_type v1type; clock_t start = clock(); for (long i = 0; i &lt; value; ++i) &#123; snprintf(buf, 10, "%d", rand() + 1); // 随机数，放进buf auto ite = c1.end(); // 定位尾端 // vltype(buf)是临时对象，调用的是移动构造函数 c1.insert(ite, v1type(buf)); &#125; cout &lt;&lt; "construction, milli-seconds: " &lt;&lt; (clock() - start) &lt;&lt; endl; cout &lt;&lt; "size()=" &lt;&lt; c1.size() &lt;&lt; endl; output_static_data(*(c1.begin())); // 调用拷贝构造函数+ cout &lt;&lt; endl; start = clock(); M c11(c1); cout &lt;&lt; "container copy, milli-seconds: " &lt;&lt; (clock() - start) &lt;&lt; endl; start = clock(); M c12(std::move(c1)); cout &lt;&lt; "container move, milli-seconds: " &lt;&lt; (clock() - start) &lt;&lt; endl; start = clock(); c11.swap(c12); cout &lt;&lt; "container swap, milli-seconds: " &lt;&lt; (clock() - start) &lt;&lt; endl;&#125; 运行结果与效率比较vector12345678910void test_vector() &#123; long value = 3000000;// value = 10; test_moveable(vector&lt;String&gt;(), value);&#125;int main() &#123; test1(); return 0;&#125; 对于vector,有mctor和masgn的情况下的运行结果(时间单位毫秒) 12345678construction, milli-seconds: 709342size()=3000000typeid(myStr).name(): 6String--cctor=0 mctor=7194303 casgn=0 masgn=0 dtor=7194303 ctor=3000000 dctor=0container copy, milli-seconds: 171571container move, milli-seconds: 1container swap, milli-seconds: 0 调用了7194303次移动构造函数．之所以这里的调用移动构造函数次数多于元素个数是因为vector在插入过程，一旦内存不足，需要扩容，而扩容的过程是分配一块新的内存，然后将旧的元素搬到新的内存中，再释放新的内存． 没有这两个函数时的运行结果 12345678construction, milli-seconds: 912494size()=3000000typeid(myStr).name(): 6String--cctor=7194303 mctor=0 casgn=0 masgn=0 dtor=7194303 ctor=3000000 dctor=0container copy, milli-seconds: 169270container move, milli-seconds: 1container swap, milli-seconds: 1 调用的是拷贝构造函数． list12345void test_list() &#123; long value = 3000000;// value = 10; test_moveable(list&lt;String&gt;(), value);&#125; 运行结果 有mctor和masgn的情况下 12345678construction, milli-seconds: 771100size()=3000000typeid(myStr).name(): 6String--cctor=0 mctor=3000000 casgn=0 masgn=0 dtor=3000000 ctor=3000000 dctor=0container copy, milli-seconds: 453080container move, milli-seconds: 16container swap, milli-seconds: 1 没有mctor和masgn的情况下 12345678construction, milli-seconds: 837069size()=3000000typeid(myStr).name(): 6String--cctor=3000000 mctor=0 casgn=0 masgn=0 dtor=3000000 ctor=3000000 dctor=0container copy, milli-seconds: 433835container move, milli-seconds: 1container swap, milli-seconds: 1 对于list，有无移动构造函数，没有特别大的影响． deque12345void test_deque() &#123; long value = 3000000;// value = 10; test_moveable(deque&lt;String&gt;(), value);&#125; 运行结果 有mctor和masgn的情况下 12345678construction, milli-seconds: 621955size()=3000000typeid(myStr).name(): 6String--cctor=0 mctor=3000000 casgn=0 masgn=0 dtor=3000000 ctor=3000000 dctor=0container copy, milli-seconds: 201950container move, milli-seconds: 17container swap, milli-seconds: 1 没有mctor和masgn的情况下 12345678construction, milli-seconds: 697399size()=3000000typeid(myStr).name(): 6String--cctor=3000000 mctor=0 casgn=0 masgn=0 dtor=3000000 ctor=3000000 dctor=0container copy, milli-seconds: 200969container move, milli-seconds: 18container swap, milli-seconds: 2 对于deque，在尾端插入的情况，影响同样不大，但是如果在中间位置输入，则会影响较大．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[c++2.0新特性]]></title>
    <url>%2F2019%2F09%2F27%2Fc%2B%2B11%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[此文档整理c++11中新特性． 语言： Variadic Templates move Semantics auto auto和decltype的区别与联系 range base for Initializer list Lambdas type_traits Unordered Containers forward_list array explicit tuple Con-currency RegEx Initializer list1234int values[]&#123;1,2,3&#125;;vector&lt;int&gt; v&#123;2,3,4,5&#125;;vector&lt;string&gt;cities&#123;"hello","hi"&#125;;complext&lt;double&gt; c&#123;4.0, 3.0&#125;; 当编译器看到{t1,t2,…,tn}便做出一个initializer_list,它关联至一个array&lt;T,n&gt;．调用函数（如ctor)时该array内的元素可被编译器分解逐一传给函数．但是，若函数的参数是initializer_list&lt;T&gt;，调用者却不能给予数个T参数然后以为它们会被自动转为一个initializer_list&lt;T&gt;传入． 对于vector&lt;string&gt;cities{“hello”,”hi”}; {“hello”,”hi”}形成了一个initializer_list&lt;string&gt;，背后有个array&lt;string,2&gt;，调用vector&lt;string&gt; ctor时编译器找到一个vector&lt;string&gt; ctor接受initializer_list&lt;string&gt;．所有容器都有这样的ctor． complext&lt;double&gt; c{4.0, 3.0}; 这形成一个initializer_list&lt;string&gt;，背后有个array&lt;double,2&gt;．调用complext&lt;double&gt; ctor时该array内的2个元素被分解传给ctor．因为complex&lt;double&gt;并无任何ctor接受initializer_list． initializer_list的使用在函数中使用initializer_list传递不定个参数 12345678910void print(initializer_list&lt;int&gt; vals) &#123; for (auto p = vals.begin(); p != vals.end(); ++p) &#123; cout &lt;&lt; *p &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void test() &#123; print(&#123;12, 3, 5, 7, 13, 17&#125;);&#125; 在类中使用initializer_list 12345678910111213141516171819202122class P &#123;public: P(int a, int b) &#123; cout &lt;&lt; "P(int, int): a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; P(initializer_list&lt;int&gt; initlist) &#123; cout &lt;&lt; "P(initializer_list&lt;int&gt;), values="; for (auto i:initlist) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;;void test1() &#123; // 若同时存在两个构造函数，如上 P p(77, 5); // 调用构造函数 P(int, int): a=77 b=5 P q&#123;77, 5&#125;; // 调用构造函数 P(initializer_list&lt;int&gt;), values=77 5 P r&#123;77, 5, 42&#125;; // P(initializer_list&lt;int&gt;), values=77 5 42 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125; 123456789101112131415void test2() &#123; // 若仅存在构造函数P(int, int) P p(77, 5); // 调用构造函数 P(int, int): a=77 b=5 P q&#123;77, 5&#125;; // 调用构造函数 P(initializer_list&lt;int&gt;), values=77 5 // P r&#123;77, 5, 42&#125;; // 无法使用这种方式创建对象 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125;void test3() &#123; // 若仅存在构造函数P(initializer_list&lt;int&gt; initlist) // P p(77, 5); // 无法使用这种方式创建对象 P q&#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5 P r&#123;77, 5, 42&#125;; // P(initializer_list&lt;int&gt;), values=77 5 42 P s = &#123;77, 5&#125;; // P(initializer_list&lt;int&gt;), values=77 5&#125; 在标准库容器和算法中使用initializer_list 1234567891011121314151617vector&lt;int&gt; v1&#123;11, 22, 454, 33&#125;;vector&lt;int&gt; v2(&#123;11, 22, 454, 33&#125;);for (auto i:v2) &#123; cout &lt;&lt; i &lt;&lt; " ";&#125;cout &lt;&lt; endl;vector&lt;int&gt; v3&#123;1, 2, 3&#125;;v3.insert(v3.begin() + 1, &#123;11, 22, 33, 55&#125;);for (auto i:v3) &#123; cout &lt;&lt; i &lt;&lt; " ";&#125;cout &lt;&lt; endl;cout &lt;&lt; max(&#123;string("hello"), string("good"), string("stacy"), string("nice")&#125;) &lt;&lt; endl;cout &lt;&lt; min(&#123;string("hello"), string("good"), string("stacy"), string("nice")&#125;) &lt;&lt; endl;cout &lt;&lt; max(&#123;11, 24, 25, 44, 10&#125;) &lt;&lt; endl; initializer_list的实现1234567891011121314151617181920212223242526272829303132template&lt;class _E&gt; class _initializer_list &#123; public: typedef _E value_type; typedef const _E &amp;reference; typedef const _E &amp;const_reference; typedef size_t size_type; typedef const _E *iterator; typedef const _E *const_iterator; private: iterator _M_array; // array的头 size_type _M_len; // array的长度 // 编译器实现准备好一个array,并把array的首地址和长度记录下来 constexpr _initializer_list(const_iterator _a, size_type _l) : _M_array(_a), _M_len(_l) &#123;&#125; public: constexpr _initializer_list() noexcept : _M_array(0), _M_len(0) &#123;&#125; constexpr size_type size() const noexcept &#123; return _M_len; &#125; constexpr const_iterator begin() const noexcept &#123; return _M_array; &#125; constexpr const_iterator end() const noexcept &#123; return begin() + _M_len; &#125; &#125;; explicit对于仅有单一实参（也可能是有n(n&gt;=2)个参数，但是n-1个参数都有默认实参）的构造函数，指定expliciit表示不允许隐式转换． 对于多个实参的构造函数，指定explicit表示不允许进行隐式转换．如果没有指定explicit，那么对于多个实参的构造函数也可以进行隐式转换． 123456789101112class P &#123; public: P(int a, int b, int c) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; " c=" &lt;&lt; c &lt;&lt; endl; &#125;&#125;;void test1() &#123; // 多实参的隐式转换 P p = &#123;1, 2, 3&#125;; //&#125; 运行结果： 1a=1 b=2 c=3 Alias Template(template typedef)与模板模板参数相关． 12345template&lt;typename T&gt;using Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;; // 为vector指定别名// 使用别名Vec&lt;int&gt; coll; type Alias12345678typedef void(*func)(int, int); // func是一个返回值为void,两个int参数的函数指针类型// 下面是等价写法using func = void (*)(int,int);// 给函数指针赋值void example(int,int)&#123;&#125;func fn = example; usingusing的三种用法 using-directives 123using namespace std;using std::cout; using-declarations 12345class Derived:public Base&#123; protected: using Base::_M_alloc; using Base::_M_deallocate;&#125; type alias and alias template 1234template&lt;typename&gt;struct Container&#123; using value_type = T;&#125; 12345// type alias used to hide a template parametertemplate&lt;class CharT&gt; using mystring = std::basic_string&lt;CharT,std::char_traits&lt;CharT&gt;&gt;;// mystring是模板，mystring&lt;char&gt;才是类型mystring&lt;char&gt; str; noexceptfinalfinal有两种用法： 修饰class，禁止类被继承 修饰virtual function，禁止virtual function被重写 decltypedecltype可以找出一个表达式的类型．decltype有三种用法： 声明一个type作为返回类型 1234template&lt;typename T1, typename T2&gt;auto add(T1 x, T2 y) -&gt; decltype(x + y) &#123; return x + y;&#125; 在metaprogramming中使用 取一个表达式的类型 1234567891011121314template&lt;typename T&gt;void test_decltype(T obj) &#123; typedef typename decltype(obj)::iterator iType; // 相当于typedef typename T::iterator iType iType it = obj.begin(); if (it != obj.end()) &#123; cout &lt;&lt; "not empty container" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "empty container" &lt;&lt; endl; &#125; decltype(obj) anoObj(obj); cout &lt;&lt; "anoObj.size(): " &lt;&lt; anoObj.size() &lt;&lt; endl; cout &lt;&lt; endl;&#125; 面对lambda，往往只有object,没有type，要获得其类型就需要借助于decltype． 12345678910111213141516171819class Person &#123; public: Person(string _firstName, string _lastName) : fname(_firstName), lname(_lastName)&#123;&#125; string firstName() const &#123; return fname; &#125; string lastName() const &#123; return lname; &#125; private: string fname; string lname;&#125;;auto comp = [](const Person &amp;p1, const Person &amp;p2) &#123; return p1.lastName() &lt; p2.lastName() || (p1.lastName() == p2.lastName() &amp;&amp; p1.firstName() &lt; p2.firstName(); &#125;; set&lt;Person, decltype(comp)&gt; coll(comp); lambda]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>c++11新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++牛客网刷题总结]]></title>
    <url>%2F2019%2F09%2F27%2FC%2B%2B%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[字符串系列]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bind与函数适配器]]></title>
    <url>%2F2019%2F09%2F27%2Fbind%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[bind是从c++11开始出现的新型适配器]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[traits]]></title>
    <url>%2F2019%2F09%2F27%2Ftraits%2F</url>
    <content type="text"><![CDATA[type_traits和iterator_traits is_void的实现is_class，is_union, is_enum, is_pod的实现]]></content>
      <categories>
        <category>STL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Palindromic Substrings系列]]></title>
    <url>%2F2019%2F09%2F27%2FPalindromic-Substrings%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[Palindromic Substrings系列 647 Palindromic Substrings5 Longest Palindromic Substring516. Longest Palindromic Subsequence647. Palindromic Substrings 647. Palindromic SubstringsMedium Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: 123Input: &quot;abc&quot;Output: 3Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. Example 2: 123Input: &quot;aaa&quot;Output: 6Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. Note: The input string length won’t exceed 1000. 解法1动态规划： 时间复杂度：O(n2) 空间复杂度：O(n2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[const关键字的妙用]]></title>
    <url>%2F2019%2F09%2F27%2Fconst%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%A6%99%E7%94%A8%2F</url>
    <content type="text"><![CDATA[const可用于修饰变量，成员函数等待． 用于成员函数的const规则一 const object(data members不得变动) non-const object(data members可变动) const member functions(保证不更改data members) yes yes non-const member functions(不保证data members不变) no yes 规则二当成员函数的const和non-const版本同时存在，const object只会(只能)调用const版本，non-const object只会(只能)调用non-const版本． 关于规则二的例子：class template std::basci_string&lt;…&gt;有如下两个member functions： 12charT operator[](size_t pos) const &#123; /*...*/ &#125; // 需要考虑cowreference operator[](size_t pos) &#123; /*...*/ &#125; // 不需要考虑cow COW：copy on write多个对象共享底层字符串对象；常量对象不会修改其底层对象，因此不需要考虑COW；对于非常量对象，需要考虑COW，当多个共享底层字符串的对象中的某个需要修改底层数据时，需要为该对象复制一份底层对象，让其独享．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针和引用]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是引用？ 引用和指针的区别与联系指针和引用的异同点 指针 引用 指针本身是对象 引用本身不是对象,只是对象的别名 允许对指针本身进行赋值和拷贝,在指针的生命期内可以指向不同的对象(只要指针不是常量指针) 引用定义时就和一个对象绑定,且始终和这个对象绑定,无法令引用重新绑定到另一个对象 指针无须在定义时赋初值,在块作用域内的指针如果没有被初始化,将拥有一个不确定的值. 引用必须初始化. 可以定义指向指针的指针 无法定义引用的引用 引用的常见用途引用通常不用于声明变量，而用于参数类型和返回类型的描述． 12345678910void func1(Cls* pobj)&#123; pobj-&gt;xxx();&#125;void func2(Cls obj)&#123;obj.xxx();&#125;void func3(Cls&amp; obj)&#123;obj.xxx();&#125;Cls obj;func1(&amp;obj); // 接口不同// 调用端口相同func2(obj);func3(obj); 以下两个函数被视为”same signature”(所以二者不能同时存在)： 12double imag(const double&amp; im)&#123;...&#125;double imag(const double im)&#123;...&#125; // Ambiguity Q：const是不是函数签名的一部分？A：是的，两个函数，一个函数有const，另一个没有，则可以看做函数重载．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++2.0新特性]]></title>
    <url>%2F2019%2F09%2F27%2Fc%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[此文档整理c++11中新特性． autoauto和decltype的区别与联系variadic templatesrange base for]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>c++11新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可变模板参数(c++11新特性)]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8F%AF%E5%8F%98%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Variadic Templates Variadic Templates谈的是template function template class template 变化的是template parameters 参数个数：利用参数个数注意递减的特性，实现递归函数调用．使用function template完成 参数类型：利用参数个数逐一递减，参数类型也逐一递减的特性，实现递归继承或递归复合，以class template完成． 可变模板参数写的一个小例子针对函数模板参数包，函数参数类型包，函数参数包 123456789void print() &#123;&#125; //非模板，和模板的实例形成重载函数；函数没有特化和偏特化template&lt;typename T, typename... Types&gt;void print(const T &amp;firstArg, const Types &amp;... args) &#123; // firstArg是包中第一个元素的引用，输出包中剩余元素个数 cout &lt;&lt; sizeof...(args) &lt;&lt; " "; cout &lt;&lt; firstArg &lt;&lt; endl; print(args...); // 当args为空时，调用的是非模板函数print&#125; 可变模板参数实现hash function1234567891011121314151617181920212223242526template&lt;typename T&gt;inline void hash_combine(size_t &amp;seed, const T &amp;val) &#123; seed ^= std::hash&lt;T&gt;()(val) + 0x9e3779b9 // 0x9e3779b9黄金比例 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);&#125;template&lt;typename T&gt;inline void hash_val(size_t &amp;seed, const T &amp;val) &#123; hash_combine(seed, val);&#125;template&lt;typename T, typename...Types&gt;inline void hash_val(size_t &amp;seed, const T &amp;val, const Types &amp;...args) &#123; hash_combine(seed, val); hash_val(seed, args...);&#125;// 版本1// typename...Types：任意个模板参数// 第一个函数不是size_ttemplate&lt;typename...Types&gt;inline size_t hash_val(const Types &amp;...args) &#123; size_t seed = 0; hash_val(seed, args...); return seed;&#125; 可变模板参数实现printf1234567891011121314151617181920212223242526void printf(const char *s) &#123; while (*s) &#123; if (*s == '%' &amp;&amp; (*(++s) != '%')) &#123; throw std::runtime_error("invalid formal string::missing arguments"); &#125; cout &lt;&lt; *s++; &#125;&#125;template&lt;typename T, typename... Args&gt;void printf(const char *s, T value, Args... args) &#123; while (*s) &#123; if (*s == '%' &amp;&amp; (*(++s)) != '%') &#123; cout &lt;&lt; value; printf(++s, args...); return; &#125; cout &lt;&lt; *s++; // 如果s不是用于格式控制，则直接输出s &#125; throw std::logic_error("extra argument provided to printf");&#125;void test_printf() &#123; printf("%d\n%s\n%f\n", 15, "This is Alice", 3.1415926); printf("%d, %s, %f\n", 15, "This is Alice", 3.1415926);&#125; variadic templates与initializer_list若参数的类型相同，无须使用variadic templates,使用initializer_list&lt;T&gt;即可 使用initializer_list实现max 12345678910111213141516171819202122232425262728293031323334template&lt;typename __ForwardIterator, typename __Compare&gt;__ForwardIterator __max_element(__ForwardIterator __first, __ForwardIterator __last, __Compare _comp) &#123; if (__first == __last) &#123; return __first; &#125; __ForwardIterator __result = __first; while (++__first != __last) &#123; if (_comp(__result, __first)) __result = __first; &#125; return __result;&#125;// _Iter_less_iter是一种类型inline __Iter_less_iter __iter_less_iter() &#123; return __Iter_less_iter();&#125;template&lt;typename __ForwardIterator&gt;inline __ForwardIterator max_element(__ForwardIterator __first, __ForwardIterator __last) &#123; // _iter_less_iter()是一个函数调用，但是返回一个对象 return __max_element(__first, __last, __iter_less_iter());&#125;template&lt;typename _Tp&gt;inline _Tpmax(initializer_list&lt;_Tp&gt; _l) &#123; return *max_element(_l.begin(), _l.end());&#125;// 调用形式：max(&#123;1,2,43,2,41&#125;); 使用varadic templates实现max 123456789101112int maximum(int n) &#123; return n;&#125;template&lt;typename... Args&gt;int maximum(int n, Args... args) &#123; return max(maximum(args...), n);&#125;void test_maximum() &#123; cout &lt;&lt; maximum(57, 48, 60, 100, 20, 18) &lt;&lt; endl;&#125; 对异于一般的方式处理first元素和last元素12345678910111213141516171819202122232425template&lt;int IDX, int MAX, typename... Args&gt;struct PRINT_TUPLE &#123; static void print(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123; os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX + 1 == MAX ? &quot;&quot; : &quot;,&quot;); PRINT_TUPLE&lt;IDX + 1, MAX, Args...&gt;::print(os, t); &#125;&#125;;// 当前元素是最后一个template&lt;int MAX, typename...Args&gt;struct PRINT_TUPLE&lt;MAX, MAX, Args...&gt; &#123; static void print(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123;&#125;&#125;;template&lt;typename... Args&gt;ostream &amp;operator&lt;&lt;(ostream &amp;os, const tuple&lt;Args...&gt; &amp;t) &#123; PRINT_TUPLE&lt;0, sizeof...(Args), Args...&gt;::print(os, t); return os;&#125;void test_print_tuple() &#123; cout &lt;&lt; make_tuple(1.4, &quot;hello&quot;, 13, string(&quot;good&quot;)) &lt;&lt; endl;&#125; 可变模板参数实现tuple通过private 继承实现复合递归的继承 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template&lt;typename...Values&gt;class tuple;template&lt;&gt;class tuple&lt;&gt; &#123;&#125;;// private继承template&lt;typename Head, typename... Tail&gt;class tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt; &#123; typedef tuple&lt;Tail...&gt; inherited;protected: Head m_head;public: tuple() &#123;&#125; // inherited(vtail...)调用base ctor并给予参数(不是创建temp object) tuple(Head v, Tail... vtail) : m_head(v), inherited(vtail...) &#123;&#125; // 原始构想是取出Head指定的类型，但是head类型如何知道自己是什么type？// typename Head::type head() &#123; return m_head; &#125; // 通过decltype获取Head // m_head必须声明在此句之前 // auto head() -&gt; decltype(m_head) &#123; return m_head; &#125; // 更好的等价写法 // 可以直接这么写，Head本身就是指的类型 // Head head() &#123; return m_head; &#125; // return后转型为inherited // 返回值一定得是引用 // 调用tail之后，得到一个inhertied子对象，然后再对此子对象调用head时会改变此子对象，但是如果传回的是值(而非引用)，则被改变的是副本 inherited &amp;tail() &#123; return *this; &#125;&#125;;void test_tuple() &#123; tuple&lt;int, float, string&gt; t(41, 6.3, "nico"); cout &lt;&lt; sizeof(string) &lt;&lt; " " &lt;&lt; sizeof(int) &lt;&lt; " " &lt;&lt; sizeof(float) &lt;&lt; endl; // 32 4 4 cout &lt;&lt; sizeof(t) &lt;&lt; endl; // 40 cout &lt;&lt; t.head() &lt;&lt; endl; // 40 cout &lt;&lt; t.tail().head() &lt;&lt; endl; // 6.3 cout &lt;&lt; t.tail().tail().head() &lt;&lt; endl; // nico&#125; 通过composite实现复合1234567891011121314151617181920212223242526272829303132333435363738394041424344// 这两句存在的意义是什么？换言之，为什么需要这两句template&lt;typename... Values&gt; class tup;// 特化版本template&lt;&gt; class tup&lt;&gt; &#123; public: tup() &#123; cout &lt;&lt; "empty tup" &lt;&lt; endl; &#125; &#125;;// 特化版本template&lt;typename Head, typename...Tail&gt; class tup&lt;Head, Tail...&gt; &#123; typedef tup&lt;Tail...&gt; compositied; protected: compositied m_tail; Head m_head; public: tup() &#123;&#125;; // vtail...是一个函数参数包 tup(Head v, Tail... vtail) : m_head(v), m_tail(vtail...) &#123; cout &lt;&lt; m_head &lt;&lt; " " &lt;&lt; sizeof...(vtail) &lt;&lt; endl; &#125; Head head() &#123; return m_head; &#125; compositied &amp;tail() &#123; return m_tail; &#125; &#125;;void test_tup() &#123; tup&lt;int, float, string&gt; it1(41, 6.3, "nico"); cout &lt;&lt; endl; cout &lt;&lt; sizeof(it1) &lt;&lt; endl; cout &lt;&lt; it1.head() &lt;&lt; endl; cout &lt;&lt; it1.tail().head() &lt;&lt; endl; cout &lt;&lt; it1.tail().tail().head() &lt;&lt; endl;&#125; 运行结果 1234567891011# 由内到外构造对象empty tupnico 06.3 141 2# 依次输出tup中的内容56416.3nico]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>variadic templates</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板特化]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%2F</url>
    <content type="text"><![CDATA[什么是特化？什么是偏特化？偏特化有两种，第一种是个数上的偏．第二种是范围上的偏． 对于个数上的偏，如，模板共有2个模板参数，但是只指定1个模板参数，那么这就是偏特化．范围上的偏，如第一个模板参数，表示指向任意类型，当我们想要表示指向任意类型的指针，那么这就是范围上的偏． 1234567891011121314151617181920template&lt;typename T&gt;class C &#123; public: C() &#123; cout &lt;&lt; "generic version" &lt;&lt; endl; &#125;&#125;;template&lt;typename T&gt;class C&lt;T *&gt; &#123; public: C() &#123; cout &lt;&lt; "pointer version" &lt;&lt; endl; &#125;&#125;;void test_parial_specialization() &#123; C&lt;string&gt; obj1; // 使用泛华版本 C&lt;string *&gt; obj2; // 使用指向任意类型的指针类型&#125; 运行结果： 12generic versionpointer version 函数模板没有特化，只能重载．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>specialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%85%B3%E4%BA%8E%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[对于快速排序过程中一个的问题：为什么在qsort中递归时，需要将递归范围改为[lo, pos-1]而不是[lo, pos]? 以下看一个具体例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; int i = lo - 1; int key = arr[hi]; for (int j = lo; j &lt; hi; ++j) &#123; if (arr[j] &lt;= key) &#123; ++i; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; arr[hi] = arr[i + 1]; arr[i + 1] = key; return i + 1;&#125;void qsort(vector&lt;int&gt; &amp;arr, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; int pos = partition(arr, lo, hi); // 这里返回了pos=5,所以出现了递归调用，而且这个递归调用和之前的调用一模一样 qsort(arr, lo, pos - 1); qsort(arr, pos + 1, hi);&#125;int main() &#123; vector&lt;int&gt; arr&#123;12, 34, 11, 46, 12, 89&#125;; qsort(arr, 0, arr.size() - 1); for (auto c:arr) &#123; cout &lt;&lt; c &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 在归并排序过程中，递归的两个子范围为[lo, mid]和[mid+1, hi].那是因为[lo, mid]区间必然是[lo, hi]区间的子区间，而不会和区间[lo, hi]重叠．而这里的pos是通过partition函数返回的，表示在数组中小于等于key的元素范围，pos有可能等于hi,这是区间[lo, pos]和区间[lo, hi]重叠．]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[221.Maximal Square]]></title>
    <url>%2F2019%2F09%2F27%2F221.Maximal%20Square%2F</url>
    <content type="text"><![CDATA[Maximal Square Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 解法1:单调栈解法详见程序员代码面试指南：求最大子矩阵的大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())&#123; return 0; &#125; int maxArea = 0; int row = matrix.size(); // 1 int col = matrix[0].size(); // 1 vector&lt;int&gt; height(col, 0); for(int i=0;i&lt;row;++i)&#123; for(int j=0;j&lt;col;++j)&#123; height[j] = (matrix[i][j] == '0') ? 0 : height[j] + 1; &#125; auto res = getLessThan(height); for(int j=0;j&lt;col;++j)&#123; int w = res[j][1] - res[j][0] - 1; int l = min(w, height[j]); maxArea = max(maxArea, l * l); &#125; &#125; return maxArea; &#125; vector&lt;vector&lt;int&gt;&gt; getLessThan(vector&lt;int&gt;&amp; nums)&#123; vector&lt;vector&lt;int&gt;&gt; res(nums.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for(int i=0;i&lt;nums.size();++i)&#123; int r = i; while(!s1.empty() &amp;&amp; nums[s1.top()] &gt;= nums[i])&#123; int index = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); res[index][0] = l; res[index][1] = r; &#125; s1.push(i); &#125; int r = nums.size(); while(!s1.empty())&#123; int index = s1.top(); s1.pop(); int l = s1.empty() ? -1 : s1.top(); res[index][0] = l; res[index][1] = r; &#125; return res; &#125;&#125;; 解法2:动态规划]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调序列]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8D%95%E8%B0%83%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Monotonic Array An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j]. Return true if and only if the given array A is monotonic. Example 1: 12Input: [1,2,2,3]Output: true Example 2: 12Input: [6,5,4,4]Output: true Example 3: 12Input: [1,3,2]Output: false Example 4: 12Input: [1,2,4,5]Output: true Example 5: 12Input: [1,1,1]Output: true Note: 1 &lt;= A.length &lt;= 50000 -100000 &lt;= A[i] &lt;= 100000 方法一：两次遍历第一遍检查序列是否是递增序列；第二遍检查序列是否是递减序列． 方法二：一次遍历遍历一次，依次查看相邻两对数的变化趋势是否相等，若相反，则说明不是单调序列． 12345678910111213141516171819202122232425class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; A) &#123; int store = 0; for(int i=0;i&lt;A.size()-1;++i)&#123; int c = compare(A[i], A[i+1]); if(c!=0)&#123; // A[i] != A[i+1] // A[i] != A[i+1] and A[i-1] != A[i] // then A[i] &gt; A[i+1] and A[i-1] &gt; A[i] // or A[i] &lt; A[i+1] and A[i-1] &lt; A[i] if(c!= store &amp;&amp; store != 0)&#123; return false; &#125; store = c; &#125; &#125; return true; &#125; int compare(int a, int b)&#123; if(a == b)&#123; return 0; &#125; return a &lt; b ? -1 : 1; &#125;&#125;; 方法三：一次遍历(变种)如果一个序列是单调递增的，那么不会出现相邻两个数递减的趋势，同理，若一个序列是单调递减的，那么不会出现递增的趋势．如果在一个序列中同时出现了递增和递减的趋势，说明该序列不是单调序列． 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[什么是单调栈？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;/** * 对于不含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 */vector&lt;vector&lt;int&gt;&gt; getNearLessNoRepeat(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; while (!s1.empty() &amp;&amp; arr[s1.top()] &gt; arr[i]) &#123; int popIndex = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top(); res[popIndex][0] = left; res[popIndex][1] = i; &#125; s1.push(i); &#125; while (!s1.empty()) &#123; int popIndex = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top(); res[popIndex][0] = left; res[popIndex][1] = -1; &#125; return res;&#125;/** * 对于含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 * 方法１：把所有相等元素放到一个vector中 */vector&lt;vector&lt;int&gt;&gt; getNearLess(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;vector&lt;int&gt;&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; while (!s1.empty() &amp;&amp; arr[s1.top()[0]] &gt; arr[i]) &#123; vector&lt;int&gt; popIs = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top()[s1.top().size() - 1]; for (int popi : popIs) &#123; res[popi][0] = left; res[popi][1] = i; &#125; &#125; if (!s1.empty() &amp;&amp; arr[s1.top()[s1.top().size() - 1]] == arr[i]) &#123; s1.top().push_back(i); &#125; else &#123; vector&lt;int&gt; tmp&#123;i&#125;; s1.push(tmp); &#125; &#125; while (!s1.empty()) &#123; vector&lt;int&gt; popIs = s1.top(); s1.pop(); int left = s1.empty() ? -1 : s1.top()[s1.top().size() - 1]; for (int popi: popIs) &#123; res[popi][0] = left; res[popi][1] = -1; &#125; &#125; return res;&#125;/** * 对于含重复元素的数组求其中每个元素左边和右边小于该元素且距离该元素最近的位置 * 方法2：对于每个元素从栈中退出时才统计与其相等的元素 */vector&lt;vector&lt;int&gt;&gt; getNearLess2(vector&lt;int&gt; &amp;arr) &#123; vector&lt;vector&lt;int&gt;&gt; res(arr.size(), vector&lt;int&gt;(2, -1)); stack&lt;int&gt; s1; for (int i = 0; i &lt; arr.size(); ++i) &#123; int right = i; while (!s1.empty() &amp;&amp; arr[s1.top()] &gt; arr[i]) &#123; int idx = s1.top(); vector&lt;int&gt; tmp&#123;idx&#125;; while (!s1.empty() &amp;&amp; arr[s1.top()] == arr[idx]) &#123; tmp.push_back(s1.top()); s1.pop(); &#125; int left = s1.empty() ? -1 : s1.top(); for (auto index : tmp) &#123; res[index][0] = left; res[index][1] = right; &#125; &#125; s1.push(i); &#125; int right = -1; while (!s1.empty()) &#123; int idx = s1.top(); vector&lt;int&gt; tmp&#123;idx&#125;; while (!s1.empty() &amp;&amp; arr[idx] == arr[s1.top()]) &#123; tmp.push_back(s1.top()); s1.pop(); &#125; int left = s1.empty() ? -1 : s1.top(); for (auto index:tmp) &#123; res[index][0] = left; res[index][1] = right; &#125; &#125; return res;&#125;int main() &#123; vector&lt;int&gt; arr&#123;3, 1, 3, 4, 3, 5, 3, 2, 2&#125;; vector&lt;vector&lt;int&gt;&gt; res1 = getNearLess(arr); vector&lt;vector&lt;int&gt;&gt; res2 = getNearLess2(arr); for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " " &lt;&lt; res1[i][0] &lt;&lt; " " &lt;&lt; res1[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " " &lt;&lt; res2[i][0] &lt;&lt; " " &lt;&lt; res2[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; 单调栈的应用 Maximal Square]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从数组中找重复数字系列]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[287. Find the Duplicate Number 方法一：排序，将整个数组进行排序．排序的时间复杂度和空间复杂度取决于使用的排序算法．这里要求额外空间排序度为O(1)，那么只能用堆排序． 方法二：使用set 方法三 前面方法一都会修改数组，不满足要求．方法二的额外空间复杂度是O(n)，同样不满足要求． https://leetcode.com/problems/find-the-duplicate-number/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序的优化和鸡尾酒排序]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96%E5%92%8C%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序的优化有设置哨兵来表示当前整个数组已经有序，以及设置有序区间，下一次只对有序区间进行排序（尚未完全理解）． 详情可见 鸡尾酒排序鸡尾酒排序算法适用于大部分元素已经有序的情况．它能够在特定条件下，减少排序的回合数；但是缺点是代码量几乎扩大了一倍． 鸡尾酒排序 未进行优化的鸡尾酒排序 12345678910111213141516171819202122232425262728293031323334353637383940414243void clockTailSort(vector&lt;int&gt; &amp;nums) &#123; // 未进行优化的鸡尾酒排序 int tmp = 0; for (int i = 0; i &lt; nums.size() / 2 - 1; ++i) &#123; // 有序标记，每一轮的初始值是true bool isSorted = true; // 奇数轮:从做向右比较和交换 // 奇数轮：区间内最大的数会被冒泡到最右 for (int j = i; j &lt; nums.size() - i - 1; ++j) &#123; if (nums[j] &gt; nums[j + 1]) &#123; tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; // 有元素交换，所以，不是有序，标记变为false isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; isSorted = true; // 8 1 2 3 4 // 偶数轮，从右向左比较和交换 // 偶数轮，最小的数会被冒泡到最左边 for (int j = nums.size() - i - 1; j &gt; i; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; tmp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = tmp; isSorted = false; &#125; &#125; if (isSorted) &#123; break; &#125; &#125;&#125; 进行优化的鸡尾酒排序优化方法：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>冒泡排序的优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k sum 系列]]></title>
    <url>%2F2019%2F09%2F27%2Fk-sum-%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[two sumTwo Sum II - Input array is sorted3Sum4Sum4Sum IIk sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[旋转数组]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Rotate Array旋转数组 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: 123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: 12345Input: [-1,-100,3,99] and k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? 方法一：暴力破解方法二：使用额外空间方法三：循环移动1234567891011121314151617181920void rotate(vector&lt;int&gt; &amp;nums, int k) &#123; k = k % nums.size(); int count = 0; for (int start = 0; count &lt; nums.size(); start++) &#123; int current = start; int prev = nums[start]; // 如果移动的数量正好等于nums.size()时，每个元素移动后的位置都是移动前的位置 // 那么这个循环的唯一目的就是为了count++ // nums: [0,1,2,3], k=4 do &#123; int next = (current + k) % nums.size(); int temp = nums[next]; nums[next] = prev; prev = temp; current = next; count++; &#125; while (start != current); &#125;&#125; 具体过程[0,1,2,3,4,5,6] , k = 3时，start = 0, 0-3,3-6,6-2, 2-5, 5-1, 1-4, 4-0，此时count=7，start=0，current = 0, 故退出内层循环退出内层循环，又因为count==nums.size()，故退出外层循环．[0,1,2,3,4,5], k = 2时，start = 0, 0-2, 2-4, 4-0, current = 0, start = 0, count = 3,故退出内层循环．start = 1, 1-3, 3- 5, 5 - 1, current = 1, start = 1, 故退出内层循环．count = 6, 故退出外层循环． 时间复杂度: O(n)空间复杂度: O(1) 方法四：数组逆转123456789101112131415void reverse(vector&lt;int&gt; &amp;nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; ++start, --end; &#125;&#125;void rotate1(vector&lt;int&gt; &amp;nums, int k) &#123; k = k % nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[Permutation SequenceNext permutation 当整个是逆序时，无法找到下一个更大的排列了．如[3,2,1],此时按照题目要求，直接将序列逆序，变成[1,2,3]首先找到数组连续的一对数a[i]与a[i-1]，a[i] &gt; a[i-1].之后从a[i,…,n-1]中找出一个比a[i-1]大的最小的数arr[j]与a[i-1]交换．在交换之前，序列arr[i,…,n-1]满足逆序，由于arr[i-1] &lt; arr[j]小，交换之后的序列仍然满足逆序．reverse(arr[i,..n-1])注意：数组中存在重复元素时的情形．当arr[i,..n-1]满足逆序时，若数组arr[i,..n-1]中存在重复元素，则这两个重复元素必然相邻．交换两个相等元素，显然无用，因此，在前面寻找可交换元素的过程中，没有将两个相等元素作为寻找目标．但是此时，若这两个相等元素正是arr[i,..n-1]中比arr[i-1]大的最小的元素，那么此时该选择哪一个元素呢？答案是选择索引较大的那一个．因为索引较大的那一个目前处在较低位上，reverse之后处在较高位上． Next Permutation 视频：https://www.bilibili.com/video/av52421617?from=search&amp;seid=9609389838434247675&gt;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404. Sum of Left Leaves]]></title>
    <url>%2F2019%2F09%2F27%2F404.-Sum-of-Left-Leaves%2F</url>
    <content type="text"><![CDATA[题目链接 Find the sum of all left leaves in a given binary tree. Example: 1234567 3 / \ 9 20 / \ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 如何确定左叶子节点，首先该节点必须是一个叶子节点，其次它必须位于其父节点的左子树上．当使用先序遍历时，该节点存在于左子树上且是一个叶子节点． 12345678910111213141516171819202122232425class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; return sumOfLeftLeavesCore(root); &#125; int sumOfLeftLeavesCore(TreeNode* root)&#123; int sum = 0; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while(cur!=nullptr || !st.empty())&#123; if(cur == nullptr)&#123; cur = st.top(); st.pop(); cur = cur-&gt;right; &#125;else&#123; st.push(cur); cur = cur-&gt;left; if(cur &amp;&amp; cur-&gt;left == nullptr &amp;&amp; cur-&gt;right == nullptr)&#123; sum += cur-&gt;val; &#125; &#125; &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2F2019%2F09%2F27%2F142.%20Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. 解法1双指针,快指针在前,慢指针在后.快指针一次走两步,慢指针一次走一步.如果链表无环,快指针一定先达到链表尾.否则,快指针比满指针走的快,快指针和慢指针一定会在链表上相遇. 找到快慢指针相遇的环中节点后,接下来要怎么找入环节点呢.我们知道快指针比慢指针快,如果要是能让快指针和慢指针在入环节点处相遇,那么需要快指针比慢指针多走一个环的长度的距离.当快指针和慢指针都在环上走时, 如果让慢指针先出发,当快指针赶上慢指针时,快指针正好比慢指针多走了一个环长的距离.所以,只需要让慢指针先走一个环的长度的距离,然后快指针和慢指针一起走,快指针来追赶慢指针,当慢指针赶上快指针时,正好是在入环节点上. 那么如何求环的长度呢?只需要一个指针从(快慢指针在环上相遇的节点)相遇节点出发, 再次回到该节点所需要走的步数就是环的长度. 为什么必须快指针在前,慢指针在呢?举个例子 如果链表是1-&gt;2-&gt;3.如果初始化时,慢指针在前,指向节点2, 快指针在后,指向1,那么快指针会赶上慢指针,即快慢指针会在节点3相遇,那么结束条件就不能是快指针和慢指针是否相遇.如果如上所示,即使没环,快慢指针也会在节点3处相遇.]]></content>
      <categories>
        <category>leetcode</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2F2019%2F09%2F27%2F164%20maximum-gap%2F</url>
    <content type="text"><![CDATA[Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. 解法1:基数排序12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F09%2F27%2F19.%20Remove%20Nth%20Node%20From%20End%20of%20List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 两趟算法一趟算法用两个指针，一个快指针先走n+2步．指向第n+2个节点．随后慢指针也从头节点出发，两个指针一起向前走．当快指针到达链表尾后节点时，慢指针指向的节点和尾后节点之间隔着n个节点，即慢指针指向倒数第n+1个节点．这时候只需要删除慢指针指向的下一个节点即可．有几种情况需要考虑： 当链表中的总节点个数少于n个．无法删除倒数第n个节点． 当链表中的总结点个数等于n个．要被删除的正好是头结点． 当链表中的总结点个数大于n个．删除倒数第n个节点． 首先让快指针先走，要么走到第n+2个节点，要么走到尾后节点．快指针先走之后，通过判断快指针共走过的节点个数来分情况处理．若快指针共走过k个节点(包括最后一个尾后空节点) 若k&lt;=n，说明链表中节点个数少于n，快指针走过的节点中包括了尾后节点(空节点) 若k==n+1，说明链表中节点个数为n，要删除的正是头结点 若k==n+2，说明链表中至少有n+1个非空节点，可以删除倒数第n个节点． AC代码 12]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传参]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[传参有值传递和引用传递两种方式．值传递用在参数较小的情况下，值传递过程中，形参和实参独立．对形参的修改不会影响实参．引用传递用在：传递的参数较大或者不支持拷贝时．引用传递可以避免拷贝实参，但对形参的修改会直接影响实参． 数组形参数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响．这两个特殊性质是： 不允许拷贝数组 使用数组时通常会将数组名转换为指向数组首元素的指针 因为不能拷贝数组，所以我们不能以值传递的方式使用数组参数．因为数组会被转换为指针，所以当我们为函数传递一个数组时，实际上传递的是一个指向数组首元素的指针（传入的数组的大小对函数调用没有影响）．三个形式不同但等价的函数声明： 123void print(const int*);void print(const int[]);void print(const int[10]); // 这里的维度表示我们希望数组含有多少个元素，但实际情况不一定 尽管形式不同，但上面三个函数是等价的：每个函数的唯一形参都是const int*类型的．当编译器处理对print函数的调用时，只检查传入的参数是否是const int *类型的(这里的const是底层的，是表示指针指向的是常量对象)．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeof]]></title>
    <url>%2F2019%2F09%2F27%2Fsizeof%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[sizeof运算符返回一条表达式或一个类型所占的字节数.sizeof运算符的结果是一个size_t类型的值. sizeof运算符满足右结合律.因此,表达式sizeof p等价于sizeof(\p). 这是因为sizeof满足右结合律且与*运算符的优先级相同.所以表达式会按照从右向左的顺序组合. sizoef运算符并不实际求其运算对象的值.因此,sizeof运算可以对一个无效指针进行运算. 以下是各种内置数据类型在64位机器上所占空间大小: 12345678910111213141516171819cout &lt;&lt; "sizeof(int):" &lt;&lt; sizeof(int) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(float):" &lt;&lt; sizeof(float) &lt;&lt; endl; // 4cout &lt;&lt; "sizeof(double):" &lt;&lt; sizeof(double) &lt;&lt; endl;// 8cout &lt;&lt; "sizeof(char):" &lt;&lt; sizeof(char) &lt;&lt; endl; // 1int *p = 0;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl;p = new int&#123;12&#125;;// 8, 指针本身所占内存空间的大小cout &lt;&lt; "sizeof(p):" &lt;&lt; sizeof(p) &lt;&lt; endl;// 4, 指针指向的对象所占内存空间的大小cout &lt;&lt; "sizeof(*p):" &lt;&lt; sizeof(*p) &lt;&lt; endl; sizeof运算符与数组 对数组执行sizeof运算得到整个数组所占空间的大小.sizeof运算不会把数组名转成指针来处理 可以利用sizeof运算符来求数组中元素个数. 12345int arr[] = &#123;1, 2, 3&#125;;cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 12(4x3)int n = sizeof(arr) / sizeof(*arr);cout &lt;&lt; "n=" &lt;&lt; n &lt;&lt; endl; // 3,数组中元素个数 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小,不会计算对象中的元素占用了多少空间 1234vector&lt;int&gt; arr&#123;1, 3, 7, 3&#125;;vector&lt;int&gt; brr(100, 0);cout &lt;&lt; "sizeof(arr):" &lt;&lt; sizeof(arr) &lt;&lt; endl; // 24cout &lt;&lt; "sizeof(brr):" &lt;&lt; sizeof(brr) &lt;&lt; endl; // 24]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[71. Simplify Path]]></title>
    <url>%2F2019%2F09%2F27%2F71.Simplify-Path%2F</url>
    <content type="text"><![CDATA[题目描述Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path. Example 1: 123Input: &quot;/home/&quot;Output: &quot;/home&quot;Explanation: Note that there is no trailing slash after the last directory name. Example 2: 123Input: &quot;/../&quot;Output: &quot;/&quot;Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: 123Input: &quot;/home//foo/&quot;Output: &quot;/home/foo&quot;Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: 12Input: &quot;/a/./b/../../c/&quot;Output: &quot;/c&quot; Example 5: 12Input: &quot;/a/../../b/../c//.//&quot;Output: &quot;/c&quot; Example 6: 12Input: &quot;/a//b////c/d//././/..&quot;Output: &quot;/a/b/c&quot; # 解法1 思路：一次取出path中不等于//的部分（表示的是目录），若该部分是..，表示返回上级目录，若此时不在根目录下则有上级目录可以返回，则返回上级目录，即删除当前的目录。若该部分是.，表示当前目录，则什么也不做。否则，将新的目录加入到当前路径中（这里用vector来存储当前路径中的所有目录名）。最后将整个目录用/连接起来。另外，这里的根目录是隐含的，没有在初始化路径时加入到vector中，这是因为我们知道当前路径中的第一个目录一定是根目录。 注意：vector等的size()都是无符号数，无符号数都大于等于0，无符号数与有符号数做减法时不会产生负数，而是会变成一个很大的整数。参见：c++数据类型基础知识 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string simplifyPath(string path) &#123; if(path.empty() || path[0]!='/')&#123; return ""; &#125; vector&lt;string&gt; vec; int i=1; while(i &lt; path.size())&#123; int j=i; while(j &lt; path.size() &amp;&amp; path[j]=='/')&#123; ++j; &#125; i = j; while(j &lt; path.size() &amp;&amp; path[j]!='/')&#123; ++j; &#125; if(i &lt; j)&#123; string tmp = path.substr(i, j-i); if(tmp == "..")&#123; if(!vec.empty())&#123; vec.pop_back(); &#125; &#125;else if(tmp !=".")&#123; vec.push_back(tmp); &#125; &#125; i = j; &#125; string res = "/"; i = 0; while(vec.size() &gt; 1 &amp;&amp; i &lt; vec.size()-1)&#123; res += vec[i]; res += "/"; ++i; &#125; if(!vec.empty())&#123; res += vec[vec.size()-1]; &#125; return res; &#125;&#125;; 复杂度分析 时间复杂度为为O(n)，只从左到右扫描了整个路径字符串一遍。空间复杂度为O(n)，使用了一个vector来存储路径。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2F2019%2F09%2F27%2F225.-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 注意点是否需要处理异常情况。 # 两个队列，push(O(1),pop O(n)) 两个队列，push(O(n),pop O(1))一个队列，push(O(n),pop O(1))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桶排序和计数排序]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[比较排序,例如归并排序, 堆排序, 快速排序等等. 在比较排序中, 各元素的次序依赖于它们之间的比较.任何比较排序在最坏情况下都要经过O(nlogn)次比较.快速排序的额外空间复杂度为O(logn)，归并排序的空间复杂度为O(n)，堆排序的空间复杂度为O(1) 桶排序假设输入数据服从均匀分布, 平均情况下它的时间代价为O(n). 与计数排序类似,因为对输入数据做了某种假设, 桶排序的速度也很快.具体来说,计数排序假设数据都属于一个小区间内的整数, 而桶排序假设输入是由一个随机过程产生,该过程将元素均匀,独立地分布在[0,1]区间内.桶排序将[0,1]区间划分为n个相同大小的子区间, 或称为桶.然后将n个输入数分别放在各个桶中.因为输入数据是均匀,独立地分布在[0,1]区间上,所以一般不会出现很多数落在同一个桶中的情况.为了得到输出结果, 先对每个桶中的数进行排序,然后遍历每个桶,按照次序将各个桶中的元素列出来即可. 桶排序是稳定排序．如果有两个键值相同的元素进行排序，那么这两个元素排序前后的相对位置不会改变． 1234567891011121314151617181920212223242526272829303132333435363738394041424344void bucketSort1(vector&lt;int&gt; &amp;nums, int bucketSize) &#123; if (nums.size() &lt; 2) &#123; return; &#125; vector&lt;vector&lt;int&gt;&gt; help(nums.size(), vector&lt;int&gt;(0)); int i; int maxVal, minVal; maxVal = nums[0]; minVal = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; minVal) &#123; minVal = nums[i]; &#125; else if (nums[i] &gt; maxVal) &#123; maxVal = nums[i]; &#125; &#125; int bucketCount = (maxVal - minVal) / bucketSize + 1; vector&lt;vector&lt;int&gt;&gt; buckets(bucketCount, vector&lt;int&gt;(0)); for (int i = 0; i &lt; nums.size(); ++i) &#123; int index = (nums[i] - minVal) / bucketSize;// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]" &lt;&lt; nums[i] &lt;&lt; " index:" &lt;&lt; index &lt;&lt; endl; buckets[index].push_back(nums[i]); &#125; int arrIndex = 0; for (int i = 0; i &lt; buckets.size(); ++i) &#123; if (buckets[i].empty()) &#123; continue; &#125; insectionSort(buckets[i]); // cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "个桶中:";// for (int j = 0; j &lt; buckets[i].size(); ++j) &#123;// cout &lt;&lt; buckets[i][j] &lt;&lt; " ";// &#125;// cout &lt;&lt; endl; for (int value : buckets[i]) &#123; nums[arrIndex++] = value; &#125; &#125;&#125; 另一种与桶排序相关的排序方法. 12345678910111213141516171819202122232425262728293031323334// max是数组中元素的最大值, 数组中的元素都在0-max之间void bucketSort(vector&lt;int&gt; &amp;arr, int max) &#123; int i, j; vector&lt;int&gt; buckets(max, 0); // 桶数组,所有 if (arr.empty() || max &lt; 1) &#123; return; &#125; for (int i = 0; i &lt; arr.size(); ++i) &#123; buckets[arr[i]]++; &#125; // bucket[i]表示数组arr中等于i的元素个数 for (int i = 0, j = 0; i &lt; maxVal; ++i) &#123; // 当数组arr中等于i的元素个数不为0,就把元素i加入到原来的数组arr中 while ((buckets[i]--) &gt; 0) &#123; arr[j++] = i; &#125; &#125;&#125;void testBucketSort() &#123; vector&lt;int&gt; arr = &#123;8, 2, 3, 4, 3, 6, 6, 3, 9&#125;; for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; bucketSort(arr, 10); for (int i = 0; i &lt; arr.size(); ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 计数排序计数排序假设n个输入元素的每一个都是在0-k区间内的一个整数,其中k为某个整数.计数排序的基本思想:对于每一个输入元素x, 确定小于x的元素个数,.利用这一信息,就可以直接把x放在它在输出数组中的位置上了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445void countingSort(vector&lt;int&gt; &amp;nums) &#123; if (nums.size() &lt; 2) &#123; return; &#125; int maxVal = -2147483648; for (int i = 0; i &lt; nums.size(); ++i) &#123; maxVal = maxVal &gt; nums[i] ? maxVal : nums[i]; &#125; vector&lt;int&gt; count(maxVal + 1, 0); // count[i]表示数组nums中等于i的元素个数 for (int i = 0; i &lt; nums.size(); ++i) &#123; ++count[nums[i]]; &#125; // count[i]表示数组nums中小于等于i的元素个数 for (int i = 1; i &lt; count.size(); ++i) &#123; count[i] += count[i - 1]; &#125; vector&lt;int&gt; aux(nums.size()); for (int i = 0; i &lt; nums.size(); ++i) &#123; // count[nums[i]]表示数组nums中小于等于nums[i]的元素个数,因此count[nums[i]]也就是nums[i]在排序后数组中的位置// cout &lt;&lt; "nums[" &lt;&lt; i &lt;&lt; "]:" &lt;&lt; nums[i] &lt;&lt; " count:" &lt;&lt; count[nums[i]] &lt;&lt; endl; aux[--count[nums[i]]] = nums[i]; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; nums[i] = aux[i]; &#125; cout &lt;&lt; endl;&#125;void testcountingSort() &#123;// vector&lt;int&gt; nums&#123;2, 1, 2, 4, 5&#125;; vector&lt;int&gt; nums&#123;5, 4, 3, 2, 2, 4, 1&#125;; for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; countingSort(nums); for (int i = 0; i &lt; nums.size(); ++i) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 基数排序假设n个d位的元素存放在数组A中, 其中第1位是最低位, 第d位是最高位. 123radixSort(A, d) for i = 1 to d use a stable sort to sort array A on digit i]]></content>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[静态内存用来保存局部静态对象,类静态数据成员以及定义在任何函数之外的变量.栈内存用来保存定义在函数内的非static对象.分配在静态或栈内存的对象由编译器自动创建和销毁. 栈对象在其定义的程序块运行时才存在;静态对象在使用之前分配,在程序结束时销毁.堆用来存储动态分配的对象, 即在程序运行时分配的对象.动态对象的生命期由程序控制.也就是说,当动态对象不再使用时,必须在代码中显式地销毁它们.c++动态内存的管理由一对运算符new和delete来完成.new在动态内存中为对象分配空间并返回一个指向该对象的指针.delete:接受一个动态对象的指针,销毁该对象,并释放该对象占用的内存. 常规指针的缺陷如果忘记了释放内存,就会导致内存泄露.如果在还有指针引用内存的情况就释放了内存会产生引用非法内存的指针. 智能指针与常规指针的区别在于, 智能指针是类类型, 在离开作用域时会自动调用析构函数, 自动释放内存. 程序使用动态内存的原因 原因 例子 程序不知道自己需要使用多少对象 容器类 程序不知道所需对象的准确类型 动态绑定 程序需要在多个对象间共享数据 strBlob类 shared_ptr: 多个指针可以指向同一个对象.使用引用计数来记录该对象的资源被多少个指针共享.当引用计数为0时, 资源自动释放. unique_ptr:同一时刻只能有一个unique_ptr指向一个给定对象.unique_ptr独占对象的资源.unique_ptr不支持普通的拷贝和赋值.可以通过release和reset将指针的所有权从一个unique_ptr转移到另一个unique_ptr. weak_ptr:不控制所指向对象生存期的智能指针,它指向由一个shared_ptr管理的对象.将一个weak_ptr绑定到一个shared_ptr不会改变该shared_ptr的引用计数.因此, weak_ptr指向的对象可能被释放掉.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Target Sum 系列]]></title>
    <url>%2F2019%2F09%2F27%2FTarget-Sum-%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[combination sumCombination Sum IICombination Sum IIICombination Sum IV 3Sum4Sum4Sum II]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>target sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载new和delete]]></title>
    <url>%2F2019%2F09%2F27%2Fnew%E5%92%8Cdelete%2F</url>
    <content type="text"><![CDATA[当应用程序对于内存分配有特殊要求时,需要重载operator new和operator delete运算符. new表达式的工作机制 new表达式的工作机理 当我们使用一条new表达式时,实际执行了三步操作. 第一步,调用名为operator new(或operator new[])的标准库函数, 分配一块足够大的, 原始的, 未命名的内存空间以便存储特定类型的对象(或对象数组). 运行相应的构造函数构造这些对象,并初始化这些对象 对象被分配了空间并构造完成,返回一个指向该对象的指针. 1234567891011121314151617181920212223class Complex &#123;public: explicit Complex(double _real = 0.0, double _vir = 0.0) : real(_real), vir(_vir) &#123;&#125;private: double real; double vir;&#125;;Complex *pc = new Complex(1, 2);//equal to:void *p = operator new(sizeof(Complex)); // 分配内存Complex *pc = static_cast&lt;Complex *&gt;(p); // 转型pc-&gt;Complex::Complex(1, 2); // 调用构造函数delete pc;//equal topc-&gt;~Complex(); // 调用对象的析构函数operator delete(p); // 释放内存空间 delete表达式的工作机理 当我们使用一条delete表达式时,实际执行了两步操作. 对delete表达式中指针所指向的对象执行相应的析构函数 调用名为operator delete(或operator delete[])的标准库函数释放对象内存空间 几个疑问为什么array new一定要搭配array delete？(array new 即new [size])？发生内存泄露不在于array new 分配的数组，而在于delete 表达式仅仅调用一次析构函数，而array delete表示调用多次(取决于array new分配的数组大小)析构函数．如果在对象的构造函数中进行了动态内存分配，那么需要在析构函数中进行释放，但是delete表达式仅仅调用一次而非多次析构函数，无法释放数组中所有对象分配的动态内存，因此会造成内存泄露． 定位new表达式可以通过自定义operator new和operator delete函数来控制内存分配过程.但是有一个operator new函数不允许被用户重载: 1void *operator new(size_t, void*) 此形式的operator new(定位new)只供标准库使用,不允许用户重载.该函数并不分配内存,而是直接返回void参数传入的指针;然后由new表达式负责在指定的地址初始化对象以完成整个工作.即*定位new允许我们在一个特定的,预先分配的内存地址上构造对象**.传给定位new表达式的指针可以是堆内存,也可以不是. 使用定位new表达式定位new表达式的形式: new (place_address) type [n] {initializer list}其中,place-address是一个指针,指向已经分配好的内存地址, type表示要构造的对象的类型, n可选参数,表示要构造的对象的个数, {initializer list}为初始化列表用于初始化对象. 指针place_address指向的是堆内存 123456789101112131415161718void f1()&#123; int *p1, *p2; p1 = new int; p2 = new(p1)int(4); // p1和p2指向同一块内存 cout &lt;&lt; "p1:" &lt;&lt; p1 &lt;&lt; " p2:" &lt;&lt; p2 &lt;&lt; endl; double *p3, *p4; p3 = new double[N]; // 堆内存,p3指向动态分配的空间 p4 = new(p3) double[N]&#123;1.1, 2.2, 3.0, 4.6, 6.9&#125;; // 定位new允许我们在一个特定的,预先分配的内存地址上构造对象 for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p4[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 12p1:0x55821bbafe70 p2:0x55821bbafe701.1 2.2 3 4.6 6.9 指针place_address指向的是静态内存 1234567891011121314151617const int BUF = 512;const int N = 5;char buffer[BUF];void f2()&#123; int *p; p = new(buffer) int[N]; // buffer是静态内存, 定义在任何函数之外的变量 for (int i = 0; i &lt; N; ++i) &#123; p[i] = i * 4; &#125; cout &lt;&lt; "静态分配的地址buffer:" &lt;&lt; (void *) buffer &lt;&lt; endl; cout &lt;&lt; "直接使用placement new的p2地址" &lt;&lt; p &lt;&lt; endl; for (int i = 0; i &lt; N; ++i) &#123; cout&lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 123静态分配的地址buffer: 0x556ab55fd140直接使用placement_new的p2地址: 0x556ab55fd1400 4 8 12 16 指针place_address指向的是栈内存 123456789101112131415void f3()&#123; int a; int *p = new(&amp;a)int; // p指向的内存正是a所在地址 cout &lt;&lt; "&amp;a:" &lt;&lt; &amp;a &lt;&lt; " p:" &lt;&lt; p &lt;&lt; endl; string arr[N]; // 栈内存, arr中保存着定义在函数内的非static对象 string *p; p = new(arr) string[N]&#123;"hello", "world", "a", "good", "day"&#125;; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; p[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 运行结果 12&amp;a:0x7ffe52fda13c p:0x7ffe52fda13chello world a good day 重载operator new和operator delete用户可以自定义oeprator new和operator delete，但是自定义版本必须位于全局作用于或者类的作用域中．当自定义类的operator new和operator delete时，它们是隐式静态的，无须显式声明static．operator new在对象构造之前调用，而opertator delete在对象销毁之后调用，所以这两个成员必须是静态的，而且它们不操纵类的任何数据成员． 重载类的operator new和operator delete首先类的声明即定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Foo &#123; public: Foo() : _id(0) &#123; cout &lt;&lt; "default ctor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; Foo(int i) : _id(i) &#123; cout &lt;&lt; "ctor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; ~Foo() &#123; cout &lt;&lt; "dtor.this=" &lt;&lt; this &lt;&lt; " id=" &lt;&lt; _id &lt;&lt; endl; &#125; static void *operator new(size_t size); static void operator delete(void *pdead, size_t size); static void *operator new[](size_t size); static void operator delete[](void *pdead, size_t size); private: int _id; long _data; string _str;&#125;;void *Foo::operator new(size_t size) &#123; Foo *p = (Foo *) malloc(size); cout &lt;&lt; "custom operator new" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; return p;&#125;void Foo::operator delete(void *pdead, size_t size) &#123; cout &lt;&lt; "custom operator delete" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; free(pdead);&#125;void *Foo::operator new[](size_t size) &#123; Foo *p = (Foo *) malloc(size); cout &lt;&lt; "custom operator new[]" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; return p;&#125;void Foo::operator delete[](void *pdead, size_t size) &#123; // 析构函数调用顺序为逆序调用，从最后一个元素到第一个元素 cout &lt;&lt; "custom operator delete[]" &lt;&lt; " "; cout &lt;&lt; "size = " &lt;&lt; size &lt;&lt; endl; free(pdead);&#125; 测试代码： 当没有定义成员 operator new和operator delete时就调用全局的operator new和operator delete 123456789101112131415void test_foo1() &#123; // 若无members就调用globals Foo *pf = new Foo; delete pf; cout &lt;&lt; endl; Foo *parr = new Foo[1]; delete[] parr; cout &lt;&lt; endl; parr = new Foo[2]; delete[] parr;&#125; 在64位系统上，string占32个字节，int占4个字节，long占8个字节．因此，sizeof(Foo)=32+4+8=44，又因为44不是8的倍数，因此，在Foo中添加一些padding，最后sizeof(Foo)=48字节．最后的运行结果为： 12345678910111213141516custom operator new size = 48default ctor.this=0x55bda8d2be70 id=0dtor.this=0x55bda8d2be70 id=0custom operator delete size = 48custom operator new[] size = 56default ctor.this=0x55bda8d2be78 id=0dtor.this=0x55bda8d2be78 id=0custom operator delete[] size = 56custom operator new[] size = 104default ctor.this=0x55bda8d2c2c8 id=0default ctor.this=0x55bda8d2c2f8 id=0dtor.this=0x55bda8d2c2f8 id=0dtor.this=0x55bda8d2c2c8 id=0custom operator delete[] size = 104 可以看到，这里调用了自定义的operator new和operator delete函数．此外，分别使用new Foo和new Foo[1]动态分配一个Foo对象时，打印出的size不同，这是因为在operator new[]中分配的内存的最上面有一个额外内存用于记录数组中元素的个数，以备记录调用delete []时，需要调用析构函数的次数．当new Foo[2]时：size=104．首先两个Foo对象占用内存为48 * 2 = 96字节, 而在分配内存的最前端有一个counter记录数组中元素个数，因此，最后size = 96 + 8 = 104．即这个动态分配的数组在占用内存如下图所示： 此外，可以看到，在delete[]表达式中调用析构函数是逆序调用的，即数组中最后一个元素首先调用析构函数，然后倒数第二个，依次类推，直到第一个元素． 强制调用全局operator new和operator delete 12345678910void test_foo2() &#123; // 强制使用globals Foo *pf = ::new Foo; ::delete pf; cout &lt;&lt; endl; Foo *parr = ::new Foo[2]; ::delete[] parr;&#125; 运行结果： 1234567default ctor.this=0x55e231ba2e70 id=0dtor.this=0x55e231ba2e70 id=0default ctor.this=0x55e231ba32c8 id=0default ctor.this=0x55e231ba32f8 id=0dtor.this=0x55e231ba32f8 id=0dtor.this=0x55e231ba32c8 id=0 重载placement new我们可以重载class member operator new()，写出多个版本，前提是每一版本的声明都必须有独特的参数列，其中第一参数必须是size_t，其余参数是以new所指定的placement arguments为初值．出现于new(…)小括号内的便是所谓placement arguments．也有其他定义说，new()括号内有一个指针做参数时才称为placement new． 1Foo* pf = new (300, 'c')Foo; 我们也可以重载class member operator delete()（或者称此为placement operator delete），写出多个版本．但它们绝不会被delete调用．在旧版本的编译上，只有当new所调用的ctor(构造函数)抛出exception时，才会调用这些重载版的operator delete()．它只能这样被调用，主要用来归还未能完全创建成功的object所占用的memory．下面的示例程序说明只有当new所调用的ctor抛出异常时，才会调用重载版本的operator delete() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Bad &#123; public: Bad() &#123; cout &lt;&lt; "exception" &lt;&lt; endl; &#125;&#125;;class Foo &#123; public: Foo() &#123; cout &lt;&lt; "Foo::Foo()" &lt;&lt; endl; &#125; Foo(int) &#123; cout &lt;&lt; "Foo::Foo(int)" &lt;&lt; endl; throw Bad(); &#125; // 这个是一般的operator new()的重载 void *operator new(size_t size) &#123; return malloc(size); &#125; // 标准库已经提供的placement new()的重载形式 void *operator new(size_t size, void *start) &#123; return start; &#125; // 自定义的placement new void *operator new(size_t size, long extra) &#123; return malloc(size + extra); &#125; void *operator new(size_t size, long extra, char init) &#123; return malloc(size + extra); &#125; void operator delete(void *p, size_t) &#123; free(p); cout &lt;&lt; "operator delete(void *p, size_t)" &lt;&lt; endl; &#125; void operator delete(void *p, long) &#123; delete p; cout &lt;&lt; "operator delete(void *p, long)" &lt;&lt; endl; &#125; void operator delete(void *p, long, char) &#123; delete p; cout &lt;&lt; "operator delete(void *p, long, char)" &lt;&lt; endl; &#125;&#125;;void test1() &#123; Foo start; Foo *p1 = new Foo; Foo *p2 = new(&amp;start)Foo; Foo *p3 = new(100)Foo; Foo *p4 = new(100, 'a') Foo; Foo *p5 = new(100)Foo(1); // 调用构造函数时会抛出异常 Foo *p6 = new(100, 'a')Foo(1); Foo *p7 = new(&amp;start)Foo(1); Foo *p8 = new Foo(1);&#125; 运行结果：在gnu7.4.0测试，没有调用自定义的operator delete． new表达式的作用域查找规则如果被分配(释放)的对象是类类型，则编译器首先在类及其基类的作用域中查找．此时如果该类含有operator new成员或者operator delete成员，则相应的表达式将调用这些成员．否则，编译器在全局作用域中查找匹配的函数．此时如果编译器找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；否则，则使用标准库定义的版本．]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2F2019%2F09%2F27%2F221.Maximal-Square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 解法1首先为原矩阵生成一个同样大小的新矩阵dpdp[i][j]表示以index[i][j]作为右下角的正方形的最大边长.dp[i][j] = min{dp[i][j-1], dp[i-1][j-1], dp[i-1][j-1]}.为什么一定要考虑dp[i-1][j-1]呢?下面举个例子说明例如当前dp矩阵为 12[[0,1], [1,1]] 则以位置[1,1]为右下角的最大的正方形的边长为1,因为,位置[0,0]处的边长为0, 即位置[0,0]上的元素为0.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamice programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载和重写]]></title>
    <url>%2F2019%2F09%2F27%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重载是指在同一作用域内的几个函数名字相同但形参列表不同，称这些函数为重载函数．重写(override)是指子类中对父类的虚函数不继承其实现，而重新实现． 两个除了返回类型外其他所有要素都相同的函数不是重载函数．顶层const不影响形参的类型． 12Record lookup(Phone); Record lookup(const Phone); //重复声明了Record lookup(Phone) 但底层const可以区分两个函数．即如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载． 12Record lookup(Account&amp;); // 函数作用于Account的引用Record lookup(const Account&amp;); // 新函数，作用于常量引用 编译器可以通过实参是否是常量来推断应该调用哪个函数．因为const不能转换成其他类型，所以我们只能把const对象(指向const对象的指针)传递给const形参．但是非常量对象可以转换成const，所以上面两个函数都可以作用于非常量对象，但是当实参是非常量对象时，编译器会优先选择非常量版本的函数． 重写(override)是指子类中对父类的虚函数不继承其实现，而重新实现． const_cast和重载 12345678const string &amp;shorterString2(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt; s2.size() ? s1 : s2;&#125;string &amp;shorterString2(string &amp;s1, string &amp;s2) &#123; auto &amp;r = shorterString2(static_cast&lt;const string &amp;&gt;(s1), static_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(r);&#125;]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未排序数组中累加和为给定值的最长子数组系列问题]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原题给定一个无序数组,其中元素可正,可负,可0.给定一个整数k,求arr所有的子数组中累加和为k的最长子数组长度. 12345678910111213141516171819int maxLength(vector&lt;int&gt; &amp;arr, int k) &#123; if (arr.empty()) &#123; return 0; &#125; map&lt;int, int&gt; mp; mp[0] = -1; int len = 0; int sum = 0; for (int i = 0; i &lt; arr.size(); i++) &#123; sum += arr[i]; if (mp.find(sum - k) != mp.end()) &#123; len = max(len, i - mp[sum - k]); &#125; if (mp.find(sum) == mp.end()) &#123; mp[sum] = i; &#125; &#125; return len;&#125; 补充题1补充题2类似题138. 子数组之和给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置 样例 样例 1: 123输入: [-3, 1, 2, -3, 4]输出: [0,2] 或 [1,3] 样例解释： 返回任意一段和为0的区间即可。 样例 2: 12输入: [-3, 1, -4, 2, -3, 4]输出: [1,5] 样例 3: 12输入: [3,4,5,6,-3,-4,-5,-6]输出: [0,7] 样例 4: 12输入: [1,0,-1]输出: [1,1] 注意事项: 至少有一个子数组的和为 0 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /** * @param nums: A list of integers * @return: A list of integers includes the index of the first number and the index of the last number */ vector&lt;int&gt; subarraySum(vector&lt;int&gt; &amp;nums) &#123; // write your code here if(nums.empty())&#123; return &#123;&#125;; &#125; int sum = 0; vector&lt;int&gt; res; map&lt;int, int&gt; mp; for(int i=0;i&lt;nums.size();++i)&#123; sum += nums[i]; if(sum == 0)&#123; res.push_back(0); res.push_back(i); return res; &#125; if(mp.find(sum)!=mp.end())&#123; res.push_back(mp[sum]+1); res.push_back(i); return res; &#125; mp[sum] = i; &#125; return res; &#125;&#125;; 此题与上题的相似之处在于:需要用到相同的结论:s[i]= arr[0] + arr[1] +…+arr[i]s[j]= arr[0] + arr[1] +…+arr[j]假设i &gt; j,则s[i] - s[j] = arr[j+1] + arr[j+2] + … + arr[i] 复杂度分析 理论上, 时间复杂度为O(n).但实际实现时,时间复杂度为O(nlogn).因为map的find方法查找一个数的时间复杂度为O(logn)空间复杂度为O(n) 题目来源: leetcode 560. Subarray Sum Equals K930 binary subarrays with sum另有使用三指针的解法,可以尝试看看试用否,三指针解法时间复杂度为O(n),空间复杂度为O(1),是最优解法]]></content>
      <tags>
        <tag>累积和</tag>
        <tag>leetcode</tag>
        <tag>程序员代码面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历的延伸]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%9A%84%E5%BB%B6%E4%BC%B8%2F</url>
    <content type="text"><![CDATA[中序遍历的延伸题找出二叉搜索树中两个错误的节点题目来源: leetcode题目链接 Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 解法1]]></content>
  </entry>
  <entry>
    <title><![CDATA[767. Reorganize String]]></title>
    <url>%2F2019%2F09%2F27%2F767.Reorganize-String%2F</url>
    <content type="text"><![CDATA[Reorganize StringGiven a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example 1: 12Input: S = &quot;aab&quot;Output: &quot;aba&quot; Example 2: 12Input: S = &quot;aaab&quot;Output: &quot;&quot; Note: S will consist of lowercase letters and have length in range [1, 500]. 解法1根据插空法, 当数组中有n个数,且n/2个数都是同一个数.如下所示: 1234567示例1[1,1,1,2,2]1,2,1,2,1示例2[1,1,1,2,2,2]1,2,1,2,1,2 则数组中最多有(n+1)/2个是同一个数,这样可以通过插空法,隔一个位置插一个数保证每两个相邻的数不同.如示例1中如果1的个数再多出一个就无法保证每两个相邻的数不同. 因为通过首先统计数组中是否存在出现次数超过(n+1)/2的数来判断是否存在一种方案能保证任意两个相邻的数不同.然后通过重组数组来给出一种方案.重组数组的过程中,首先将数组中元素按出现次数由少到多排序,然后,将前面一般分布到奇数位置上,将后一般分布到偶数位置上来实现任意两个相邻的元素不同. c++如何对map进行排序 时间复杂度为O(m(n + logn)),其中n是S的长度,m是用于统计每个字符出现次数的map的大小.因此时间复杂度为O(n)空间复杂度为O(n+m) 解法2https://leetcode.com/articles/reorganized-string/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>求众数(出现次数超过n/2的数)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在数组中找到出现次数大于n/k的数]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8Enk%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这道题十分重要，有诸多解法，且用到许多不同的思想。 在数组中找到出现次数超过n/2的数暴力破解排序法在数组找到出现次数大于n/k的数在数组中找到出现次数大于n/3的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; if(nums.empty())&#123; return res; &#125; map&lt;int, int&gt; mp; // cand for(int i=0;i&lt;nums.size();i++)&#123; if(mp.find(nums[i]) == mp.end())&#123; mp[nums[i]] = 1; &#125;else&#123; ++mp[nums[i]]; &#125; if(mp.size() == 3)&#123; allMinusOne(mp); &#125; &#125; map&lt;int,int&gt; counter; countElem(nums, mp, counter); for(auto it=mp.begin();it!=mp.end();it++)&#123; int num = it-&gt;first; if(counter[num]&gt;(nums.size()/3))&#123; res.push_back(num); &#125; &#125; return res; &#125; void allMinusOne(map&lt;int,int&gt; &amp;mp)&#123; auto it= mp.begin(); while(it!=mp.end())&#123; if(it-&gt;second==1)&#123; it = mp.erase(it); &#125;else&#123; --it-&gt;second; it++; &#125; &#125; &#125; void countElem(vector&lt;int&gt;&amp; nums, map&lt;int,int&gt;&amp; mp,map&lt;int,int&gt;&amp; counter)&#123; for(auto num:nums)&#123; if(mp.find(num)!=mp.end())&#123; if(counter.find(num)==counter.end())&#123; counter[num] = 1; &#125;else&#123; ++counter[num]; &#125; &#125; &#125; &#125;&#125;; c++中map的find方法查找一个键的时间复杂度为O(logn)]]></content>
  </entry>
  <entry>
    <title><![CDATA[虚函数]]></title>
    <url>%2F2019%2F09%2F27%2F%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[虚函数与纯虚函数虚函数基类希望派生类进行覆盖的函数．当我们使用指针或引用调用虚函数时，该调用将被动态绑定．更具体而言，使用基类的引用或指针调用一个虚成员函数时会执行动态绑定．只有使用引用更或者指针调用虚函数时才会发生动态绑定．每一个虚函数都必须提供定义，无论是否用到． 纯虚函数纯虚函数无须定义；可以为纯虚函数提供定义，但是函数体必须定义在类的外部．含有纯虚函数的类是抽象基类，无法被实例化． 静态类型与动态类型一个变量或表达式的静态类型与该表达式表示对象的动态类型必须区分开来．表达式的静态类型和动态类型比较 静态类型 动态类型 变量声明时的类型或表达式生成的类型 变量或表达式表示的内存中的对象的类型 编译时已知 运行时才知道 指针或引用的静态类型和动态类型可能不一致；若表达式既不是引用也不是指针，则它的动态类型和静态类型一致．]]></content>
      <tags>
        <tag>虚函数</tag>
        <tag>动态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parentheses系列]]></title>
    <url>%2F2019%2F09%2F27%2FParentheses%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[括号系列的几道题，涉及到括号匹配，生成括号等等． Valid Parentheses题目链接 Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;&#123;[]&#125;&quot;Output: true 使用一个栈来完成括号的匹配．当遇到一个左括号，入栈；当遇到一个右括号时，查看栈中是否存在对应的左括号．正常的状态是：左右括号的类型和数量都匹配，那么，当整个字符串遍历完成时，栈为空．因此，首先当字符串为空，该字符串必然是valid．若字符串中字符总数为奇数，该字符串必然为invalid．在遍历过程中，如果发现某个右括号不匹配，直接结束遍历过程，并将标记变量改为invalid．遍历结束之后，如果标记变量为valid，此时还需要检查栈是否为空．代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isValid(string s) &#123; if(s.empty())&#123; return true; &#125;else if(s.size() &amp; 1)&#123; return false; &#125; // map的初始化 map&lt;char, char&gt; mp = &#123; &#123;'&#125;','&#123;'&#125;,&#123;')','('&#125;,&#123;']','['&#125; &#125;; stack&lt;char&gt; st; bool isValid = true; for(int i=0;i&lt;s.size();++i)&#123; if(s[i] == '[' || s[i] =='(' || s[i] == '&#123;')&#123; st.push(s[i]); &#125;else if(s[i] == ']' || s[i] == ')' || s[i] == '&#125;')&#123; if(!st.empty() &amp;&amp; mp[s[i]] == st.top())&#123; st.pop(); &#125;else&#123; isValid = false; break; &#125; &#125; &#125; if(isValid) isValid = st.empty() ? true : false; return isValid; &#125;&#125;; 时间复杂度：O(n)空间复杂度：O(1) Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 题目链接 解法1:暴力法依次枚举每个位置上的字符: 对于任意位置i,先将该位置上的字符设为’(‘,然后继续枚举下一个位置,直到所有位置都被枚举完成,判断形成的字符是否有效.处理完第i位上为’(‘之后,继续枚举第i位上为’)’.只需从第0位开始枚举, 将每个位置上都枚举完成,所有可能的字符串都枚举完成,也找出了所有有效的字符串.显然需要递归实现上述思路. 1234567891011121314151617181920212223242526272829bool vaild(string &amp;res) &#123; int bal = 0; for (int i = 0; i &lt; res.size(); ++i) &#123; bal += res[i] == '(' ? 1 : -1; if (bal &lt; 0) &#123; return false; &#125; &#125; return bal == 0;&#125;void generate(string &amp;res, int n) &#123; if (res.size() == n * 2) &#123; if (vaild(res)) &#123; for (auto c : res) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; &#125; else &#123; res.push_back('('); generate(res, n); res.pop_back(); res.push_back(')'); generate(res, n); res.pop_back(); &#125;&#125; 复杂度分析 时间复杂度 当给出n时, 所有可能的字符串有22 * n个. 这是因为共2 * n 个位置上,每个位置上有两种可能. 对于每一个字符串,枚举该字符串并检查该字符串的有效性的时间复杂度为O(n), 因此总的时间复杂度为O(n* 22 * n) 空间复杂度 如上所示,整个递归过程中,只用了一个string,在这个string中,最多只会存放长度为2n的字符串,因此,空间复杂度为O(n) 解法2: 改进版本在上述解法中,当已经能够被枚举的字符串无效时仍然继续枚举下一位置,因此浪费了很多时间.例如,对n=1,当位置0上的字符被设为’)’时,无论后续如何枚举,由这个’)’开始的字符串都是无效的.因此,提前退出枚举过程以减少运行时间. 12345678910111213141516171819void generate(string &amp;res, int n, int bal, vector&lt;string&gt; &amp;ans) &#123; if (res.size() == 2 * n) &#123; if (bal == 0) &#123; ans.push_back(res); &#125; &#125; else &#123; res.push_back('('); generate(res, n, bal + 1, ans); res.pop_back(); // 当我们能确定,被枚举的字符串不可能有效时,提前退出 // 换言之,只有当我们认为被枚举的字符串可能有效时,才继续枚举 if (bal &gt; 0) &#123; res.push_back(')'); generate(res, n, bal - 1, ans); res.pop_back(); &#125; &#125;&#125; 解法3: 闭合数将有效字符串表示为不相交子集的总和.考虑有效括号序列S的闭包数, 至少存在index&gt;=0, 使得S[0], S[1],…,S[2*index+1]是有效的.显然,每个括号序列都有唯一一个的闭包号. 对于每个闭合数c,起始和结束号位于索引0和2c+1.然后位于1-2\c之间的序列和位于2*c+1和2*n之间的序列都是有效序列. 123456789101112131415161718// 生成n对括号的有效序列vector&lt;string&gt; generate(int n) &#123; vector&lt;string&gt; ans; string res = ""; if (n == 0) &#123; ans.push_back(res); &#125; else &#123; for (int i = 0; i &lt; n; ++i) &#123; for (string left: generate(i)) &#123; for (string right: generate(n - 1 - i)) &#123; string tmp = '(' + left + ')' + right; ans.push_back(tmp); &#125; &#125; &#125; &#125; return ans;&#125; valid Parathesis stringGiven a string containing only three types of characters: ‘(‘, ‘)’ and ‘*’, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;. &#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string. An empty string is also valid. Example 1: 12Input: &quot;()&quot;Output: True Example 2: 12Input: &quot;(*)&quot;Output: True Example 3: 12Input: &quot;(*))&quot;Output: True Note: The string size will be in the range [1, 100]. 解法 1:对每个*进行枚举1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool checkValidString(string s) &#123; return checkValidStringCore(s, 0); &#125; bool checkValidStringCore(string&amp; s,int pos)&#123; if(pos == s.size())&#123; return valid(s); &#125; if(s[pos]=='*')&#123; string tmp ="()*"; for(int j=0;j&lt;tmp.size();++j)&#123; s[pos] = tmp[j]; if(checkValidStringCore(s, pos+1))&#123; return true; &#125; &#125; s[pos] = '*'; return false; &#125;else&#123; return checkValidStringCore(s, pos+1); &#125; &#125; bool valid(string s)&#123; int bal = 0; for(int i=0;i&lt;s.size();++i)&#123; if(s[i]=='(')&#123; ++bal; &#125;else if(s[i]==')')&#123; --bal; &#125; if(bal &lt; 0)&#123; return false; &#125; &#125; return bal == 0; &#125;&#125;; 解法2:动态规划 dp[i][j]表示字符串i到j位置上的子串是否有效.若i&gt;j为空串, dp[i][j]=true若i == j, dp[i][j]是否有效取决于字符串i位置上的字符是否为*, 即dp[i][j] = (s[i]==’‘)若i+1==j,则dp[i][j]会在四种情况下有效:s[i] == ‘(‘ &amp;&amp; s[j] == ‘)’s[i] == ‘(‘ &amp;&amp; s[j] == ‘\‘ s[i] == ‘*‘ &amp;&amp; s[j] == ‘)’s[i] == ‘*‘ &amp;&amp; s[j] == ‘*‘ 其余情况下为false若i+1&lt;jdp[i][j] = true只在一种情况下成立,即存在i&lt;k&lt;=j, s[i]和s[k]满足上述四种情况之一,且dp[i][k]=true &amp;&amp; dp[k+1][j]=true 12345678910111213141516171819202122232425262728293031bool checkValidString(string s) &#123; if (s.empty()) &#123; return true; &#125; vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == '*') &#123; dp[i][i] = true; &#125; if (i &lt; s.size() - 1 &amp;&amp; (s[i] == '(' || s[i] == '*') &amp;&amp; (s[i + 1] == ')' || s[i + 1] == '*')) &#123; dp[i][i + 1] = true; &#125; &#125; for (int j = 2; j &lt; s.size(); ++j) &#123; for (int i = 0; i &lt; s.size() - j; ++i) &#123; if (s[i] == '*' &amp;&amp; dp[i + 1][i + j]) &#123; dp[i][i + j] = true; &#125; else if (s[i] == '(' || s[i] == '*') &#123; for (int k = i + 1; k &lt;= i + j; ++k) &#123; if ((s[k] == ')' || s[k] == '*') &amp;&amp; (k == i + 1 || dp[i + 1][k - 1]) &amp;&amp; (k == i + j || dp[k + 1][i + j])) &#123; dp[i][i + j] = true; break; &#125; &#125; &#125; &#125; &#125; return dp[0][s.size() - 1];&#125; 复杂度分析 时间复杂度：O(n3) 空间复杂度：O(n2) 解法3: 贪心lo,hi分别表示尚未匹配的左括号的最少和最大数量.尚未匹配的左括号的最少数量在仅把左括号当做左括号时取得.最大数量在把所有*都当做右括号时取得. 当hi&lt;0时,说明即使把所有*都当做左括号也无法满足左括号和右括号之间的匹配关系,因此,此字符串无效. 当hi&gt;0, 而lo&lt;0时,说明将部分*当做左括号才能满足左括号和右括号之间的匹配关系. 当hi&gt;0, 而lo&gt;0时, 说明左括号的数量多于右括号的数量.尚未匹配的左括号的最少数量还是lo. 当hi=0,lo=0时,说明左括号和右括号的数量相等. 1234567891011121314bool checkValidString(string s) &#123; int lo = 0, hi = 0; for (auto c: s) &#123; lo += c == '(' ? 1 : -1; hi += c != ')' ? 1 : -1; if (hi &lt; 0) &#123; // 即使把所有的*号都看作左括号也不行 return false; &#125; // 如果将所有*号看做右括号时导致左括号较少，则将部分*号看做左括号 lo = max(lo, 0); &#125; return lo == 0; // 最后需要检查是否左右括号彻底抵消&#125; Longest valid parathesis题目链接 解法1:暴力破解列举从每个位置开始的子串能够获得的最大长度.若某位置的字符是’)’,则从该位置获取的最大子串长度为0. 解法2:使用栈如何形成思路? 解法3: 动态规划Score of Parentheses如何区分以位置j结尾的子问题和以位置开始的子问题 Given a balanced parentheses string S, compute the score of the string based on the following rule: () has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: 12Input: &quot;()&quot;Output: 1 Example 2: 12Input: &quot;(())&quot;Output: 2 Example 3: 12Input: &quot;()()&quot;Output: 2 Example 4: 12Input: &quot;(()(()))&quot;Output: 6 Note: S is a balanced parentheses string, containing only ( and ). 2 &lt;= S.length &lt;= 50 解法1:分而治之首先把整个字符串S分成多个子串s1, s2, …,sn.score(S) = score(s1)+score(s1)+…+score(sn) 接下来,计算每个子串si&gt;的分数,子串si有两种可能: 长度为2: score(si)=1 长度大于2:score(si) = 2 * score(si[1:n-1])(假设n为si.size()) 重点是从位置i到位置j中间的某个位置k，能够形成一个子串，这个子串是一个valid string 1234567891011121314151617181920212223242526class Solution &#123;public: int scoreOfParentheses(string S) &#123; if(S.empty())&#123; return 0; &#125; return scoreOfParenthesesCore(S, 0, S.size()-1); &#125; int scoreOfParenthesesCore(string s, int lo, int hi)&#123; int ans = 0, bal = 0; for(int k=lo;k&lt;=hi;++k)&#123; bal += s[k] == '(' ? 1 : -1; if(bal == 0)&#123; if(k - lo == 1)&#123; ans++; &#125;else&#123; ans += 2 * scoreOfParenthesesCore(s, lo + 1, k - 1); &#125; lo = k + 1; &#125; &#125; return ans; &#125;&#125;; 解法２栈解法3count cores]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>Parentheses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数指针]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[函数指针指向的是函数而非对象.和其他指针一样,函数指针指向某种特定类型.函数的类型由它的返回类型和形参类型共同决定,与函数名无关. 123456789101112131415161718bool lengthCompare(const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size();&#125;bool (*pf)(const string &amp;a, const string &amp;b); // pf是一个未初始化的函数指针bool (*pf1)(const string &amp;a, const string &amp;b); // pf1是一个未初始化的函数指针int main()&#123; // 以下两种写法都是等价的 pf = lengthCompare; pf1 = &amp;lengthCompare; // 以下是三个等价的调用 bool fa = pf("hello", "goodbye"); bool fb = pf1("hello", "goodbye"); bool fc = lengthCompare("hello", "goodbye"); return 0; &#125; 当把函数名作为一个值使用时,该函数自动转换为指针,所以, pf = lengthCompare和 pf1 = &amp;lengthCompare是等价的. 函数指针作为实参不能定义函数类型的形参,但是形参可以是指向函数的指针 12345// 第三个形参是函数类型,它会自动转换为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// 显式地将形参定义为指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); 定义函数类型别名和函数指针类型别名decltype返回函数类型,不会将函数类型自动转换为指针类型 12345678// Func和Func2是函数类型typedef bool Func(const string &amp;, const string &amp;);typedef decltype(lengthCompare) Func2; // 等价的类型// FuncP和FuncP2是指向函数的指针typedef bool (*FuncP)(const string &amp;, const string &amp;);typedef decltype(lengthCompare) *FuncP2; useBigger的另外两种等价的声明(使用了类型别名) 12void useBigger(const string &amp;s1, const string &amp;s2,Func);void useBigger(const string &amp;s1, const string &amp;s2,FuncP2); 返回函数指针12using F = int(int*, int); // F是函数类型,不是指针using PF = int(*)(int*,int); // PF是指针类型 使用类型别名定义返回类型为函数指针的函数 1234567PF f1(int); // PF是指向函数的指针,f1返回指向函数的指针F f1(int); // F是函数类型,f1不能返回一个函数类型F* f1(int); // F*是函数类型int (*f1(int))(int *,int); // 直接声明f1// 尾置返回类型auto f1(int) -&gt; int(*)(int *,int); 首先f1有形参列表,所以,f1是个函数,f1的返回值是一个指针.该指针也有形参列表,所以,该指针指向函数.该函数的形参是int和int,返回int.所以,f1是一个返回一个函数int(\)(int *,int)的函数. 一个复杂点的例子 12345678910111213141516171819202122232425262728293031string::size_type sumLength(const string &amp;a, const string &amp;b) &#123; return a.size() + b.size();&#125;string::size_type largerLength(const string &amp;a, const string &amp;b) &#123; return a.size() &gt; b.size() ? a.size() : b.size();&#125;decltype(sumLength) *getFcn(const string &amp;s) &#123; if (s == "+") &#123; return sumLength; &#125; else &#123; return largerLength; &#125;&#125;int main()&#123; typedef string::size_type (*Func)(const string &amp;, const string &amp;); Func fcn = getFcn("+"); // fcn是一个函数指针 // 一种等价形式// auto fcn = getFcn("+"); string::size_type sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; fcn = getFcn("-"); sz = fcn("hello", "good"); cout &lt;&lt; sz &lt;&lt; endl; return 0;&#125; 由于函数的类型由它的返回类型和形参类型决定,而与函数名无关,可知sumLength和largerLength属于相同的类型.所以,我们可以向getFcn传入参数,获取指向同一种函数类型的不同的函数指针.]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变形词]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8F%98%E5%BD%A2%E8%AF%8D%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[此类题比较麻烦，但其实并不难。 242. Valid Anagram49. Group Anagrams找出可以通过改变一个字母变成其他单词的单词许多单词都和另外一些单词想死。例如，通过改变第1个字母，单词wine可以变成dine，fine，line，mine，pine或vine。通过改变第3个字母可以变成wide，wife，wipe或wire以及其他一些单词。通过改变第4个字母可以变成wind，wing，wink或wins以及其他一些单词。我们想要编写一个程序来找出通过单个字母的替换变成至少15个其他单词的单词。假设有一本字典，由大约89000个各种长度的不同单词组成。大部分单词在6到11个字母之间。其中6字母单词8205个，7字母单词11989个，8字母单词13672个，9字母单词13014个，10字母单词11297个，11字母单词8617个。题目来源：数据结构与算法分析(c++语言描述，第4版) p144。]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中数字出现的次数]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%89%BE%E5%87%BA%E7%8E%B0%E4%BB%85%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[数组中只出现一次的数一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。题目来源：剑指offer 56 123456789101112131415161718192021222324252627282930313233unsigned int findFirstBitIs1(int num) &#123; int indexBit = 0; while (((num &amp; 1) == 0) &amp;&amp; (indexBit &lt; 8 * sizeof(int))) &#123; num = num &gt;&gt; 1; ++indexBit; &#125; return indexBit;&#125;bool IsBit1(int num, unsigned int indexBit) &#123; num = num &gt;&gt; indexBit; return (num &amp; 1);&#125;void findNumsAppearOnce(vector&lt;int&gt; data, int *num1, int *num2) &#123; if (data.size() &lt; 2) &#123; return; &#125; int resultExclusiveOR = 0; for (int i = 0; i &lt; data.size(); i++) &#123; resultExclusiveOR ^= data[i]; &#125; unsigned int indexOf1 = findFirstBitIs1(resultExclusiveOR); *num1 = *num2 = 0; for (int i = 0; i &lt; data.size(); i++) &#123; if (IsBit1(data[i], indexOf1)) &#123; *num1 ^= data[i]; &#125; else &#123; *num2 ^= data[i]; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>位运算</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列的最大值]]></title>
    <url>%2F2019%2F09%2F27%2F%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[队列的最大值 Sliding Window Maximum Hard Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: 123456789101112Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 涉及知识点：最小栈，如何用两个队列实现一个栈， 双端队列。 c++ deque基本操作123456void push_front(const T&amp; x) //双端队列头部增加一个元素Xvoid push_back(const T&amp; x) //双端队列尾部增加一个元素xvoid pop_front() //删除双端队列中最前一个元素void pop_back() //删除双端队列中最后一个元素reference front() //返回首元素的引用reference back() //返回尾元素的引用 解法1解法2]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[void*指针]]></title>
    <url>%2F2019%2F09%2F27%2Fvoid*%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[void*是一种特殊的指针类型,可以用于存放任意类型的对象地址.但是我们不知道该指针着存放的地址指向的对象的类型. 1234int d = 102;void *p = &amp;d;int *pa = static_cast&lt;int *&gt;(p);cout &lt;&lt; *pa &lt;&lt; endl; // 102 将指针p强制为int*类型,强制转换过程中应该确保指针的值即指针指向的对象地址不变; 因此我们进行强制转换时,必须确保转换的目标类型就是指针所指的类型,否则,将产生未定义的结果. 那么什么时候使用void*指针呢?未完待续]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>void*指针</tag>
        <tag>static_cast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式匹配]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 题目链接 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str == nullptr || pattern == nullptr)&#123; return false; &#125; return matchCore(str, pattern); &#125; bool matchCore(char *str, char* pattern)&#123; if(*str == '\0' &amp;&amp; *pattern == '\0')&#123; return true; &#125; if(str != '\0' &amp;&amp; pattern == '\0')&#123; return false; &#125; if(*(pattern+1)=='*')&#123; if(*pattern == *str || (*pattern == '.' &amp;&amp; *str != '\0'))&#123; return matchCore(str + 1, pattern + 2) // *匹配1个前向字符, 如a*b匹配aab || matchCore(str + 1, pattern) // *匹配多个前向字符, 如a*b匹配aaab || matchCore(str, pattern + 2);// *匹配0个前向字符， 如a*b 匹配ab &#125; return matchCore(str, pattern + 2); // *str与*pattern不等，*匹配0个前向字符 &#125; if(*str == *pattern || (*pattern == '.' &amp;&amp; *str != '\0')) //当前字符的下一个字符不是* return matchCore(str + 1, pattern + 1); return false; &#125;&#125;; 相似题目: Simplify Path]]></content>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可调用对象]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[可调用对象有函数,函数指针,lambda表达式,函数对象, bind创建的对象等.函数和函数指针不必多说.那么什么是函数对象呢?函数对象是一种重载了调用运算符的类类型.因为重载了调用运算符,所以我们可以像调用函数一样调用类的对象,因为称为函数对象.lambda表达式表示一个可调用的代码单元. 函数对象12345678910111213141516/** * absInt类只定义了一种操作:函数调用运算符 * 此类为函数对象 */struct absInt &#123; int operator()(int val) const &#123; return val &lt; 0 ? -val : val; &#125;&#125;;int main()&#123; absInt absObj; cout &lt;&lt; absObj(42) &lt;&lt; endl; // 42 cout &lt;&lt; absObj(-10) &lt;&lt; endl; // 10 return 0;&#125; 以上代码即定义了一个函数对象.调用该对象就像调用函数一样.仿佛该类型对象是一个函数.还可以定义有数据成员的函数对象 123456789101112131415161718class PrintString &#123;public: PrintString(ostream &amp;o = cout, char c = ' ') : os(o), sep(c) &#123;&#125; void operator()(const string &amp;s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: ostream &amp;os; char sep;&#125;;int main()&#123; PrintString printer; printer("hello"); // 输出hello PrintString errors(cerr, '\n'); string s = "wrong answer"; errors(s); // 输出wrong answer return 0;&#125; lambda表达式lambda表达式在很多语言中都有.lambda可以理解为一个未命名的内联函数,但是与普通函数不同的是,lambda可能定义在函数内部;lambda表达式必须尾置返回; lambda表达式不能有默认参数; lambda表达式的参数列表和返回类型可以省略. 那么在c++中该怎么定义一个lambda表达式呢?一个lambda表达式具有以下形式: 1[capure list](parameter list)-&gt; return type &#123;function body&#125; 其中,捕获列表(capure list)是该lambda表达式所在函数中定义的局部变量(通常为空).参数列表(parameter list), 返回类型, 返回类型(return type)和函数体(function body)与普通函数相同. 当定义一个lambda时,编译器生成一个与lambda对象的新的(未命名的)类类型.当向一个函数传递一个lambda时,同时定义了一个新类型和该类型的一个对象. 123456vector&lt;string&gt; vc&#123;"good", "to", "see", "you", "again"&#125;;for_each(vc.begin(), vc.end(), PrintString(cout, '\n')); // 函数对象// 等价的lambda表达式string sep("\n");for_each(vc.begin(), vc.end(), [sep](const string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; sep; &#125;); 使用函数对象打印出可变数组vc中的元素.同时定义了一个与函数对象PrintString等价的lambda表达式. 捕获变量与参数传递类似,捕获变量也有两种方式,值捕获和引用捕获.采用值捕获需要变量可以拷贝.与参数传递不同,被捕获的变量的值是在lambda创建时拷贝,而不是调用时拷贝.引用捕获需要保证lambda表达式执行时,该引用指向的对象仍然存在. 在一个基本类型为string类型的可变数组中找出第一个长度大于给定值sz的元素.下面分别用函数对象和lambda表达式的形式实现. 123456789101112131415161718192021222324252627class SizeCmp &#123;public: SizeCmp(size_t n) : sz(n) &#123;&#125; bool operator()(const string &amp;a) &#123; return a.size() &gt;= sz; &#125;private: size_t sz;&#125;;int main()&#123; vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;; size_t sz = 6; // 使用lambda表达式// auto wc = find_if(vc.begin(), vc.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;); // 使用等价的函数对象 auto wc = find_if(vc.begin(), vc.end(), SizeCmp(sz)); // wc 为指向第一个长度不小于给定值sz的元素的迭代器 if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl; else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; &#125; //当sz=5时,输出mango;当sz=6时,输出empty result&#125; bind参数绑定标准库的bind函数可以看做一个函数适配器.它接受一个可调用对象,生成一个新的可调用对象. 12345678910111213141516171819bool check_size(const string&amp; s, string::size_type sz)&#123; return s.size() &gt;= sz;&#125;// 给check_size函数的第一个参数绑定一个值// auto check6 = bind(check_size, std::placeholders::_1, 6);auto check6 = bind(check_size, std::placeholders::_1, 5);// 调用check6函数string s = "hello";cout &lt;&lt; check6(s) &lt;&lt; endl;vector&lt;string&gt; vc&#123;"good", "to", "see", "mango", "again", "day", "nana"&#125;;auto wc = find_if(vc.begin(), vc.end(), check6);// wc 为指向第一个长度不小于给定值sz的元素的迭代器if (wc != vc.end()) cout &lt;&lt; (*wc) &lt;&lt; endl;else &#123; cout &lt;&lt; "empty result" &lt;&lt; endl; 可调用对象与function每一个lambda表达式都是一种未命名的新类型;函数对象的类型是该对象的类类型;函数和函数指针的类型由参数列表和返回值决定. 多个调用对象有不同的类型,但是却共享相同的调用形式.调用形式指明了调用返回的类型以及传递给调用的实参类型(如何SizeCmp类型的函数对象和lambda表达式,类型不同,调用形式相同).一种调用形式对应一个函数类型.标准库中function模板可以表示函数类型. 123456789101112map&lt;string, function&lt;int(int, int)&gt;&gt; binops = &#123; &#123;"+", add&#125;, &#123;"-", std::minus&lt;int&gt;()&#125;, &#123;"/", Divide()&#125;, &#123;"*", [](int i, int j) &#123; return i * j; &#125;&#125;, &#123;"%", mod&#125;&#125;;cout &lt;&lt; binops["+"](10, 5) &lt;&lt; endl; // 15cout &lt;&lt; binops["-"](10, 5) &lt;&lt; endl; // 5cout &lt;&lt; binops["%"](11, 4) &lt;&lt; endl; // 3cout &lt;&lt; binops["*"](13, 2) &lt;&lt; endl; // 26 add, Divide(),mod等各个可调用对象的类型各不相同,但是它们都是调用形式为int(int, int)的可调用对象,因此可以赋值给function&lt;int(int,int)&gt;类型的对象.]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>可调用对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找下一个节点]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链接： https://www.nowcoder.com/questionTerminal/60231d6931d543d4aadcb67851b21e4a 请设计一个算法，寻找二叉树中指定结点的下一个结点（即中序遍历的后继）。 给定树的根结点指针TreeNode* root和结点的值int p，请返回值为p的结点的后继结点的值。保证结点的值大于等于零小于等于100000且没有重复值，若不存在后继返回-1。]]></content>
  </entry>
  <entry>
    <title><![CDATA[并查集基础知识]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集(不相交集合)不相交集合数据结构是这样一种数据结构: 它维护了一个不相交动态集的集合 $$S = {s_1, s_2, …, s_i, …, s_k}$$对于每个集合S中的每个元素集合si而言,用集合中的而一个元素来代表该集合.假设x是集合si中的一个元素,则有以下三种操作: make_set(x): 建立一个新的集合,它的唯一成员是x.因为各个集合是不相交的集合, 所以x不会出现在别的集合中.union(x, y): 将包含x和y的两个动态集合(表示为sx和sy合并成一个新的集合, 即这两个集合的并集)find_set(x): 返回一个指针,该指针指向包含x的(唯一)集合的代表.不相交集合可以用于求无向图的连通分量等.待后续加上代码 为了提交效率,建立并查集的过程往往会采用两种策略来提高性能.一种是按秩(秩是指节点高度的一个上界)合并, 另一种是路径压缩.按秩合并是在合并两个集合的过程中, 让具有较小秩的根指向较大秩的根.路径压缩是在查找节点的根节点的过程中, 使查找路径上的每个节点指向指向根(即令根节点成为查找路径上每个节点的父节点). 节点x的秩: 节点x的高度(从节点x到某一后代叶节点的最长简单路径上边的数目)的一个上界.当make_set(x)创建一个单元素x集合时, 节点x的秩为0.使用按秩合并union(x, y)合并两个集合时, 若两个集合的秩不同,则让较大秩的根成为较小秩的根的父节点, 秩本身保持不变.若两个集合的秩相同,则任意选择两个根中的一个作为父节点, 并使它的秩加1. 并查集的实现(伪代码)123456789101112131415161718make_set(x) x.p = x // x的父节点是自己,即x是x所在集合的根节点 x.rank = 0 // x.rank即x的秩link(x, y) if(x.rank &gt; y.rank) y.p = x else x.p = y if(x.rank == y.rank) y.rank = y.rank + 1union(x, y) link(find_set(x), find_set(y))find_set(x) if x != x.p x.p = find_set(x.p) return x.p find_set的非递归形式 12345678find_set(x) a = x while x != x.p x = x.p while a != a.p z = a a = a.p z.p = x]]></content>
      <tags>
        <tag>基础算法</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一个结点]]></title>
    <url>%2F2019%2F09%2F27%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题目链接:https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e 相关题目:寻找下一个节点]]></content>
      <tags>
        <tag>牛客网</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortest Unsorted Continuous Subarray]]></title>
    <url>%2F2019%2F09%2F27%2FShortest%20Unsorted%20Continuous%20Subarray%2F</url>
    <content type="text"><![CDATA[Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length. Example 1: 123Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 解法1:暴力破解假设数组nums长度为n。考虑每一个可能的子数组nums[i:j]，要使得nums[i:j]是最长的未排序子数组，需要满足以下条件：nums[0:i-1]是有序的，nums[j+1:n-1]是有序的。nums[i:j]是无序的，且nums[i:j]中的最小值大于nums[i-1]，nums[i:j]中的最大值小于nums[j+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int res = nums.size(); for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i;j&lt;nums.size();j++)&#123; int min_val = 2147483647; int max_val = -2147483648; int prev = - 2147483648; for(int k=i;k&lt;j;k++)&#123; min_val = min_val &gt; nums[k]? nums[k]:min_left; max_val = max_val &gt; nums[k]? max_val:nums[k]; &#125; // min_val为nums[i:j]中的最小值，max_val为nums[i:j]中的最大值 //nums[0:i]或者nums[j+1:]不满足有序 if((i&gt;0 &amp;&amp; nums[i-1] &gt; min_val) || (j &lt;nums.size() &amp;&amp; nums[j] &lt; max_val))&#123; continue; &#125; int k = 0; //nums[0:i]是有序的 //若能成立则运行完后prev=nums[i-1] while(k &lt; i &amp;&amp; prev &lt;= nums[k])&#123; prev = nums[k]; k++; &#125; if(k!=i) continue; k = j; //nums[j:]是有序的且nums[j] &gt;= nums[i-1] while(k &lt; nums.size() &amp;&amp; prev&lt;=nums[k])&#123; prev = nums[k]; k++; &#125; // 思考一下：为什么要小于呢？ if(k==nums.size())&#123; res = res &gt; j - i ? j - i:res; &#125; &#125; &#125; return res; &#125;&#125;; 解法2：较好一点的暴力破解如果对于nums[i]来说，其前面的数都小于等于它，后面的数都大于等于它，则它的位置是正确的，否则它的位置是错误的。一对相距最远的数的位置就是我们要找的。遍历数组，每次遇到逆序的数就更新左边界和右边界。左边界取较小的，右边界取较大的。 123456789101112131415class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; int l = nums.size(), r = 0; // l是左边界，r是右边界，左边界取较小的，右边界取较大的 for(int i=0;i&lt;nums.size()-1;i++)&#123; for(int j=i+1;j&lt;nums.size();j++)&#123; if(nums[j] &lt; nums[i])&#123; r = r &gt; j? r : j; l = l &lt; i? l : i; &#125; &#125; &#125; return r - l &lt; 0?0:r - l + 1; &#125;&#125;; 时间复杂度为O(n2)。 解法3：使用栈和解法2的思路一样都是不断更新左边界和左边界。 12345678910111213141516171819202122232425class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; stack&lt;int&gt; st; int l = nums.size(), r = 0; for(int i=0;i&lt;nums.size();i++)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &gt; nums[i])&#123; l = l &gt; st.top()? st.top():l; st.pop(); &#125; st.push(i); &#125; while(!st.empty())&#123; st.pop(); &#125; for(int i=nums.size()-1;i&gt;=0;i--)&#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i])&#123; r = r &gt; st.top()?r:st.top(); st.pop(); &#125; st.push(i); &#125; return r - l ? r - l + 1: 0; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(n)。 解法4：两次遍历两次遍历，分别找左边界和右边界。左边界是位置最左，且逆序的数，右边界是位置最右且逆序的数。一个数若大于其后任意一个数就可以判断该数是逆序的。因此，一个数若大于其后最小的一个数既可以看做是逆序的。同样，一个数若小于其前面任意一个数即可认定该数是逆序。因此，一个数若小于其前面最大的一个数即可认定该数是逆序的。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2)&#123; return 0; &#125; int leftmost = -1, rightmost = -1; int min_right = nums[nums.size()-1]; int max_left = nums[0]; for(int i=nums.size()-2;i&gt;=0;i--)&#123; if(nums[i] &gt; min_right)&#123; leftmost = i; &#125;else&#123; min_right = nums[i]; &#125; &#125; if(leftmost == -1)&#123; return 0; &#125; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i] &lt; max_left)&#123; rightmost = i; &#125;else&#123; max_left = nums[i]; &#125; &#125; return rightmost - leftmost + 1; &#125;&#125;; 时间复杂度为O(n)，空间复杂度为O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>连续子数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis使用过程中遇到的问题]]></title>
    <url>%2F2019%2F09%2F27%2Fredis%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述redis使用过程中发现redis返回的数据中str类型都是byte类型。byte类型使用很不方便，所以就想转成str类型。 初始时建立redis连接代码为： 1r1 = redis.Redis(host=redis_host, port=6379, db=1) 在网上搜索了一番，在csdn找到这个答案（详见https://ask.csdn.net/questions/381758）：在建立连接时，将decode_responses置为True。即这样建立连接： 1r1 = redis.Redis(host=redis_host, port=6379, db=1, decode_responses=True) 经过测试，这个问题成功解决了。 redis的字符串redis中的字符串是一种名为sds(简单动态字符串)的抽象数据类型来表示.所有sds API都以处理二进制的方式来处理string类型对象的数据,程序中不对数据做任何的限制,过滤或者假设.]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 易混淆概念之常量指针]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指向常量的指针常量是这样一种变量:它的值不能被改变,因此,常量必须初始化. 指向常量的指针,可以指向常量或者非常量.但是要想用指针来存放常量对象的地址,只能用指向常量的指针.指向常量的指针仅仅要求不能通过该指针改变对象的值,而没有规定该对象的值不能通过其他方式改变.可以这样想: 指向常量的指针, 自以为是地以为自己指向了常量,所以自觉地不去改变该对象的值.同样,可以认为指向非常量的指针,会认为自己指向的是非常量,因此,可能会改变自己指向的变量,因此不能用指向非常量的指针保存常量对象的地址.因为,指向非常量的指针可能会试图改变其指向的常量对象的值. 非常量可以转化为常量.反之则不行. 123456const double pi = 3.14;const double *pip = &amp;pi; // 正确:指向常量的指针const double pi1 = 3.1415;pip = &amp;pi; // 使指向常量的指针pip指向另一个常量double pi2 = 3.1415926;pip = &amp;pi2; // 指向常量的指针pip指向一个非常量 常量指针常量指针是指指针本身是常量,即指针一旦指向某个对象就不能再改变(指针中保存的那个地址就不再改变了).因此同常量一样,常量指针必须初始化. 指针本身是常量只规定了指针不能指向其他对象,而并没有规定不能通过指针修改其所指向对象的值,能否只有做完全取决于所指对象的类型.常量指针既可以指向常量也可以指向非常量,具体指向的是常量还是非常量,取决于定义该指针时所指向对象的基本数据类型. 12345int errNumb = 0;int *const curErr = &amp;errNumb; // 指向非常量的常量指针 curErr常量指针,始终指向errNumb*curErr = 1; // 通过指向非常量的常量指针修改其所指向对象的值const double pi = 3.14;const double *const pip = &amp;pi; // 指向常量的常量指针pip 常量指针this类的成员函数调用时,用请求该函数的对象地址初始化this.在整个调用过程中,this所指向的都是发起该调用的对象.默认情况下,this的类型是指向非常量版本的常量指针.如类类型的名为sales_data, 则this指针的类型是sales_data *const. 又如果想要用指针来保存常量对象的地址,只能使用指向常量的指针, 所以,我们不能把类型为sales_data const的this指向一个常量对象.也因此,不能在一个常量对象上调用普通的成员函数.如果想要常量对象也能调用该成员函数,那么必须要把this指针的类型设置成指向常量的常量指针,即*const sales_data const*声明成员函数时,紧随参数列表的const的作用就是将this指针的类型声明成指向常量的常量指针.像这样使用construction的成员函数被称作常量成员函数,常量成员函数内部不能改变this指针所指向的对象的内容(即调用此成员函数的对象的内容). 1234class sales_data&#123; void f(); // 常量对象不能调用此函数 void f() const; // 此函数是常量成员函数,常量对象也可以调用,this指针指向的是常量对象(也可以是非常量对象)&#125;]]></content>
      <categories>
        <category>指针</category>
      </categories>
      <tags>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++数据类型基础]]></title>
    <url>%2F2019%2F09%2F27%2Fc%2B%2B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文主要是总结一下C++语言常用的数据类型基础知识，如类型转换，整形的最大最小数值等。 无符号数示例1 1234unsigned int u = 0xFFFFFFFF;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //4294967295u -= 31;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl;//4294967264 无符号数0xFFFFFFFF是32位无符号数中的最大值。 示例2：无符号数和有符号数运算 12345unsigned int u = 10;int i = -42;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; // 10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967296 + (-42)cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl; // 4294967264 无符号数u和有符号数i相加前，把有符号数i转换为无符号数，结果等于两个无符号数相加。 示例3： 12345unsigned int u = 10;int i = -1;cout&lt;&lt;"u="&lt;&lt;u&lt;&lt;endl; //10cout&lt;&lt;"unsigned(i)="&lt;&lt;unsigned(i)&lt;&lt;endl;//4294967295cout&lt;&lt;"(i+u) ="&lt;&lt;(i+u)&lt;&lt;endl;//(4294967295 + 10) % (4294967296)，其中4294967296是2的32次方 两个无符号数相加结果超出它表示范围时，先对这个超出表示范围的结果进行取模(对2的n次方进行取模)，则得到了真正的结果。 示例4：无符号数都是整数。若给无符号赋值一个负数，则将该负数+2n得到最后的结果。 123456unsigned int x = 0xFFFFFFFF;unsigned int u = 10;unsigned int v = 42;cout&lt;&lt;"x:"&lt;&lt;x&lt;&lt;endl;cout&lt;&lt;"(v - u):"&lt;&lt;(v - u)&lt;&lt;endl; // 32cout&lt;&lt;"(u - v):"&lt;&lt;(u - v)&lt;&lt;endl; // 4294967264: (-32 + 4294967296) % 4294967296的结果 示例5：当表达式中既有带符号数又有无符号数时，当带符号数值为负数时会出现异常情况，这是因为带符号数会自动转换成无符号数。 123unsigned int x = 1;int y = -1;cout&lt;&lt;"x * y="&lt;&lt;(x * y)&lt;&lt;endl; //4294967295，y转换为无符号数(-1 + 4294967296) = 4294967295 常用的一些16进制数 0xffffffff 0xffffffff是一个十六进制数。把它转换成2进制为：1111111..11(32个1)把它转成10进制无符号数是：0xffffffff = 16x10^7+ 16x10^6+….+16x10^1+16x10^0 = 4294967295把它转成10进制带符号整数为：111111111111111(32个1表示的补码形式)转化为源码形式为10…00001(中间30个0)，即-1。 1234unsigned int a = 0xffffffff;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // 4294967295int b = 0xffffffff; cout&lt;&lt;"b="&lt;&lt;b&lt;&lt;endl; // b = -1 0x3f3f3f3f 0x3f3f3f3f用于表示无穷大．它具有诸多优良性质．无穷大 + 无穷大 ＝ 无穷大无穷大 + 常数 = 无穷大 异或运算异或运算满足交换律与结合律。C = A ^ B (^是异或运算符)，则 A = B ^ C, B = A ^ C 例1. A = 1011, B = 0101 , C= 1110若A和B在某一位上都是1， 则C在该位上为0，则A或B的该位与C的该位相与就是1；若A和B在某一位上都是0， 则C在该位上为0，则A或B的该位与C的该位相与就是0。若A在某一位为1， B在该位为0， 则C在该位上为1，则A的该位与C的该位相与就是0，B的该位与C的该位相与就是1。同理，A在该位为0，B在该位为1时可证成立。 按位取反~1234567int a = -2147483648;cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl; // -2147483648cout&lt;&lt;" ~a="&lt;&lt;~a&lt;&lt;endl; // 2147483647bitset&lt;32&gt; b1(a); bitset&lt;32&gt; b2(~a); cout&lt;&lt;"a: "&lt;&lt;b1.to_string()&lt;&lt;endl;// 10..00cout&lt;&lt;" ~a: "&lt;&lt;b2.to_string()&lt;&lt;endl;// 011..11 补码、原码、求补运算负数的补码由其原码对除符号位外各位取反末位加1，同样，由补码求原码也是对补码除符号位外，各位取反末位加1。求补运算：不考虑符号位，对原码各位取反，并在末位加1。对一个数进行求补运算得到的是其相反数的补码。如对0111进行求补运算，0111的真值为7。其补数为1001（补码），补码1001对应的源码为1111，真值为-7。 n &amp;(~n+1)这个表达式常用来取n中最右侧的1。这是因为, ~n是对进行按位取反。例如：n = 1000，n=0111, ~n+1 = 1000, n &amp; (n+1)=1000，只有n中最右边为1的位置为1。n = 1010， n=0101，n+1=0110, n &amp; (~n+1)=0010。 参考文献[1] 0x3f3f3f3f: https://blog.csdn.net/hzh_0000/article/details/9468377]]></content>
      <categories>
        <category>C++基础知识</category>
      </categories>
      <tags>
        <tag>无符号数</tag>
        <tag>补码</tag>
        <tag>原码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Validate Stack Sequences(946)]]></title>
    <url>%2F2019%2F09%2F27%2F946.%20Validate%20Stack%20Sequences%2F</url>
    <content type="text"><![CDATA[Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: 12345Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 Example 2: 123Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 题意是说，给定一个入栈序列和一个可能的出栈序列，问在给定的入栈序列下能否得到出栈序列。如果能返回true，否则返回false。 此题的解决是模拟。模拟入栈入栈并出栈的问题，尽量得到和给定的出栈序列一致的出栈序列。如例1，首先为了得到第一个出栈的是4，则必须将[1,2,3,4]入栈，然后将4出栈，则从栈底到栈顶的元素分别为[1,2,3]。第二步，为了得到出栈序列中的第二位5，必须将5入栈，然后将5出栈，得到出栈序列中的第二位，此时，栈中栈底到栈顶的各元素分别为[1,2,3]。第三步为了得到3，直接将栈顶元素出栈即可。第四步和第五步同第三步。 对于例2，同样，第一步为了得到出栈序列中的4，将1,2,3,4依次入栈，并将4出栈，得到出栈序列中的第一位，此时栈底到栈顶的各元素为[1,2,3]。第二步，为了得到出栈序列中的第二位3，将此时的栈顶元素3直接出栈即可。第三步，为了得到5，将5入栈，继而出栈，得到出栈序列[4,3,5]。第四步，需要得到出栈序列中的第四位1，每一步当我们希望得到出栈序列中的下一位时，我们有两个选择，要么这一位还未入栈，如第一步中的4，对于这种情况，我们需要将后续元素入栈，另一种情况是，这一位就是栈顶元素，如第二步中的3。此时，所有入栈序列中的元素都已经入栈，那么只有一种可能了，那就是出栈序列中的下一位就是栈顶元素。但是，通过比较出栈序列中的下一位和栈顶元素可知，栈顶元素不是出栈序列中的下一位，因此，此出栈序列无法由入栈序列得到，返回false。 AC代码 123456789101112131415161718class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; st; int k = 0; for(int i=0;i&lt;popped.size();i++)&#123; while(k &lt; pushed.size() &amp;&amp; (st.empty() || st.top()!=popped[i]))&#123; st.push(pushed[k++]); &#125; if(st.top()==popped[i])&#123; st.pop(); &#125;else&#123; return false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[877. Stone Game]]></title>
    <url>%2F2019%2F09%2F27%2F877.Stone-Game%2F</url>
    <content type="text"><![CDATA[Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. 相关题目: 486. Predict the Winner Example 1: 12345678Input: [5,3,4,5]Output: trueExplanation: Alex starts first, and can only take the first 5 or the last 5.Say he takes the first 5, so that the row becomes [3, 4, 5].If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.This demonstrated that taking the first 5 was a winning move for Alex, so we return true. 错误的思路一开始以为可以用双指针的方式解决：每次贪心，选择从排在最前面和最后面的石头堆里选择数量较大的那堆。后来发现我太天真了。比如说这个例子： Example 1[5,3,2,7,5,2] 如果按照上面的贪心办法，那么alex会选到:5,2(选择最前面的2),5 5+2+5=12lee选到剩下的3,7,2 3+7+2=12所以结果返回false.但是如果alex这么选：5, 2（选择排序最后的2）,7 5+2+7 =14. lee选择剩下的3,2,5 3+2+5=10结果返回true。 123456789101112131415161718192021222324252627bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k; k = 0; i = 0, j = piles.size()-1; int sum_alex=0, sum_lee=0; while(k&lt;piles.size())&#123; int select; if(piles[i]&gt;=piles[j])&#123; select = piles[i]; i++; &#125;else&#123; select = piles[j]; j--; &#125; if(k&amp;1)&#123; // lee sum_lee += select; &#125;else&#123; // alex sum_alex+= select; &#125; k++; &#125; cout&lt;&lt;"sum_alex="&lt;&lt;sum_alex&lt;&lt;" sum_lee="&lt;&lt;sum_lee&lt;&lt;endl; if(sum_alex &gt; sum_lee)&#123; return true; &#125; return false;&#125; 想到的第二种解法：回溯. 悲催的是，超时了。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int i, j, k, ans, best; k = 0; i = 0, j = piles.size()-1; ans = 0, best = 0; int sum = 0; for(auto pile:piles)&#123; sum+=pile; &#125; dfs(ans, best, k, piles, i, j); if(best &gt; sum - best)&#123; return true; &#125; return false; &#125; void dfs(int &amp;ans,int &amp;best, int k, vector&lt;int&gt;&amp;piles, int i, int j)&#123; if(i==j)&#123; if(best &lt; ans)&#123; best = ans; &#125; return; &#125; // 选择i ans += k%2==0?piles[i]:0; dfs(ans, best, k+1, piles, i+1, j); ans -= k%2==0?piles[i]:0; // 选择j ans += k%2==0?piles[j]:0; dfs(ans, best, k+1, piles, i, j-1); ans -= k%2==0?piles[j]:0; &#125;&#125;; 那么接下来，我能想到的唯一可能求解的方法就是动态规划的了，那么问题来了，状态转移方程怎么写呢？ 暴力搜索自顶向下1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), -1)); int stoneNum = getStones(piles, 0, piles.size()-1, nums); return stoneNum &gt; (sum / 2); &#125; int getStones(vector&lt;int&gt;&amp; stones, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp;nums)&#123; if(i &lt;= j)&#123; if(nums[i][j]!=-1)&#123; return nums[i][j]; &#125; int sn1 = 0, sn2 = 0, sn = 0; // when there are even number of piles stones, it`s Alex`s turn if((j - i + 1) % 2 == 0)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) + stones[i] : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) + stones[j] : nums[i][j-1] ; &#125;else&#123; if(i &lt; j)&#123; sn1 = nums[i+1][j] == -1 ? getStones(stones, i+1, j, nums) : nums[i+1][j] ; sn2 = nums[i][j-1] == -1 ? getStones(stones, i, j-1, nums) : nums[i][j-1] ; &#125; &#125; sn = sn1 &gt; sn2 ? sn1 : sn2; nums[i][j] = sn; return sn; &#125;else&#123; return 0; &#125; &#125;&#125;; 时间复杂度：当剩余可以选择的石头堆数为偶数时，说明此时轮到Alex选择．当Alex选择时，他可以从最左边也可以从最右边选择一堆石头，若他选择最左边的一堆，左边界i++，否则，右边界j–． 自底向上12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;vector&lt;int&gt;&gt; nums(piles.size(), vector&lt;int&gt;(piles.size(), 0)); for(int i=0;i&lt;piles.size();i++)&#123; nums[i][i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=0;i &lt; nums.size() - k;i++)&#123; if(k % 2 == 0)&#123; nums[i][i+k] = max(nums[i][i+k-1] + piles[i + k], nums[i+1][i+k] + piles[i]); &#125;else&#123; nums[i][i+k] = max(nums[i][i+k-1], nums[i+1][i+k]); &#125; &#125; &#125; return nums[0][nums.size()-1] &lt;= (sum / 2); &#125; &#125;; 时间复杂度：O(n2) 空间复杂度：O(n2) 此时此题被转化成了Lee能够获得的最多的石头个数．nums[i][j]表示的是当Lee只能在第i到第j堆石头之间选择时，他能够获得最大石头数量．显然，nums[i][i]=piles[i]，也就是最后一次选择时，Lee只能选择第i堆石头．当i &lt; j时，当剩余可以选择的石头堆数为奇数时，即轮到Lee选择，此时，Lee有两种选择方法nums[i][j] = max(nums[i][j-1] + piles[j] , nums[i+1][j] + piles[i])Alex取胜的条件时，Lee能获得最多的石头数量仍然小于此时Alex能获得石头数量． 空间压缩12345678910111213141516171819202122232425262728class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; if(piles.size()==0)&#123; return false; &#125; int sum = 0; for(int i=0;i&lt;piles.size();i++)&#123; sum += piles[i]; &#125; vector&lt;int&gt; nums(piles.size(),0); for(int i=0;i&lt;piles.size();i++)&#123; nums[i] = piles[i]; &#125; for(int k=1;k&lt;piles.size()-1;k++)&#123; for(int i=nums.size()-k-1; i &gt;= 0;i--)&#123; if(k % 2 == 0)&#123; nums[i] = max(nums[i] + piles[i + k], nums[i+1] + piles[i]); &#125;else&#123; nums[i] = max(nums[i], nums[i+1]); &#125; &#125; &#125; return nums[0] &lt;= (sum / 2); &#125; &#125;; 代码未能AC, 还需要考虑.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2F2019%2F09%2F27%2F179.-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; 1234567891011121314151617181920212223242526class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())&#123; return ""; &#125; vector&lt;string&gt; sarr; for(int i=0;i&lt;nums.size();i++)&#123; sarr.push_back(to_string(nums[i])); &#125; sort(sarr.begin(), sarr.end(), compare); string res = ""; for(int i=0;i&lt;sarr.size();i++)&#123; res += sarr[i]; if(i==0 &amp;&amp; sarr[i]=="0")&#123; break; &#125; &#125; return res; &#125; static int compare(string c, string d)&#123; string s1 = c + d; string s2 = d + c; return s1 &gt; s2; &#125;&#125; 总结:学到一种构造cmp函数的方法.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>谓词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[62. Unique Paths]]></title>
    <url>%2F2019%2F09%2F27%2F62.%20Unique%20Paths%2F</url>
    <content type="text"><![CDATA[A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 本题很简单,只需要在暴力搜索的基础上加上计划化搜索就行.这里不再赘述思路,详情请见代码. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m &lt;= 0 || n &lt;= 0)&#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; res(m, vector&lt;int&gt;(n, -1)); return dfs(m, n, 0, 0, res); &#125; int dfs(int m, int n, int posx, int posy, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(res[posx][posy] != -1)&#123; return res[posx][posy]; &#125; if(posx == m - 1 &amp;&amp; posy == n-1)&#123; res[posx][posy] = 1; return 1; &#125; int s1, s2; if(posx +1 &lt; m)&#123; s1 = res[posx+1][posy] == -1 ? dfs(m, n, posx + 1, posy, res) : res[posx+1][posy]; &#125;else&#123; s1 = 0; &#125; if(posy + 1 &lt; n)&#123; s2 = res[posx][posy+1] == -1 ? dfs(m, n, posx, posy +1, res) : res[posx][posy+1]; &#125;else&#123; s2 = 0; &#125; res[posx][posy] = s1 + s2; return s1 + s2; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dynamic programming</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题目分类总结]]></title>
    <url>%2F2019%2F09%2F27%2Fleetcode%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这里将leetcode上刷的题目做一下分类． 纸牌博弈问题系列几道同类题目: Nim Game 此题较简单 stone game 此题首先需要定义递归函数,写出最简朴的做法 如何确定循环变量i和j的遍历方向 是否可以进行空间压缩,如何可以,如何压缩 stone game II 和stone game相比,有什么区别与联系 Predict the Winner 题号486 此题与上题几乎一模一样,但是需要注意,当player1与player2相等时的边界情况. Can I win 与上面两题之间有什么的联系与区别? 排列系列 Permutation Sequence 线段树系列 Range Sum Query - Mutable Count of Smaller Numbers After Self 广度优先搜索 Minimum Depth of Binary Tree 广度优先搜索专题：https://leetcode.com/tag/breadth-first-search/ 排列 Permutation Sequence(题号60) 百度之星[度度熊与排列] 题目链接 next permutation题目链接]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归这里</tag>
      </tags>
  </entry>
</search>
